<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Warper - Complete</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
</head>
<body class="min-h-screen bg-gray-900 p-6">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-bold text-white text-center mb-6">SVG Warper - Full Layer & Image Support</h1>
        
        <!-- Upload -->
        <div class="bg-gray-800 rounded-xl p-4 mb-4">
            <input type="file" id="svgInput" accept=".svg" 
                class="w-full text-white file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:bg-purple-600 file:text-white file:cursor-pointer">
        </div>

        <!-- Controls -->
        <div class="bg-gray-800 rounded-xl p-4 mb-4">
            <div class="grid grid-cols-4 gap-4">
                <div>
                    <label class="text-white text-sm block mb-1">Path Samples: <span id="samplesVal">150</span></label>
                    <input type="range" id="pathSamples" min="50" max="300" value="150" class="w-full accent-purple-500">
                </div>
                <div>
                    <label class="text-white text-sm block mb-1">Image Mesh: <span id="meshVal">30</span></label>
                    <input type="range" id="imageMesh" min="10" max="60" value="30" class="w-full accent-purple-500">
                </div>
                <div>
                    <label class="text-white text-sm block mb-1">Bend: <span id="bendVal">100</span>%</label>
                    <input type="range" id="bendAmount" min="0" max="100" value="100" class="w-full accent-purple-500">
                </div>
                <div>
                    <label class="text-white text-sm block mb-1">Smooth: <span id="smoothVal">0.5</span></label>
                    <input type="range" id="smoothing" min="0" max="10" value="5" step="1" class="w-full accent-purple-500">
                </div>
            </div>
            <div class="flex gap-4 mt-4">
                <button id="applyWarp" class="flex-1 bg-purple-600 hover:bg-purple-700 text-white py-3 rounded-lg font-semibold">
                    üîÑ Apply Warp
                </button>
                <button id="downloadSvg" class="flex-1 bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-semibold hidden">
                    üì• Download SVG
                </button>
            </div>
        </div>

        <!-- Preview Grid -->
        <div class="grid grid-cols-2 gap-4 mb-4">
            <div class="bg-gray-800 rounded-xl p-4">
                <h2 class="text-white text-lg mb-2">Original</h2>
                <div id="original" class="bg-white rounded-lg p-2 min-h-[200px] flex items-center justify-center">
                    <span class="text-gray-500">Upload SVG</span>
                </div>
            </div>
            <div class="bg-gray-800 rounded-xl p-4">
                <h2 class="text-white text-lg mb-2">Target Shape</h2>
                <div class="bg-gray-700 rounded-lg p-2">
                    <svg viewBox="0 0 837 244" class="w-full">
                        <path d="M1.37,162.42L73.32,242.27C283.84,56.41,576.84,75.5,764.01,242.27L835.96,162.42C597.61,-50.29,240.85,-53.15,1.37,162.42Z" 
                              fill="rgba(168,85,247,0.3)" stroke="#a855f7" stroke-width="2"/>
                    </svg>
                </div>
            </div>
        </div>

        <!-- Layers -->
        <div class="bg-gray-800 rounded-xl p-4 mb-4">
            <h2 class="text-white text-lg mb-2">Layers</h2>
            <div id="layers" class="bg-gray-700 rounded-lg p-2 max-h-[150px] overflow-y-auto text-gray-400 text-sm">
                Upload SVG to see layers
            </div>
        </div>

        <!-- Result -->
        <div class="bg-gray-800 rounded-xl p-4">
            <h2 class="text-white text-lg mb-2">Warped Result</h2>
            <div id="result" class="bg-white rounded-lg p-2 min-h-[250px] flex items-center justify-center">
                <span class="text-gray-500">Click "Apply Warp" to generate</span>
            </div>
            <div id="status" class="text-gray-400 text-sm mt-2"></div>
        </div>
    </div>

    <canvas id="paperCanvas" style="display:none"></canvas>
    <canvas id="imageCanvas" style="display:none"></canvas>

    <script>
        paper.setup('paperCanvas');

        // Shape config
        const SHAPE = {
            width: 837,
            height: 244,
            path: "M1.37,162.42L73.32,242.27C283.84,56.41,576.84,75.5,764.01,242.27L835.96,162.42C597.61,-50.29,240.85,-53.15,1.37,162.42Z",
            top: [
                {x: 835.96, y: 162.42},
                {x: 597.61, y: -50.29},
                {x: 240.85, y: -53.15},
                {x: 1.37, y: 162.42}
            ],
            bottom: [
                {x: 73.32, y: 242.27},
                {x: 283.84, y: 56.41},
                {x: 576.84, y: 75.5},
                {x: 764.01, y: 242.27}
            ]
        };

        // State
        let originalSvg = null;
        let svgText = '';
        let warpedSvgString = '';

        // DOM elements
        const svgInput = document.getElementById('svgInput');
        const originalDiv = document.getElementById('original');
        const resultDiv = document.getElementById('result');
        const layersDiv = document.getElementById('layers');
        const statusDiv = document.getElementById('status');
        const applyBtn = document.getElementById('applyWarp');
        const downloadBtn = document.getElementById('downloadSvg');
        const pathSamples = document.getElementById('pathSamples');
        const imageMesh = document.getElementById('imageMesh');
        const bendAmount = document.getElementById('bendAmount');
        const smoothing = document.getElementById('smoothing');

        // Update labels
        pathSamples.oninput = () => document.getElementById('samplesVal').textContent = pathSamples.value;
        imageMesh.oninput = () => document.getElementById('meshVal').textContent = imageMesh.value;
        bendAmount.oninput = () => document.getElementById('bendVal').textContent = bendAmount.value;
        smoothing.oninput = () => document.getElementById('smoothVal').textContent = (smoothing.value / 10).toFixed(1);

        // Bezier curve calculation
        function bezier(p0, p1, p2, p3, t) {
            const mt = 1 - t;
            return {
                x: mt*mt*mt*p0.x + 3*mt*mt*t*p1.x + 3*mt*t*t*p2.x + t*t*t*p3.x,
                y: mt*mt*mt*p0.y + 3*mt*mt*t*p1.y + 3*mt*t*t*p2.y + t*t*t*p3.y
            };
        }

        // Warp point from source to target shape
        function warpPoint(x, y, srcW, srcH, blend) {
            // Normalize to 0-1
            const u = Math.max(0, Math.min(1, x / srcW));
            const v = Math.max(0, Math.min(1, y / srcH));

            // Top curve goes right-to-left, so use (1-u)
            const top = bezier(SHAPE.top[0], SHAPE.top[1], SHAPE.top[2], SHAPE.top[3], 1 - u);
            // Bottom curve goes left-to-right
            const bot = bezier(SHAPE.bottom[0], SHAPE.bottom[1], SHAPE.bottom[2], SHAPE.bottom[3], u);

            // Lerp between top and bottom
            const wx = top.x + (bot.x - top.x) * v;
            const wy = top.y + (bot.y - top.y) * v;

            // Linear position (no warp)
            const lx = u * SHAPE.width;
            const ly = v * SHAPE.height;

            // Blend
            return {
                x: lx + (wx - lx) * blend,
                y: ly + (wy - ly) * blend
            };
        }

        // Load SVG
        svgInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            svgText = await file.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            originalSvg = doc.documentElement;

            // Check for parse errors
            const parseError = doc.querySelector('parsererror');
            if (parseError) {
                alert('Invalid SVG file');
                return;
            }

            // Show original
            originalDiv.innerHTML = '';
            const clone = originalSvg.cloneNode(true);
            clone.style.maxWidth = '100%';
            clone.style.maxHeight = '250px';
            originalDiv.appendChild(clone);

            // Show layers
            showLayers(originalSvg);
            
            status('SVG loaded. Click "Apply Warp" to process.');
        });

        // Show layers
        function showLayers(svg) {
            layersDiv.innerHTML = '';
            
            function walk(el, depth) {
                if (el.nodeType !== 1) return;
                const tag = el.tagName.toLowerCase();
                if (['defs', 'style', 'metadata', 'title', 'desc', 'sodipodi:namedview', 'inkscape:defs'].includes(tag)) return;

                const name = el.id || el.getAttribute('inkscape:label') || tag;
                const hasImage = tag === 'image' || el.querySelector('image');
                
                const row = document.createElement('div');
                row.className = 'flex items-center gap-2 py-1';
                row.style.paddingLeft = (depth * 12) + 'px';
                row.innerHTML = `
                    <input type="checkbox" checked class="layer-cb accent-purple-500" data-id="${el.id || ''}">
                    <span class="text-white">${name}</span>
                    <span class="text-gray-500 text-xs">&lt;${tag}&gt;</span>
                    ${hasImage ? '<span class="text-yellow-400 text-xs">üì∑</span>' : ''}
                `;
                layersDiv.appendChild(row);

                if (tag === 'g' || tag === 'svg') {
                    [...el.children].forEach(c => walk(c, depth + 1));
                }
            }

            [...svg.children].forEach(c => walk(c, 0));
        }

        // Status message
        function status(msg) {
            statusDiv.textContent = msg;
        }

        // Apply warp
        applyBtn.addEventListener('click', async () => {
            if (!originalSvg) {
                alert('Please upload an SVG first');
                return;
            }

            applyBtn.disabled = true;
            applyBtn.textContent = '‚è≥ Processing...';
            status('Processing SVG...');

            try {
                await new Promise(r => setTimeout(r, 50)); // Allow UI update

                const samples = parseInt(pathSamples.value);
                const mesh = parseInt(imageMesh.value);
                const blend = parseInt(bendAmount.value) / 100;
                const smooth = parseFloat(smoothing.value) / 10;

                // Get source dimensions
                const vb = originalSvg.getAttribute('viewBox');
                let srcW, srcH;
                if (vb) {
                    const parts = vb.split(/[\s,]+/).map(Number);
                    srcW = parts[2] || 100;
                    srcH = parts[3] || 100;
                } else {
                    srcW = parseFloat(originalSvg.getAttribute('width')) || 400;
                    srcH = parseFloat(originalSvg.getAttribute('height')) || 200;
                }

                // Clone SVG
                const warpedSvg = originalSvg.cloneNode(true);
                warpedSvg.setAttribute('viewBox', `0 0 ${SHAPE.width} ${SHAPE.height}`);
                warpedSvg.setAttribute('width', SHAPE.width);
                warpedSvg.setAttribute('height', SHAPE.height);
                warpedSvg.removeAttribute('style');

                // Process all elements
                await processElement(warpedSvg, srcW, srcH, samples, mesh, blend, smooth, null);

                // Add clip path
                addClipPath(warpedSvg);

                // Show result
                resultDiv.innerHTML = '';
                warpedSvg.style.maxWidth = '100%';
                resultDiv.appendChild(warpedSvg);

                warpedSvgString = new XMLSerializer().serializeToString(warpedSvg);
                downloadBtn.classList.remove('hidden');
                status('‚úÖ Warp complete! All layers and images preserved.');

            } catch (err) {
                console.error(err);
                status('‚ùå Error: ' + err.message);
            }

            applyBtn.disabled = false;
            applyBtn.textContent = 'üîÑ Apply Warp';
        });

        // Process element recursively
        async function processElement(el, srcW, srcH, samples, mesh, blend, smooth, parentTransform) {
            const tag = el.tagName?.toLowerCase();
            if (!tag) return;

            // Skip non-visual elements
            if (['defs', 'style', 'metadata', 'title', 'desc', 'clipPath', 'mask', 'pattern', 'linearGradient', 'radialGradient', 'filter'].includes(tag)) {
                return;
            }

            // Get element transform and combine with parent
            let transform = getTransformMatrix(el);
            if (parentTransform) {
                transform = multiplyMatrix(parentTransform, transform);
            }

            // Process based on type
            switch (tag) {
                case 'path':
                    await warpPath(el, srcW, srcH, samples, blend, smooth, transform);
                    break;
                case 'rect':
                    await warpRect(el, srcW, srcH, samples, blend, smooth, transform);
                    break;
                case 'circle':
                    await warpCircle(el, srcW, srcH, samples, blend, smooth, transform);
                    break;
                case 'ellipse':
                    await warpEllipse(el, srcW, srcH, samples, blend, smooth, transform);
                    break;
                case 'line':
                    await warpLine(el, srcW, srcH, samples, blend, smooth, transform);
                    break;
                case 'polyline':
                case 'polygon':
                    await warpPoly(el, srcW, srcH, samples, blend, smooth, transform);
                    break;
                case 'text':
                    warpText(el, srcW, srcH, blend, transform);
                    break;
                case 'image':
                    await warpImage(el, srcW, srcH, mesh, blend, transform);
                    break;
                case 'use':
                    warpUse(el, srcW, srcH, blend, transform);
                    break;
                case 'g':
                case 'svg':
                case 'a':
                case 'switch':
                    // Process children with accumulated transform
                    // FIXED: Don't remove transform attribute from groups
                    for (const child of [...el.children]) {
                        await processElement(child, srcW, srcH, samples, mesh, blend, smooth, transform);
                    }
                    // Don't clear transform on group - transformations are baked into children's coordinates
                    // el.removeAttribute('transform'); // REMOVED THIS LINE
                    break;
            }
        }

        // Get transform matrix from element
        function getTransformMatrix(el) {
            const t = el.getAttribute('transform');
            if (!t) return [1, 0, 0, 1, 0, 0];

            // Create temporary SVG to parse transform
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', t);
            svg.appendChild(g);
            document.body.appendChild(svg);
            
            try {
                const ctm = g.getCTM() || svg.createSVGMatrix();
                document.body.removeChild(svg);
                return [ctm.a, ctm.b, ctm.c, ctm.d, ctm.e, ctm.f];
            } catch (e) {
                document.body.removeChild(svg);
                return [1, 0, 0, 1, 0, 0];
            }
        }

        // Multiply two 2D transform matrices
        function multiplyMatrix(m1, m2) {
            return [
                m1[0]*m2[0] + m1[2]*m2[1],
                m1[1]*m2[0] + m1[3]*m2[1],
                m1[0]*m2[2] + m1[2]*m2[3],
                m1[1]*m2[2] + m1[3]*m2[3],
                m1[0]*m2[4] + m1[2]*m2[5] + m1[4],
                m1[1]*m2[4] + m1[3]*m2[5] + m1[5]
            ];
        }

        // Apply matrix to point
        function applyMatrix(m, x, y) {
            return {
                x: m[0]*x + m[2]*y + m[4],
                y: m[1]*x + m[3]*y + m[5]
            };
        }

        // Warp path
        async function warpPath(el, srcW, srcH, samples, blend, smooth, matrix) {
            const d = el.getAttribute('d');
            if (!d || !d.trim()) return;

            try {
                const pathData = warpPathData(d, srcW, srcH, samples, blend, smooth, matrix);
                el.setAttribute('d', pathData);
                el.removeAttribute('transform');
            } catch (err) {
                console.warn('Path warp failed:', err);
            }
        }

        // Warp path data string
        function warpPathData(d, srcW, srcH, samples, blend, smooth, matrix) {
            // Use Paper.js to parse and sample path
            const path = new paper.Path(d);
            
            if (path.length === 0) {
                path.remove();
                return d;
            }

            const isClosed = path.closed;
            const numPoints = Math.max(samples, Math.ceil(path.length / 2));
            const points = [];

            for (let i = 0; i <= numPoints; i++) {
                const offset = (i / numPoints) * path.length;
                let pt = path.getPointAt(offset);
                if (!pt) continue;

                // Apply transform
                const transformed = applyMatrix(matrix, pt.x, pt.y);
                
                // Apply warp
                const warped = warpPoint(transformed.x, transformed.y, srcW, srcH, blend);
                points.push(new paper.Point(warped.x, warped.y));
            }

            path.remove();

            if (points.length < 2) return d;

            // Create new path
            const newPath = new paper.Path(points);
            newPath.closed = isClosed;

            // Smooth if needed
            if (smooth > 0) {
                newPath.smooth({ type: 'catmull-rom', factor: smooth });
            }

            const result = newPath.pathData;
            newPath.remove();
            
            return result;
        }

        // Warp rect
        async function warpRect(el, srcW, srcH, samples, blend, smooth, matrix) {
            const x = parseFloat(el.getAttribute('x')) || 0;
            const y = parseFloat(el.getAttribute('y')) || 0;
            const w = parseFloat(el.getAttribute('width')) || 0;
            const h = parseFloat(el.getAttribute('height')) || 0;
            const rx = parseFloat(el.getAttribute('rx')) || 0;
            const ry = parseFloat(el.getAttribute('ry')) || rx;

            let d;
            if (rx > 0 || ry > 0) {
                // Rounded rect
                d = `M${x+rx},${y} L${x+w-rx},${y} Q${x+w},${y} ${x+w},${y+ry} L${x+w},${y+h-ry} Q${x+w},${y+h} ${x+w-rx},${y+h} L${x+rx},${y+h} Q${x},${y+h} ${x},${y+h-ry} L${x},${y+ry} Q${x},${y} ${x+rx},${y} Z`;
            } else {
                d = `M${x},${y} L${x+w},${y} L${x+w},${y+h} L${x},${y+h} Z`;
            }

            const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // Copy all attributes except rect-specific ones
            [...el.attributes].forEach(attr => {
                if (!['x', 'y', 'width', 'height', 'rx', 'ry'].includes(attr.name)) {
                    newPath.setAttribute(attr.name, attr.value);
                }
            });

            newPath.setAttribute('d', warpPathData(d, srcW, srcH, samples, blend, smooth, matrix));
            newPath.removeAttribute('transform');
            el.replaceWith(newPath);
        }

        // Warp circle
        async function warpCircle(el, srcW, srcH, samples, blend, smooth, matrix) {
            const cx = parseFloat(el.getAttribute('cx')) || 0;
            const cy = parseFloat(el.getAttribute('cy')) || 0;
            const r = parseFloat(el.getAttribute('r')) || 0;

            // Create circle path
            const d = `M${cx-r},${cy} A${r},${r} 0 1,1 ${cx+r},${cy} A${r},${r} 0 1,1 ${cx-r},${cy} Z`;

            const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            [...el.attributes].forEach(attr => {
                if (!['cx', 'cy', 'r'].includes(attr.name)) {
                    newPath.setAttribute(attr.name, attr.value);
                }
            });

            newPath.setAttribute('d', warpPathData(d, srcW, srcH, samples, blend, smooth, matrix));
            newPath.removeAttribute('transform');
            el.replaceWith(newPath);
        }

        // Warp ellipse
        async function warpEllipse(el, srcW, srcH, samples, blend, smooth, matrix) {
            const cx = parseFloat(el.getAttribute('cx')) || 0;
            const cy = parseFloat(el.getAttribute('cy')) || 0;
            const rx = parseFloat(el.getAttribute('rx')) || 0;
            const ry = parseFloat(el.getAttribute('ry')) || 0;

            const d = `M${cx-rx},${cy} A${rx},${ry} 0 1,1 ${cx+rx},${cy} A${rx},${ry} 0 1,1 ${cx-rx},${cy} Z`;

            const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            [...el.attributes].forEach(attr => {
                if (!['cx', 'cy', 'rx', 'ry'].includes(attr.name)) {
                    newPath.setAttribute(attr.name, attr.value);
                }
            });

            newPath.setAttribute('d', warpPathData(d, srcW, srcH, samples, blend, smooth, matrix));
            newPath.removeAttribute('transform');
            el.replaceWith(newPath);
        }

        // Warp line
        async function warpLine(el, srcW, srcH, samples, blend, smooth, matrix) {
            const x1 = parseFloat(el.getAttribute('x1')) || 0;
            const y1 = parseFloat(el.getAttribute('y1')) || 0;
            const x2 = parseFloat(el.getAttribute('x2')) || 0;
            const y2 = parseFloat(el.getAttribute('y2')) || 0;

            const d = `M${x1},${y1} L${x2},${y2}`;

            const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            [...el.attributes].forEach(attr => {
                if (!['x1', 'y1', 'x2', 'y2'].includes(attr.name)) {
                    newPath.setAttribute(attr.name, attr.value);
                }
            });

            newPath.setAttribute('d', warpPathData(d, srcW, srcH, samples, blend, smooth, matrix));
            newPath.removeAttribute('transform');
            el.replaceWith(newPath);
        }

        // Warp polygon/polyline
        async function warpPoly(el, srcW, srcH, samples, blend, smooth, matrix) {
            const points = el.getAttribute('points');
            if (!points) return;

            const coords = points.trim().split(/[\s,]+/).map(Number);
            let d = '';
            for (let i = 0; i < coords.length; i += 2) {
                d += (i === 0 ? 'M' : 'L') + coords[i] + ',' + coords[i+1];
            }
            if (el.tagName.toLowerCase() === 'polygon') d += ' Z';

            const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            [...el.attributes].forEach(attr => {
                if (attr.name !== 'points') {
                    newPath.setAttribute(attr.name, attr.value);
                }
            });

            newPath.setAttribute('d', warpPathData(d, srcW, srcH, samples, blend, smooth, matrix));
            newPath.removeAttribute('transform');
            el.replaceWith(newPath);
        }

        // Warp text
        function warpText(el, srcW, srcH, blend, matrix) {
            const x = parseFloat(el.getAttribute('x')) || 0;
            const y = parseFloat(el.getAttribute('y')) || 0;

            const transformed = applyMatrix(matrix, x, y);
            const warped = warpPoint(transformed.x, transformed.y, srcW, srcH, blend);

            // Calculate rotation from curve tangent
            const nextPt = warpPoint(transformed.x + 10, transformed.y, srcW, srcH, blend);
            const angle = Math.atan2(nextPt.y - warped.y, nextPt.x - warped.x) * 180 / Math.PI;

            el.setAttribute('x', warped.x.toFixed(2));
            el.setAttribute('y', warped.y.toFixed(2));
            el.setAttribute('transform', `rotate(${angle.toFixed(2)}, ${warped.x.toFixed(2)}, ${warped.y.toFixed(2)})`);

            // Process tspans
            el.querySelectorAll('tspan').forEach(tspan => {
                const tx = parseFloat(tspan.getAttribute('x')) || warped.x;
                const ty = parseFloat(tspan.getAttribute('y')) || warped.y;
                const tt = applyMatrix(matrix, tx, ty);
                const tw = warpPoint(tt.x, tt.y, srcW, srcH, blend);
                tspan.setAttribute('x', tw.x.toFixed(2));
                tspan.setAttribute('y', tw.y.toFixed(2));
            });
        }

        // Warp image using mesh distortion
        async function warpImage(el, srcW, srcH, meshSize, blend, matrix) {
            const href = el.getAttribute('href') || el.getAttribute('xlink:href');
            if (!href) return;

            const x = parseFloat(el.getAttribute('x')) || 0;
            const y = parseFloat(el.getAttribute('y')) || 0;
            const w = parseFloat(el.getAttribute('width')) || 100;
            const h = parseFloat(el.getAttribute('height')) || 100;

            status(`Processing image at (${x}, ${y})...`);

            try {
                // Load image
                const img = await loadImage(href);
                
                // Create source canvas
                const srcCanvas = document.createElement('canvas');
                srcCanvas.width = img.width;
                srcCanvas.height = img.height;
                const srcCtx = srcCanvas.getContext('2d');
                srcCtx.drawImage(img, 0, 0);

                // Create destination canvas (size of target shape)
                const dstCanvas = document.getElementById('imageCanvas');
                dstCanvas.width = SHAPE.width;
                dstCanvas.height = SHAPE.height;
                const dstCtx = dstCanvas.getContext('2d');
                dstCtx.clearRect(0, 0, SHAPE.width, SHAPE.height);

                // Mesh warp the image
                const cols = meshSize;
                const rows = Math.ceil(meshSize * (h / w));

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        // Source rectangle
                        const sx = (col / cols) * w;
                        const sy = (row / rows) * h;
                        const sw = w / cols;
                        const sh = h / rows;

                        // FIXED: Correct coordinate mapping for image warping
                        // Source corners in the ORIGINAL SVG coordinate system
                        const srcCorners = [
                            { x: sx, y: sy },                     // Top-left
                            { x: sx + sw, y: sy },                // Top-right
                            { x: sx + sw, y: sy + sh },           // Bottom-right
                            { x: sx, y: sy + sh }                 // Bottom-left
                        ].map(pt => {
                            // 1. First, map from image-local space to the image's position in the SVG
                            const imgSpaceX = x + pt.x;
                            const imgSpaceY = y + pt.y;
                            // 2. Apply any transformation (like from a parent <g>)
                            return applyMatrix(matrix, imgSpaceX, imgSpaceY);
                        });

                        // Warp each corner
                        const dstCorners = srcCorners.map(pt => {
                            return warpPoint(pt.x, pt.y, srcW, srcH, blend);
                        });

                        // Source coordinates on the original image
                        const srcX0 = (col / cols) * img.width;
                        const srcY0 = (row / rows) * img.height;
                        const srcX1 = ((col + 1) / cols) * img.width;
                        const srcY1 = ((row + 1) / rows) * img.height;

                        // Draw warped quad using two triangles
                        drawTexturedTriangle(
                            dstCtx, srcCanvas,
                            // Source triangle 1
                            srcX0, srcY0,
                            srcX1, srcY0,
                            srcX0, srcY1,
                            // Dest triangle 1
                            dstCorners[0].x, dstCorners[0].y,
                            dstCorners[1].x, dstCorners[1].y,
                            dstCorners[3].x, dstCorners[3].y
                        );

                        drawTexturedTriangle(
                            dstCtx, srcCanvas,
                            // Source triangle 2
                            srcX1, srcY0,
                            srcX1, srcY1,
                            srcX0, srcY1,
                            // Dest triangle 2
                            dstCorners[1].x, dstCorners[1].y,
                            dstCorners[2].x, dstCorners[2].y,
                            dstCorners[3].x, dstCorners[3].y
                        );
                    }
                }

                // Convert canvas to base64
                const dataUrl = dstCanvas.toDataURL('image/png');

                // Update image element
                el.setAttribute('href', dataUrl);
                el.setAttribute('xlink:href', dataUrl);
                el.setAttribute('x', '0');
                el.setAttribute('y', '0');
                el.setAttribute('width', SHAPE.width);
                el.setAttribute('height', SHAPE.height);
                el.removeAttribute('transform');
                el.setAttribute('preserveAspectRatio', 'none');

            } catch (err) {
                console.error('Image warp failed:', err);
                status('‚ö†Ô∏è Image warp failed: ' + err.message);
            }
        }

        // Load image as promise
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = src;
            });
        }

        // Draw textured triangle using affine transform
        function drawTexturedTriangle(ctx, img, 
            sx0, sy0, sx1, sy1, sx2, sy2,
            dx0, dy0, dx1, dy1, dx2, dy2) {
            
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(dx0, dy0);
            ctx.lineTo(dx1, dy1);
            ctx.lineTo(dx2, dy2);
            ctx.closePath();
            ctx.clip();

            // Calculate affine transform
            const denom = (sx0 * (sy1 - sy2) + sx1 * (sy2 - sy0) + sx2 * (sy0 - sy1));
            if (Math.abs(denom) < 0.001) {
                ctx.restore();
                return;
            }

            const m11 = (dx0 * (sy1 - sy2) + dx1 * (sy2 - sy0) + dx2 * (sy0 - sy1)) / denom;
            const m12 = (dx0 * (sx2 - sx1) + dx1 * (sx0 - sx2) + dx2 * (sx1 - sx0)) / denom;
            const m21 = (dy0 * (sy1 - sy2) + dy1 * (sy2 - sy0) + dy2 * (sy0 - sy1)) / denom;
            const m22 = (dy0 * (sx2 - sx1) + dy1 * (sx0 - sx2) + dy2 * (sx1 - sx0)) / denom;
            const m31 = (dx0 * (sx1 * sy2 - sx2 * sy1) + dx1 * (sx2 * sy0 - sx0 * sy2) + dx2 * (sx0 * sy1 - sx1 * sy0)) / denom;
            const m32 = (dy0 * (sx1 * sy2 - sx2 * sy1) + dy1 * (sx2 * sy0 - sx0 * sy2) + dy2 * (sx0 * sy1 - sx1 * sy0)) / denom;

            ctx.transform(m11, m21, m12, m22, m31, m32);
            ctx.drawImage(img, 0, 0);
            ctx.restore();
        }

        // Warp <use> element
        function warpUse(el, srcW, srcH, blend, matrix) {
            const x = parseFloat(el.getAttribute('x')) || 0;
            const y = parseFloat(el.getAttribute('y')) || 0;

            const transformed = applyMatrix(matrix, x, y);
            const warped = warpPoint(transformed.x, transformed.y, srcW, srcH, blend);

            el.setAttribute('x', warped.x.toFixed(2));
            el.setAttribute('y', warped.y.toFixed(2));
            el.removeAttribute('transform');
        }

        // Add clip path to final SVG
        function addClipPath(svg) {
            let defs = svg.querySelector('defs');
            if (!defs) {
                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                svg.insertBefore(defs, svg.firstChild);
            }

            // Check if clip already exists
            if (defs.querySelector('#warpClip')) return;

            const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
            clipPath.setAttribute('id', 'warpClip');
            const clipShape = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            clipShape.setAttribute('d', SHAPE.path);
            clipPath.appendChild(clipShape);
            defs.appendChild(clipPath);

            // Wrap all content in clipped group
            const wrapper = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            wrapper.setAttribute('clip-path', 'url(#warpClip)');

            const children = [...svg.children].filter(c => 
                c.tagName.toLowerCase() !== 'defs' && 
                c !== wrapper
            );
            
            children.forEach(c => wrapper.appendChild(c));
            svg.appendChild(wrapper);
        }

        // Download
        downloadBtn.addEventListener('click', () => {
            if (!warpedSvgString) return;

            const blob = new Blob([warpedSvgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'warped-label.svg';
            a.click();
            URL.revokeObjectURL(url);
        });
    </script>
</body>
</html>