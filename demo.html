<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Terra Tech Packs KLD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script
      type="module"
      src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.3.0/model-viewer.min.js"
    ></script>
    <style>
      .dragover { border-color: #3b82f6; }
      .radio-container.hidden { display: none; }
      
      /* Loading Overlay */
      .loading-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        flex-direction: column;
        backdrop-filter: blur(4px);
      }
      .loading-overlay.show { display: flex; }
      .loading-box {
        background: white;
        padding: 30px 50px;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
      }
      .spinner {
        border: 4px solid #e5e7eb;
        border-top: 4px solid #3b82f6;
        border-radius: 50%;
        width: 50px; height: 50px;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      .loading-text {
        color: #374151;
        font-size: 16px;
        font-weight: 500;
      }
      .loading-subtext {
        color: #9ca3af;
        font-size: 13px;
      }
      
      /* Error Popup Modal */
      .error-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1001;
        backdrop-filter: blur(2px);
      }
      .error-overlay.show { display: flex; }
      .error-popup {
        background: white;
        padding: 24px 32px;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 400px;
        width: 90%;
        text-align: center;
        animation: popIn 0.2s ease-out;
      }
      @keyframes popIn {
        0% { transform: scale(0.9); opacity: 0; }
        100% { transform: scale(1); opacity: 1; }
      }
      .error-icon {
        width: 56px;
        height: 56px;
        background: #fef2f2;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
      }
      .error-icon svg {
        width: 28px;
        height: 28px;
        fill: #ef4444;
      }
      .error-title {
        color: #1f2937;
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 8px;
      }
      .error-message {
        color: #6b7280;
        font-size: 14px;
        line-height: 1.5;
        margin-bottom: 20px;
        white-space: pre-line;
      }
      .error-close-btn {
        background: #3b82f6;
        color: white;
        border: none;
        padding: 10px 32px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
      }
      .error-close-btn:hover {
        background: #2563eb;
      }
      
      .site-logo {
        position: absolute;
        left: 2vw;
        top: 50%;
        transform: translateY(-50%);
        height: 2vw;
        object-fit: contain;
        z-index: 60;
      }
      @media (max-width: 420px) { .site-logo { display: none; } }
      @media (max-width: 640px) { .site-logo { height: 36px; left: 8px; } }
      
      /* 3D Viewer Container */
      #viewer3DContainer {
        position: absolute;
        top: 12px; right: 12px;
        width: 200px; height: 200px;
        background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
        border-radius: 12px;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
        overflow: hidden;
        z-index: 50;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
      }
      #viewer3DContainer:hover { box-shadow: 0 10px 35px rgba(0, 0, 0, 0.4); }
      #viewer3DContainer.expanded {
        width: 400px;
        height: 350px;
      }
      #modelViewer {
        width: 100%; height: 100%;
        display: block;
        --poster-color: transparent;
        --progress-bar-color: #3b82f6;
        --progress-bar-height: 2px;
      }
      .viewer3D-loading {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #64748b;
        font-size: 11px;
        text-align: center;
        z-index: 5;
        pointer-events: none;
      }
      .viewer3D-loading.hidden { display: none; }
      .viewer3D-loading .mini-spinner {
        width: 20px; height: 20px;
        border: 2px solid rgba(100, 116, 139, 0.3);
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 6px;
      }
      .viewer3D-status {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #64748b;
        font-size: 11px;
        text-align: center;
        z-index: 5;
        padding: 8px;
      }
      .viewer3D-status.hidden { display: none; }
      
      /* Viewer Controls */
      .viewer3D-controls {
        position: absolute;
        top: 6px; right: 6px;
        display: flex;
        gap: 4px;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.2s;
      }
      #viewer3DContainer:hover .viewer3D-controls { opacity: 1; }
      .viewer3D-btn {
        width: 24px; height: 24px;
        background: rgba(0, 0, 0, 0.6);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }
      .viewer3D-btn:hover { background: rgba(59, 130, 246, 0.8); }
      .viewer3D-btn svg { width: 14px; height: 14px; fill: #fff; }
      
      /* Minimized State */
      #viewer3DContainer.minimized { 
        width: 80px; 
        height: 28px; 
        cursor: pointer; 
      }
      #viewer3DContainer.minimized #modelViewer,
      #viewer3DContainer.minimized .viewer3D-loading,
      #viewer3DContainer.minimized .viewer3D-status { display: none !important; }
      #viewer3DContainer.minimized::after {
        content: "3D View";
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #94a3b8;
        font-size: 11px;
        font-weight: 600;
      }
      #viewer3DContainer.minimized #viewer3DExpand { display: none !important; }
      #viewer3DContainer.minimized .viewer3D-controls {
        opacity: 1;
        top: 50%;
        right: 6px;
        transform: translateY(-50%);
      }
      
      @media (max-width: 768px) {
        #viewer3DContainer { width: 160px; height: 160px; top: 8px; right: 8px; }
        #viewer3DContainer.expanded { width: 300px; height: 260px; }
      }
      @media (max-width: 480px) {
        #viewer3DContainer { width: 130px; height: 130px; }
        #viewer3DContainer.expanded { width: 240px; height: 210px; }
        #viewer3DContainer.minimized { width: 70px; height: 24px; }
      }
      
      /* Disable buttons during loading */
      .export:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body class="bg-slate-100 flex flex-col h-screen overflow-hidden font-sans">
    <div class="bg-white shadow-md z-10 relative">
      <img src="./assets/terratechpacks.png" alt="Terra Tech Packs" class="site-logo" />
      <div class="container mx-auto pt-4 pb-3 flex justify-center items-end flex-wrap gap-x-6 gap-y-4">
        <div class="flex flex-col">
          <label for="shapeTypeSelect" class="text-xs font-semibold text-slate-600 mb-1">Select Shape Type:</label>
          <select id="shapeTypeSelect" class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 transition cursor-pointer"></select>
        </div>
        <div class="flex flex-col">
          <label for="shapeSelect" class="text-xs font-semibold text-slate-600 mb-1">Select Specific Shape:</label>
          <select id="shapeSelect" class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 transition cursor-pointer"></select>
        </div>
        <div id="viewSelector" class="hidden self-end pb-1">
          <div class="radio-group flex flex-col gap-1">
            <div class="radio-container">
              <input type="radio" id="viewTopRadio" name="view_type" value="top" class="cursor-pointer accent-blue-600" />
              <label for="viewTopRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Top</label>
            </div>
            <div class="radio-container">
              <input type="radio" id="viewBottomRadio" name="view_type" value="bottom" checked class="cursor-pointer accent-blue-600" />
              <label for="viewBottomRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Bottom</label>
            </div>
          </div>
        </div>
        <div id="dropArea" class="flex flex-col">
          <label for="imageUpload" class="text-xs font-semibold text-slate-600 mb-1">Upload Label:</label>
          <label class="file-upload-label h-12 min-w-[180px] flex items-center justify-center px-5 bg-slate-50 border-2 border-dashed border-slate-400 rounded-lg cursor-pointer hover:border-blue-500 transition" for="imageUpload">
            <input type="file" id="imageUpload" class="hidden" accept="image/*,.svg" />
            <small id="uploadText" class="font-medium text-slate-700">Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span></small>
          </label>
        </div>
        <button class="export h-12 px-6 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition" id="exportPngBtn">Export PNG</button>
        <button class="export h-12 px-6 bg-orange-500 text-white font-semibold rounded-lg hover:bg-orange-600 transition" id="exportSvgBtn">Export SVG</button>
        <button class="export h-12 px-6 bg-red-700 text-white font-semibold rounded-lg hover:bg-red-800 transition" id="exportPdfBtn">Export PDF</button>
      </div>
    </div>

    <div class="flex-grow p-4 md:p-6 flex items-center justify-center relative">
      <canvas id="warpCanvas" class="w-full h-full bg-white rounded-lg shadow-sm"></canvas>
      
      <!-- 3D Viewer -->
      <div id="viewer3DContainer">
        <div class="viewer3D-controls">
          <button id="viewer3DExpand" class="viewer3D-btn" title="Expand">
            <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
          </button>
          <button id="viewer3DToggle" class="viewer3D-btn" title="Minimize">
            <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
          </button>
        </div>
        
        <div class="viewer3D-loading" id="viewer3DLoading">
          <div class="mini-spinner"></div>
          <span>Loading...</span>
        </div>
        <div class="viewer3D-status hidden" id="viewer3DStatus"></div>
        
        <model-viewer
          id="modelViewer"
          alt="3D product preview"
          camera-controls
          auto-rotate
          rotation-per-second="30deg"
          exposure="1.0"
          shadow-intensity="1"
          environment-image="neutral"
          interaction-prompt="none"
          style="background: transparent"
        ></model-viewer>
      </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-box">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Processing...</div>
        <div class="loading-subtext" id="loadingSubtext">Please wait</div>
      </div>
    </div>

    <!-- Error Popup Modal -->
    <div id="errorOverlay" class="error-overlay">
      <div class="error-popup">
        <div class="error-icon">
          <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
        </div>
        <div class="error-title" id="errorTitle">Error</div>
        <div class="error-message" id="errorMessage">Something went wrong.</div>
        <button class="error-close-btn" id="errorCloseBtn">OK</button>
      </div>
    </div>

    <script type="module">
      // ========== HELPERS ==========
      function debounce(fn, wait = 150) {
        let t;
        return (...args) => {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, args), wait);
        };
      }

      // ========== STATE ==========
      let currentImage = null;
      let currentImageDataUrl = null;
      let textureImageDataUrl = null;
      let currentView = "bottom";
      let currentShapeType = "round";
      let currentShape = "250ml_round";
      const EXPORT_SCALE = 4;
      let isExporting = false;

      let isViewer3DMinimized = false;
      let isViewer3DExpanded = false;
      let isModelLoaded = false;

      const canvas = document.getElementById("warpCanvas");
      const ctx = canvas.getContext("2d");
      const uploadText = document.getElementById("uploadText");
      const fileInput = document.getElementById("imageUpload");
      const exportPngBtn = document.getElementById("exportPngBtn");
      const exportSvgBtn = document.getElementById("exportSvgBtn");
      const exportPdfBtn = document.getElementById("exportPdfBtn");
      const shapeTypeSelect = document.getElementById("shapeTypeSelect");
      const shapeSelect = document.getElementById("shapeSelect");
      const viewSelector = document.getElementById("viewSelector");
      
      // Loading elements
      const loadingOverlay = document.getElementById("loadingOverlay");
      const loadingText = document.getElementById("loadingText");
      const loadingSubtext = document.getElementById("loadingSubtext");
      
      // Error popup elements
      const errorOverlay = document.getElementById("errorOverlay");
      const errorTitle = document.getElementById("errorTitle");
      const errorMessage = document.getElementById("errorMessage");
      const errorCloseBtn = document.getElementById("errorCloseBtn");

      const viewer3DContainer = document.getElementById("viewer3DContainer");
      const modelViewer = document.getElementById("modelViewer");
      const viewer3DLoading = document.getElementById("viewer3DLoading");
      const viewer3DStatus = document.getElementById("viewer3DStatus");
      const viewer3DToggle = document.getElementById("viewer3DToggle");
      const viewer3DExpand = document.getElementById("viewer3DExpand");

      // ========== LOADING & ERROR FUNCTIONS ==========
      
      function showLoading(message = "Processing...", subtext = "Please wait") {
        loadingText.textContent = message;
        loadingSubtext.textContent = subtext;
        loadingOverlay.classList.add("show");
        exportPngBtn.disabled = true;
        exportSvgBtn.disabled = true;
        exportPdfBtn.disabled = true;
      }

      function updateLoading(message, subtext = "") {
        loadingText.textContent = message;
        if (subtext) loadingSubtext.textContent = subtext;
      }

      function hideLoading() {
        loadingOverlay.classList.remove("show");
        exportPngBtn.disabled = false;
        exportSvgBtn.disabled = false;
        exportPdfBtn.disabled = false;
        isExporting = false;
      }

      function showError(title, message) {
        errorTitle.textContent = title;
        errorMessage.textContent = message;
        errorOverlay.classList.add("show");
      }

      function hideError() {
        errorOverlay.classList.remove("show");
      }

      errorCloseBtn.addEventListener("click", hideError);
      
      errorOverlay.addEventListener("click", (e) => {
        if (e.target === errorOverlay) {
          hideError();
        }
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && errorOverlay.classList.contains("show")) {
          hideError();
        }
      });

      // ========== DOWNLOAD HELPER ==========
      
      function triggerDownload(blob, filename) {
        return new Promise((resolve, reject) => {
          try {
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            link.style.display = "none";
            document.body.appendChild(link);
            
            setTimeout(() => {
              link.click();
              setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                resolve();
              }, 500);
            }, 100);
          } catch (error) {
            reject(error);
          }
        });
      }

      class PathSampler {
        constructor(pathData) {
          this.pathNode = document.createElementNS("http://www.w3.org/2000/svg", "path");
          this.pathNode.setAttribute("d", pathData);
          this.length = this.pathNode.getTotalLength();
        }
        getPointAt(percentage) {
          return this.pathNode.getPointAtLength(this.length * percentage);
        }
      }

      const shapeTypes = {
        round: "Round",
        round_square: "Round Square",
        rectangle: "Rectangle",
        sweet_box: "Sweet Box",
        sweet_box_te: "Sweet Box TE",
      };

      const COMMON_LABEL_MATERIALS = [
        "Bottom", "Label", "Wrap", "Decal", "Logo", "Sticker",
        "label", "bottom", "wrap", "decal", "logo", "sticker",
        "Material", "Material.001", "Material.002", "Material_0"
      ];

      const allBottleShapes = {
        "250ml_round": {
          type: "round",
          view: "bottom",
          name: "250ml Round",
          width: 837,
          height: 244,
          uploadDimensions: { width: 2908, height: 448 },
          path: "M1.37,162.42L73.32,242.27C283.84,56.41,576.84,75.5,764.01,242.27L835.96,162.42C597.61,-50.29,240.85,-53.15,1.37,162.42Z",
          topPath: "M 835.96,162.42 C 597.61,-50.29 240.85,-53.15 1.37,162.42",
          bottomPath: "M 73.32,242.27 C 283.84,56.41 576.84,75.5 764.01,242.27",
          topIsReversed: true,
          bottomIsReversed: false,
          modelPath: "./assets/models/500ml_Round_with_logo.glb",
          targetMaterials: ["Bottom", "Label", "Wrap"],
        },
        "300ml_round": {
          type: "round",
          view: "bottom",
          name: "300ml Round",
          width: 986.98,
          height: 332.17,
          uploadDimensions: { width: 2906, height: 448 },
          path: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0l-5.32,1.98-45.71-122.15,6.01-2.21c286.86-105.52,601.92-105.52,888.78,0l6.04,2.15-45.75,122.2-5.3-1.98Z",
          topPath: "M49.08,172.19c286.86-105.52,601.92-105.52,888.78,0",
          bottomPath: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0",
          topIsReversed: false,
          bottomIsReversed: true,
          modelPath: "./assets/models/logo_300_ml_round.glb",
          targetMaterials: ["Bottom", "Label", "Wrap"],
        },
      };

      const shapeGroups = {};
      const keyToGroupName = {};

      // ========== 3D VIEWER FUNCTIONS ==========

      function showStatus(message) {
        viewer3DStatus.textContent = message;
        viewer3DStatus.classList.remove("hidden");
      }

      function hideStatus() {
        viewer3DStatus.classList.add("hidden");
      }

      function show3DLoading() {
        viewer3DLoading.classList.remove("hidden");
        hideStatus();
      }

      function hide3DLoading() {
        viewer3DLoading.classList.add("hidden");
      }

      function findBestMaterial(viewer, preferredNames) {
        if (!viewer.model || !viewer.model.materials) return null;
        const materials = viewer.model.materials;

        for (const name of preferredNames) {
          const mat = materials.find(m => m.name === name);
          if (mat) return mat;
        }

        for (const name of preferredNames) {
          const mat = materials.find(m => m.name.toLowerCase() === name.toLowerCase());
          if (mat) return mat;
        }

        for (const name of preferredNames) {
          const mat = materials.find(m => 
            m.name.toLowerCase().includes(name.toLowerCase()) ||
            name.toLowerCase().includes(m.name.toLowerCase())
          );
          if (mat) return mat;
        }

        for (const name of COMMON_LABEL_MATERIALS) {
          const mat = materials.find(m => m.name === name);
          if (mat) return mat;
        }

        return materials.length > 0 ? materials[0] : null;
      }

      async function applyTextureToMaterial(viewer, material, textureUrl) {
        if (!viewer || !material || !textureUrl) return false;

        try {
          const texture = await viewer.createTexture(textureUrl);
          if (!texture) return false;

          const pbr = material.pbrMetallicRoughness;

          if (typeof pbr.setBaseColorFactor === 'function') {
            pbr.setBaseColorFactor([1.0, 1.0, 1.0, 1.0]);
          }

          if (pbr.baseColorTexture) {
            pbr.baseColorTexture.setTexture(texture);
          }

          try {
            const texInfo = pbr.baseColorTexture;
            if (texInfo && texInfo.texture && texInfo.texture.sampler) {
              const sampler = texInfo.texture.sampler;
              const GL_CLAMP_TO_EDGE = 33071;
              const GL_LINEAR = 9729;
              const GL_LINEAR_MIPMAP_LINEAR = 9987;

              if (typeof sampler.setWrapS === 'function') {
                sampler.setWrapS(GL_CLAMP_TO_EDGE);
                sampler.setWrapT(GL_CLAMP_TO_EDGE);
              }
              if (typeof sampler.setMinFilter === 'function') {
                sampler.setMinFilter(GL_LINEAR_MIPMAP_LINEAR);
              }
              if (typeof sampler.setMagFilter === 'function') {
                sampler.setMagFilter(GL_LINEAR);
              }
            }
          } catch (e) {
            console.warn("Could not set sampler settings:", e);
          }

          if (typeof pbr.setMetallicFactor === 'function') {
            pbr.setMetallicFactor(0.0);
          }
          if (typeof pbr.setRoughnessFactor === 'function') {
            pbr.setRoughnessFactor(0.5);
          }

          return true;
        } catch (error) {
          console.error("Error applying texture:", error);
          return false;
        }
      }

      async function applyTextureToModel() {
        if (!modelViewer.model || !textureImageDataUrl) return;

        const shape = getCurrentShape();
        if (!shape) return;

        const materialNames = shape.targetMaterials || COMMON_LABEL_MATERIALS;
        const material = findBestMaterial(modelViewer, materialNames);

        if (!material) return;

        await applyTextureToMaterial(modelViewer, material, textureImageDataUrl);
      }

      async function load3DModel(shape) {
        isModelLoaded = false;

        if (!shape || !shape.modelPath) {
          showStatus("No 3D model");
          modelViewer.src = "";
          return;
        }

        show3DLoading();
        modelViewer.src = shape.modelPath + "?t=" + Date.now();
      }

      modelViewer.addEventListener("load", async () => {
        isModelLoaded = true;
        hide3DLoading();
        hideStatus();

        let attempts = 0;
        while (!modelViewer.model && attempts < 100) {
          await new Promise(r => setTimeout(r, 50));
          attempts++;
        }

        if (textureImageDataUrl && modelViewer.model) {
          await applyTextureToModel();
        }
      });

      modelViewer.addEventListener("error", () => {
        hide3DLoading();
        showStatus("Load failed");
        isModelLoaded = false;
      });

      modelViewer.addEventListener("progress", (event) => {
        const progress = event.detail.totalProgress;
        if (progress < 1) {
          const percent = Math.round(progress * 100);
          viewer3DLoading.querySelector("span").textContent = `${percent}%`;
        }
      });

      function toggleViewer3D() {
        isViewer3DMinimized = !isViewer3DMinimized;
        viewer3DContainer.classList.toggle("minimized", isViewer3DMinimized);
        
        if (isViewer3DMinimized) {
          isViewer3DExpanded = false;
          viewer3DContainer.classList.remove("expanded");
        }
      }

      function toggleViewer3DExpand() {
        if (isViewer3DMinimized) return;
        isViewer3DExpanded = !isViewer3DExpanded;
        viewer3DContainer.classList.toggle("expanded", isViewer3DExpanded);
      }

      viewer3DToggle.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleViewer3D();
      });

      viewer3DExpand.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleViewer3DExpand();
      });

      viewer3DContainer.addEventListener("click", (e) => {
        if (isViewer3DMinimized && !e.target.closest('.viewer3D-btn')) {
          toggleViewer3D();
        }
      });

      // ========== SHAPE FUNCTIONS ==========

      function preProcessShapes() {
        for (const [key, shape] of Object.entries(allBottleShapes)) {
          shape.topSampler = new PathSampler(shape.topPath);
          shape.bottomSampler = new PathSampler(shape.bottomPath);

          if (!shapeGroups[shape.name]) {
            shapeGroups[shape.name] = {};
          }
          shapeGroups[shape.name][shape.view] = key;
          keyToGroupName[key] = shape.name;
        }
      }

      function getCurrentShape() {
        return currentShape ? allBottleShapes[currentShape] : null;
      }

      function updateUploadPlaceholder() {
        const shape = getCurrentShape();
        if (shape && shape.uploadDimensions) {
          const { width, height } = shape.uploadDimensions;
          uploadText.innerHTML = `<span class="text-xs text-slate-500 block text-center">${width} × ${height}px</span>Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>`;
        } else {
          uploadText.innerHTML = 'Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>';
        }
      }

      function toggleViewSelector() {
        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          viewSelector.classList.remove("hidden");
        } else {
          viewSelector.classList.add("hidden");
        }
      }

      function syncSweetBoxViewControls() {
        const topRadioDiv = document.getElementById("viewTopRadio").parentElement;
        const bottomRadioDiv = document.getElementById("viewBottomRadio").parentElement;

        if ((currentShapeType !== "sweet_box" && currentShapeType !== "sweet_box_te") || !currentShape) {
          topRadioDiv.classList.add("hidden");
          bottomRadioDiv.classList.add("hidden");
          return;
        }

        const groupName = keyToGroupName[currentShape];
        const group = shapeGroups[groupName];

        topRadioDiv.classList.toggle("hidden", !group.top);
        bottomRadioDiv.classList.toggle("hidden", !group.bottom);

        if (currentShape.endsWith("_top")) {
          currentView = "top";
          document.getElementById("viewTopRadio").checked = true;
        } else if (currentShape.endsWith("_bottom")) {
          currentView = "bottom";
          document.getElementById("viewBottomRadio").checked = true;
        }
      }

      function updateSpecificShapeSelector() {
        shapeSelect.innerHTML = "";
        let firstShapeKey = null;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const uniqueNames = new Set();
          for (const key in allBottleShapes) {
            const shape = allBottleShapes[key];
            if (shape.type === currentShapeType && !uniqueNames.has(shape.name)) {
              uniqueNames.add(shape.name);
              const option = document.createElement("option");
              option.value = shape.name;
              option.textContent = shape.name;
              shapeSelect.appendChild(option);
            }
          }
          if (shapeSelect.options.length > 0) {
            const selectedName = shapeSelect.options[0].value;
            shapeSelect.value = selectedName;
            const group = shapeGroups[selectedName];
            firstShapeKey = group.top || group.bottom;
          }
        } else {
          for (const [key, shape] of Object.entries(allBottleShapes)) {
            if (shape.type === currentShapeType) {
              const option = document.createElement("option");
              option.value = key;
              option.textContent = shape.name;
              shapeSelect.appendChild(option);
              if (!firstShapeKey) firstShapeKey = key;
            }
          }
          if (firstShapeKey) shapeSelect.value = firstShapeKey;
        }

        currentShape = firstShapeKey;
        syncSweetBoxViewControls();

        const shape = getCurrentShape();
        load3DModel(shape);
      }

      function populateShapeTypes() {
        shapeTypeSelect.innerHTML = "";
        for (const [key, name] of Object.entries(shapeTypes)) {
          const option = document.createElement("option");
          option.value = key;
          option.textContent = name;
          shapeTypeSelect.appendChild(option);
        }
        shapeTypeSelect.value = currentShapeType;
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
      }

      function drawWarp(localCtx, img, shape, offsetX, offsetY, finalScale, isExport, heightAdjust = 1.0) {
        const sliceCountBase = isExport ? 4000 : 2000;
        const imgWidth = img.width;
        const imgHeight = img.height;
        const sliceCount = Math.min(sliceCountBase, Math.max(1, Math.floor(imgWidth)));
        const sourceSliceWidth = imgWidth / sliceCount;

        const isWideShape = shape.type === "round_square" || shape.type === "sweet_box" || shape.type === "sweet_box_te";
        const isSweetBox = shape.type === "sweet_box" || shape.type === "sweet_box_te";
        const isLargeRound = ["300ml_round", "500ml_round", "750ml_round", "1000ml_round"].includes(currentShape);

        let baseOverlap;
        if (isSweetBox) baseOverlap = isExport ? 40 : 20;
        else if (isLargeRound) baseOverlap = isExport ? 30 : 15;
        else if (isWideShape) baseOverlap = isExport ? 20 : 10;
        else baseOverlap = isExport ? 8 : 4;

        for (let i = 0; i < sliceCount; i++) {
          const t0 = i / sliceCount;
          const t1 = (i + 1) / sliceCount;
          const edgeExtension = isSweetBox ? 0.03 : 0.01;
          const tTop0 = shape.topIsReversed ? 1 - t0 : t0;
          const tTop1 = shape.topIsReversed ? 1 - t1 : t1;
          const tBot0 = shape.bottomIsReversed ? 1 - t0 : t0;
          const tBot1 = shape.bottomIsReversed ? 1 - t1 : t1;

          const clampedTTop0 = Math.min(Math.max(tTop0, -edgeExtension), 1 + edgeExtension);
          const clampedTTop1 = Math.min(Math.max(tTop1, -edgeExtension), 1 + edgeExtension);
          const clampedTBot0 = Math.min(Math.max(tBot0, -edgeExtension), 1 + edgeExtension);
          const clampedTBot1 = Math.min(Math.max(tBot1, -edgeExtension), 1 + edgeExtension);

          if ((clampedTTop0 < -0.05 && clampedTTop1 < -0.05) || (clampedTTop0 > 1.05 && clampedTTop1 > 1.05)) continue;

          const pTop1 = shape.topSampler.getPointAt(Math.min(Math.max(clampedTTop0, 0), 1));
          const pBot1 = shape.bottomSampler.getPointAt(Math.min(Math.max(clampedTBot0, 0), 1));
          const pTop2 = shape.topSampler.getPointAt(Math.min(Math.max(clampedTTop1, 0), 1));
          const pBot2 = shape.bottomSampler.getPointAt(Math.min(Math.max(clampedTBot1, 0), 1));

          const top1X = pTop1.x * finalScale + offsetX;
          const top1Y = pTop1.y * finalScale + offsetY;
          const bot1X = pBot1.x * finalScale + offsetX;
          const bot1Y = pBot1.y * finalScale + offsetY;
          const top2X = pTop2.x * finalScale + offsetX;
          const top2Y = pTop2.y * finalScale + offsetY;
          const bot2X = pBot2.x * finalScale + offsetX;
          const bot2Y = pBot2.y * finalScale + offsetY;

          const midTopX = (top1X + top2X) / 2;
          const midTopY = (top1Y + top2Y) / 2;
          const midBotX = (bot1X + bot2X) / 2;
          const midBotY = (bot1Y + bot2Y) / 2;

          const sliceHeight = Math.hypot(midBotX - midTopX, midBotY - midTopY) * heightAdjust;
          const sliceAngle = Math.atan2(midBotY - midTopY, midBotX - midTopX) - Math.PI / 2;

          const topWidth = Math.hypot(top2X - top1X, top2Y - top1Y);
          const botWidth = Math.hypot(bot2X - bot1X, bot2Y - bot1Y);
          const sliceWidth = Math.max(topWidth, botWidth);

          let overlap = baseOverlap;
          const normalizedT = Math.min(Math.max(t0, 0), 1);

          if (isSweetBox) {
            if (isExport) {
              if (normalizedT < 0.02 || normalizedT > 0.98) overlap = 80;
              else if (normalizedT < 0.05 || normalizedT > 0.95) overlap = 60;
              else if (normalizedT < 0.1 || normalizedT > 0.9) overlap = 40;
              else {
                const edgeFactor = Math.min(normalizedT * 3, (1 - normalizedT) * 3, 1);
                overlap = baseOverlap + (20 - baseOverlap) * (1 - edgeFactor);
              }
            } else {
              if (normalizedT < 0.05 || normalizedT > 0.95) overlap = 40;
              else if (normalizedT < 0.1 || normalizedT > 0.9) overlap = 30;
              else overlap = 20;
            }
          } else if (isWideShape) {
            const edgeFactor = Math.min(normalizedT * 5, (1 - normalizedT) * 5, 1);
            overlap = baseOverlap + (15 - baseOverlap) * (1 - edgeFactor);
            if (isExport) {
              if (normalizedT < 0.05 || normalizedT > 0.95) overlap += 25;
              else if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 15;
            } else {
              if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 10;
            }
          } else if (isLargeRound) {
            if (isExport) {
              if (normalizedT < 0.05 || normalizedT > 0.95) overlap += 25;
              else if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 15;
            } else {
              if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 10;
            }
          }

          if (sliceWidth < 0.1) continue;

          localCtx.save();
          localCtx.translate(midTopX, midTopY);
          localCtx.rotate(sliceAngle);

          let verticalExtension = 0;
          if (shape.type !== "rectangle") {
            if (isSweetBox) verticalExtension = isExport ? 40 : 20;
            else if (isWideShape) verticalExtension = isExport ? 22 : 10;
            else if (shape.type === "round") {
              if (shape.name === "250ml Round") verticalExtension = 0;
              else verticalExtension = isExport ? 10 : 0;
            }
          }

          const sourceLeft = Math.max(0, Math.floor(i * sourceSliceWidth));
          const sourceRight = Math.min(imgWidth, Math.ceil((i + 1) * sourceSliceWidth));
          const sourceW = Math.max(1, sourceRight - sourceLeft);

          localCtx.drawImage(img, sourceLeft, 0, sourceW, imgHeight, -(sliceWidth + overlap) / 2, -verticalExtension, sliceWidth + overlap, sliceHeight + verticalExtension * 2);
          localCtx.restore();
        }
      }

      function renderImageContent(localCtx, targetW, targetH, isExport, exportScale, clearBackground) {
        if (clearBackground) localCtx.clearRect(0, 0, targetW, targetH);

        const shape = getCurrentShape();
        if (!shape) return;

        const margin = isExport ? 0 : 20;
        const scaleXFit = (targetW - 2 * margin) / shape.width;
        const scaleYFit = (targetH - 2 * margin) / shape.height;
        const finalScale = isExport ? exportScale : Math.min(scaleXFit, scaleYFit);

        const scaledW = shape.width * finalScale;
        const scaledH = shape.height * finalScale;
        const offsetX = (targetW - scaledW) / 2;
        const offsetY = (targetH - scaledH) / 2;

        const path = new Path2D(shape.path);
        const transformMatrix = new DOMMatrix();
        transformMatrix.translateSelf(offsetX, offsetY);
        transformMatrix.scaleSelf(finalScale, finalScale);

        if (currentImage) {
          localCtx.save();
          localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
          localCtx.clip(path);
          localCtx.setTransform(1, 0, 0, 1, 0, 0);

          if (!isExport && window.devicePixelRatio && localCtx === ctx) {
            localCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
          }

          let imageOffsetX = 0;
          const needsHorizontalShift = ["500ml_round", "750ml_round", "1000ml_round", "450ml_round_square", "500ml_round_square"].includes(currentShape);
          if (needsHorizontalShift) imageOffsetX = isExport ? 22 : 5;

          if (shape.type === "rectangle" || shape.view === "top" || shape.type === "sweet_box_te") {
            let drawOffsetX = offsetX + imageOffsetX;
            let drawOffsetY = offsetY;
            let drawScaledW = scaledW;
            let drawScaledH = scaledH;

            if (currentShape === "250ml_sweet_box_te_bottom") {
              const scaleFactor = 1.029;
              drawScaledW = scaledW * scaleFactor;
              drawScaledH = scaledH * scaleFactor;
              drawOffsetX = offsetX - (drawScaledW - scaledW) / 2 + imageOffsetX;
              drawOffsetY = offsetY - (drawScaledH - scaledH) / 2;
            }

            localCtx.drawImage(currentImage, drawOffsetX, drawOffsetY, drawScaledW, drawScaledH);
          } else {
            drawWarp(localCtx, currentImage, shape, offsetX + imageOffsetX, offsetY, finalScale, isExport, 1.0);
          }

          localCtx.restore();
        } else {
          localCtx.save();
          localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
          localCtx.fillStyle = "#eee";
          localCtx.fill(path);
          localCtx.restore();
        }
      }

      function drawShape(localCtx, targetW, targetH, isExport, exportScale, clearBackground) {
        localCtx.imageSmoothingEnabled = true;
        localCtx.imageSmoothingQuality = "high";

        renderImageContent(localCtx, targetW, targetH, isExport, exportScale, clearBackground);

        const shape = getCurrentShape();
        if (!shape) {
          if (clearBackground) localCtx.clearRect(0, 0, targetW * (window.devicePixelRatio || 1), targetH * (window.devicePixelRatio || 1));
          const dpr = window.devicePixelRatio || 1;
          localCtx.font = `${16 * dpr}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
          localCtx.textAlign = "center";
          localCtx.fillStyle = "#9ca3af";
          localCtx.fillText("No shapes available for this type/view.", (targetW * dpr) / 2, (targetH * dpr) / 2);
          return;
        }

        const margin = isExport ? 0 : 20;
        const scaleXFit = (targetW - 2 * margin) / shape.width;
        const scaleYFit = (targetH - 2 * margin) / shape.height;
        const finalScale = isExport ? exportScale : Math.min(scaleXFit, scaleYFit);
        const scaledW = shape.width * finalScale;
        const scaledH = shape.height * finalScale;
        const offsetX = (targetW - scaledW) / 2;
        const offsetY = (targetH - scaledH) / 2;

        const path = new Path2D(shape.path);
        const transformMatrix = new DOMMatrix();
        transformMatrix.translateSelf(offsetX, offsetY);
        transformMatrix.scaleSelf(finalScale, finalScale);

        localCtx.save();
        localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
        if (!isExport) {
          localCtx.strokeStyle = "#ed312c";
          localCtx.lineWidth = 2 / finalScale;
          localCtx.stroke(path);
        }
        localCtx.restore();
      }

      function mainDraw() {
        resizeCanvas();
        drawShape(ctx, canvas.clientWidth, canvas.clientHeight, false, 1, true);
      }

      async function processUploadedImage(img, shape) {
        updateLoading("Applying to shape...", "Almost done");
        
        currentImage = img;

        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.drawImage(img, 0, 0);
        currentImageDataUrl = tempCanvas.toDataURL("image/png");
        textureImageDataUrl = currentImageDataUrl;

        await new Promise(r => setTimeout(r, 100));

        if (isModelLoaded && modelViewer.model) {
          updateLoading("Applying 3D texture...", "Finishing up");
          await applyTextureToModel();
        }

        mainDraw();
        hideLoading();
      }

      async function handleImageUpload(event) {
        const file = (event.target.files || [])[0];

        if (!file) {
          currentImage = null;
          currentImageDataUrl = null;
          textureImageDataUrl = null;
          mainDraw();
          updateUploadPlaceholder();
          const shape = getCurrentShape();
          if (shape) load3DModel(shape);
          return;
        }

        showLoading("Loading image...", "Reading file");

        const isSVG = file.type === "image/svg+xml" || file.name.toLowerCase().endsWith(".svg");
        const shape = getCurrentShape();

        if (isSVG) {
          const reader = new FileReader();
          reader.onload = async function (e) {
            updateLoading("Processing SVG...", "Parsing file");
            
            let svgText = e.target.result;
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
            const svgElement = svgDoc.querySelector("svg");

            const parserError = svgDoc.querySelector("parsererror");
            if (parserError || !svgElement) {
              hideLoading();
              showError("Invalid SVG File", "The SVG file could not be parsed. Please make sure it's a valid SVG file.");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
              return;
            }

            let width = svgElement.getAttribute("width");
            let height = svgElement.getAttribute("height");
            const viewBox = svgElement.getAttribute("viewBox");

            if (width) width = parseFloat(width);
            if (height) height = parseFloat(height);

            if ((!width || !height) && viewBox) {
              const vbParts = viewBox.split(/[\s,]+/).map(parseFloat);
              if (vbParts.length === 4) {
                if (!width) width = vbParts[2];
                if (!height) height = vbParts[3];
              }
            }

            if (!width || !height || isNaN(width) || isNaN(height)) {
              if (shape && shape.uploadDimensions) {
                width = width || shape.uploadDimensions.width;
                height = height || shape.uploadDimensions.height;
              } else {
                width = width || 1000;
                height = height || 1000;
              }
            }

            svgElement.setAttribute("width", width);
            svgElement.setAttribute("height", height);
            if (!viewBox) svgElement.setAttribute("viewBox", `0 0 ${width} ${height}`);

            svgText = new XMLSerializer().serializeToString(svgDoc);
            const blob = new Blob([svgText], { type: "image/svg+xml" });
            const url = URL.createObjectURL(blob);

            const img = new Image();
            img.onload = async () => {
              if (shape && shape.uploadDimensions) {
                const expectedWidth = shape.uploadDimensions.width;
                const expectedHeight = shape.uploadDimensions.height;

                if (width < expectedWidth || height < expectedHeight) {
                  hideLoading();
                  showError(
                    "Image Too Small",
                    `<div class="font-semibold">The image dimensions (${Math.round(width)} × ${Math.round(height)}px) are smaller than required.\n\nMinimum size: ${expectedWidth} × ${expectedHeight}px </div>`
                  );
                  currentImage = null;
                  currentImageDataUrl = null;
                  textureImageDataUrl = null;
                  fileInput.value = "";
                  updateUploadPlaceholder();
                  URL.revokeObjectURL(url);
                  mainDraw();
                  return;
                }
              }

              const fullName = file.name;
              const dotIndex = fullName.lastIndexOf(".");
              let name = dotIndex !== -1 ? fullName.substring(0, dotIndex) : fullName;
              const ext = dotIndex !== -1 ? fullName.substring(dotIndex) : "";
              if (name.length > 12) name = name.substring(0, 12) + "...";
              uploadText.textContent = `${name}${ext}`;

              await processUploadedImage(img, shape);
            };

            img.onerror = () => {
              URL.revokeObjectURL(url);
              hideLoading();
              showError("Failed to Load SVG", "The SVG file could not be loaded. Please try a different file.");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
            };

            img.src = url;
          };

          reader.onerror = () => {
            hideLoading();
            showError("File Read Error", "Failed to read the SVG file. Please try again.");
            fileInput.value = "";
            updateUploadPlaceholder();
            mainDraw();
          };

          reader.readAsText(file);
        } else {
          const reader = new FileReader();
          reader.onload = async function (e) {
            updateLoading("Processing image...", "Loading pixels");
            
            const img = new Image();
            img.onload = async () => {
              if (shape && shape.uploadDimensions) {
                const expectedWidth = shape.uploadDimensions.width;
                const expectedHeight = shape.uploadDimensions.height;

                if (img.width < expectedWidth || img.height < expectedHeight) {
                  hideLoading();
                  showError(
                    "Image Too Small",
                    `The image dimensions (${img.width} × ${img.height}px) are smaller than required.\n\nMinimum size: ${expectedWidth} × ${expectedHeight}px`
                  );
                  currentImage = null;
                  currentImageDataUrl = null;
                  textureImageDataUrl = null;
                  fileInput.value = "";
                  updateUploadPlaceholder();
                  mainDraw();
                  return;
                }
              }

              const fullName = file.name;
              const dotIndex = fullName.lastIndexOf(".");
              let name = dotIndex !== -1 ? fullName.substring(0, dotIndex) : fullName;
              const ext = dotIndex !== -1 ? fullName.substring(dotIndex) : "";
              if (name.length > 12) name = name.substring(0, 12) + "...";
              uploadText.textContent = `${name}${ext}`;

              await processUploadedImage(img, shape);
            };
            img.onerror = () => {
              hideLoading();
              showError("Failed to Load Image", "The image file could not be loaded. Please try a different file format (PNG, JPG, etc.).");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
            };
            img.src = e.target.result;
          };
          
          reader.onerror = () => {
            hideLoading();
            showError("File Read Error", "Failed to read the image file. Please try again.");
            fileInput.value = "";
            updateUploadPlaceholder();
            mainDraw();
          };
          
          reader.readAsDataURL(file);
        }
      }

      async function handleViewChange(event) {
        const newView = event.target.value;
        currentView = newView;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const groupName = shapeSelect.value;
          const group = shapeGroups[groupName];
          const newShapeKey = group[newView];

          if (newShapeKey) {
            currentShape = newShapeKey;
            updateUploadPlaceholder();
            currentImage = null;
            currentImageDataUrl = null;
            textureImageDataUrl = null;
            fileInput.value = "";

            const shape = getCurrentShape();
            load3DModel(shape);
            mainDraw();
          }
        }
      }

      async function handleShapeTypeChange(event) {
        currentShapeType = event.target.value;
        toggleViewSelector();
        updateSpecificShapeSelector();
        updateUploadPlaceholder();
        currentImage = null;
        currentImageDataUrl = null;
        textureImageDataUrl = null;
        fileInput.value = "";
        mainDraw();
      }

      async function handleShapeChange(event) {
        const selectedValue = event.target.value;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const group = shapeGroups[selectedValue];
          currentShape = group.top || group.bottom;
        } else {
          currentShape = selectedValue;
        }

        syncSweetBoxViewControls();
        updateUploadPlaceholder();
        currentImage = null;
        currentImageDataUrl = null;
        textureImageDataUrl = null;
        fileInput.value = "";

        const shape = getCurrentShape();
        load3DModel(shape);
        mainDraw();
      }

      // ========== EXPORT FUNCTIONS ==========

      async function exportPNG() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }

        isExporting = true;
        showLoading("Exporting PNG...", "Generating high-resolution image");

        await new Promise(r => setTimeout(r, 50));

        try {
          updateLoading("Exporting PNG...", "Creating canvas");
          
          const exportWidth = shape.width * EXPORT_SCALE;
          const exportHeight = shape.height * EXPORT_SCALE;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const exportCtx = exportCanvas.getContext("2d", { alpha: true });

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PNG...", "Rendering image");

          drawShape(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, true);

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PNG...", "Generating file");

          const blob = await new Promise((resolve, reject) => {
            exportCanvas.toBlob(
              (b) => {
                if (b) resolve(b);
                else reject(new Error("Failed to create blob"));
              },
              "image/png",
              1.0
            );
          });

          updateLoading("Exporting PNG...", "Starting download");
          
          await triggerDownload(blob, `${currentShape}_Wrap.png`);
          
          hideLoading();
        } catch (error) {
          console.error("Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the PNG file. Please try again.");
        }
      }

      function hexToRgb(hex) {
        const h = hex.replace("#", "");
        const bigint = parseInt(h.length === 3 ? h.split("").map((c) => c + c).join("") : h, 16);
        return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
      }

      function rgbToCmyk(r, g, b) {
        const rn = r / 255, gn = g / 255, bn = b / 255;
        const k = 1 - Math.max(rn, gn, bn);
        if (k >= 1) return { c: 0, m: 0, y: 0, k: 1 };
        return { c: (1 - rn - k) / (1 - k), m: (1 - gn - k) / (1 - k), y: (1 - bn - k) / (1 - k), k };
      }

      function hexToCmykPercentString(hex) {
        const rgb = hexToRgb(hex);
        const cmyk = rgbToCmyk(rgb.r, rgb.g, rgb.b);
        const pc = (v) => Math.round(v * 100);
        return `${pc(cmyk.c)}% ${pc(cmyk.m)}% ${pc(cmyk.y)}% ${pc(cmyk.k)}%`;
      }

      function createSVGString() {
        const shape = getCurrentShape();
        if (!shape) return null;
        let svgContent = "";

        if (currentImage) {
          const exportWidth = shape.width * EXPORT_SCALE;
          const exportHeight = shape.height * EXPORT_SCALE;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const exportCtx = exportCanvas.getContext("2d", { alpha: true });
          renderImageContent(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, true);
          const rasterData = exportCanvas.toDataURL("image/png");
          svgContent = `<image x="0" y="0" width="${shape.width}" height="${shape.height}" xlink:href="${rasterData}" preserveAspectRatio="none" />`;
          svgContent += `\n<!-- CMYK-VECTORS-HINT: fill=${hexToCmykPercentString("#eeeeee")} (vectors only) -->`;
        } else {
          svgContent = `<path d="${shape.path}" fill="#eeeeee" data-cmyk-fill="${hexToCmykPercentString("#eeeeee")}" />`;
        }

        return `<?xml version="1.0" encoding="UTF-8"?>\n<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 ${shape.width} ${shape.height}" xml:space="preserve">\n${svgContent}\n</svg>`;
      }

      async function exportSVG() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }
        
        isExporting = true;
        showLoading("Exporting SVG...", "Creating vector file");

        await new Promise(r => setTimeout(r, 50));

        try {
          updateLoading("Exporting SVG...", "Generating content");
          
          const svgString = createSVGString();
          if (!svgString) {
            throw new Error("Failed to create SVG content");
          }

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting SVG...", "Starting download");

          const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
          await triggerDownload(blob, `${currentShape}_Wrap.svg`);
          
          hideLoading();
        } catch (error) {
          console.error("Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the SVG file. Please try again.");
        }
      }

      // ========== PDF EXPORT (Transparent Background for Adobe Illustrator) ==========
      async function exportPDF() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }
        
        // Check if jsPDF is loaded
        if (typeof window.jspdf === 'undefined') {
          showError("Library Error", "PDF library not loaded. Please refresh the page and try again.");
          return;
        }

        isExporting = true;
        showLoading("Exporting PDF...", "Creating document");

        await new Promise(r => setTimeout(r, 50));

        try {
          const { jsPDF } = window.jspdf;
          
          updateLoading("Exporting PDF...", "Rendering image");
          
          // Create high-resolution canvas with TRANSPARENCY
          const exportWidth = shape.width * EXPORT_SCALE;
          const exportHeight = shape.height * EXPORT_SCALE;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const exportCtx = exportCanvas.getContext("2d", { alpha: true });
          
          // Clear with transparent background (NO white fill)
          exportCtx.clearRect(0, 0, exportWidth, exportHeight);
          
          // Draw only the shape content (no background)
          renderImageContent(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, false);

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PDF...", "Generating PDF");

          // Get image data as PNG to preserve transparency
          const imgData = exportCanvas.toDataURL('image/png');
          
          // Create PDF with exact dimensions
          const pdf = new jsPDF({
            orientation: shape.width > shape.height ? 'landscape' : 'portrait',
            unit: 'pt',
            format: [shape.width, shape.height],
            compress: true
          });
          
          // Add the transparent PNG image
          pdf.addImage(imgData, 'PNG', 0, 0, shape.width, shape.height, undefined, 'FAST');
          
          // Add metadata
          pdf.setProperties({
            title: `${currentShape}_Wrap`,
            subject: 'Label Wrap Export - Transparent Background',
            creator: 'Terra Tech Packs',
            keywords: 'label, wrap, packaging, transparent'
          });

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PDF...", "Starting download");

          // Save the PDF
          pdf.save(`${currentShape}_Wrap.pdf`);
          
          await new Promise(r => setTimeout(r, 500));
          
          hideLoading();
        } catch (error) {
          console.error("PDF Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the PDF file. Please try again.");
        }
      }

      // --- Event Listeners ---
      window.addEventListener("resize", debounce(mainDraw, 150));
      fileInput.addEventListener("input", handleImageUpload);
      exportPngBtn.addEventListener("click", exportPNG);
      exportSvgBtn.addEventListener("click", exportSVG);
      exportPdfBtn.addEventListener("click", exportPDF);
      shapeTypeSelect.addEventListener("change", handleShapeTypeChange);
      shapeSelect.addEventListener("change", handleShapeChange);
      document.querySelectorAll('input[name="view_type"]').forEach((radio) => {
        radio.addEventListener("change", handleViewChange);
      });

      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey || e.metaKey) {
          if (e.key === "p") {
            e.preventDefault();
            exportPNG();
          } else if (e.key === "s") {
            e.preventDefault();
            exportSVG();
          }
        }
      });

      const fileUploadLabel = document.querySelector(".file-upload-label");
      fileUploadLabel.addEventListener("dragover", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.add("dragover");
      });
      fileUploadLabel.addEventListener("dragleave", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.remove("dragover");
      });
      fileUploadLabel.addEventListener("drop", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.remove("dragover");
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          fileInput.files = e.dataTransfer.files;
          fileInput.dispatchEvent(new Event("input", { bubbles: true }));
        }
      });

      // --- Initialization ---
      function initializeApp() {
        preProcessShapes();
        populateShapeTypes();
        toggleViewSelector();
        updateSpecificShapeSelector();
        updateUploadPlaceholder();
        mainDraw();
      }

      initializeApp();
    </script>
  </body>
</html>