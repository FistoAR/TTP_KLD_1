<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Terra Tech Packs KLD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script
      type="module"
      src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.3.0/model-viewer.min.js"
    ></script>
    <style>
      .dragover { border-color: #3b82f6; }
      .radio-container.hidden { display: none; }
      
      /* Loading Overlay */
      .loading-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        flex-direction: column;
        backdrop-filter: blur(4px);
      }
      .loading-overlay.show { display: flex; }
      .loading-box {
        background: white;
        padding: 30px 50px;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
      }
      .spinner {
        border: 4px solid #e5e7eb;
        border-top: 4px solid #3b82f6;
        border-radius: 50%;
        width: 50px; height: 50px;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      .loading-text {
        color: #374151;
        font-size: 16px;
        font-weight: 500;
      }
      .loading-subtext {
        color: #9ca3af;
        font-size: 13px;
      }
      
      /* Error Popup Modal */
      .error-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1001;
        backdrop-filter: blur(2px);
      }
      .error-overlay.show { display: flex; }
      .error-popup {
        background: white;
        padding: 24px 32px;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 400px;
        width: 90%;
        text-align: center;
        animation: popIn 0.2s ease-out;
      }
      @keyframes popIn {
        0% { transform: scale(0.9); opacity: 0; }
        100% { transform: scale(1); opacity: 1; }
      }
      .error-icon {
        width: 56px;
        height: 56px;
        background: #fef2f2;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
      }
      .error-icon svg {
        width: 28px;
        height: 28px;
        fill: #ef4444;
      }
      .error-title {
        color: #1f2937;
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 8px;
      }
      .error-message {
        color: #6b7280;
        font-size: 14px;
        line-height: 1.5;
        margin-bottom: 20px;
        white-space: pre-line;
      }
      .error-close-btn {
        background: #3b82f6;
        color: white;
        border: none;
        padding: 10px 32px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
      }
      .error-close-btn:hover {
        background: #2563eb;
      }
      
      .site-logo {
        position: absolute;
        left: 2vw;
        top: 50%;
        transform: translateY(-50%);
        height: 2vw;
        object-fit: contain;
        z-index: 60;
      }
      @media (max-width: 420px) { .site-logo { display: none; } }
      @media (max-width: 640px) { .site-logo { height: 36px; left: 8px; } }
      
      /* 3D Viewer Container */
      #viewer3DContainer {
        position: absolute;
        top: 12px; right: 12px;
        width: 200px; height: 200px;
        background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
        border-radius: 12px;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
        overflow: hidden;
        z-index: 50;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
      }
      #viewer3DContainer:hover { box-shadow: 0 10px 35px rgba(0, 0, 0, 0.4); }
      #viewer3DContainer.expanded {
        width: 400px;
        height: 350px;
      }
      #modelViewer {
        width: 100%; height: 100%;
        display: block;
        --poster-color: transparent;
        --progress-bar-color: #3b82f6;
        --progress-bar-height: 2px;
      }
      .viewer3D-loading {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #64748b;
        font-size: 11px;
        text-align: center;
        z-index: 5;
        pointer-events: none;
      }
      .viewer3D-loading.hidden { display: none; }
      .viewer3D-loading .mini-spinner {
        width: 20px; height: 20px;
        border: 2px solid rgba(100, 116, 139, 0.3);
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 6px;
      }
      .viewer3D-status {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #64748b;
        font-size: 11px;
        text-align: center;
        z-index: 5;
        padding: 8px;
      }
      .viewer3D-status.hidden { display: none; }
      
      /* Viewer Controls */
      .viewer3D-controls {
        position: absolute;
        top: 6px; right: 6px;
        display: flex;
        gap: 4px;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.2s;
      }
      #viewer3DContainer:hover .viewer3D-controls { opacity: 1; }
      .viewer3D-btn {
        width: 24px; height: 24px;
        background: rgba(0, 0, 0, 0.6);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }
      .viewer3D-btn:hover { background: rgba(59, 130, 246, 0.8); }
      .viewer3D-btn svg { width: 14px; height: 14px; fill: #fff; }
      
      /* Minimized State */
      #viewer3DContainer.minimized { 
        width: 80px; 
        height: 28px; 
        cursor: pointer; 
      }
      #viewer3DContainer.minimized #modelViewer,
      #viewer3DContainer.minimized .viewer3D-loading,
      #viewer3DContainer.minimized .viewer3D-status { display: none !important; }
      #viewer3DContainer.minimized::after {
        content: "3D View";
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #94a3b8;
        font-size: 11px;
        font-weight: 600;
      }
      #viewer3DContainer.minimized #viewer3DExpand { display: none !important; }
      #viewer3DContainer.minimized .viewer3D-controls {
        opacity: 1;
        top: 50%;
        right: 6px;
        transform: translateY(-50%);
      }
      
      @media (max-width: 768px) {
        #viewer3DContainer { width: 160px; height: 160px; top: 8px; right: 8px; }
        #viewer3DContainer.expanded { width: 300px; height: 260px; }
      }
      @media (max-width: 480px) {
        #viewer3DContainer { width: 130px; height: 130px; }
        #viewer3DContainer.expanded { width: 240px; height: 210px; }
        #viewer3DContainer.minimized { width: 70px; height: 24px; }
      }
      
      /* Disable buttons during loading */
      .export:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      /* Zoom Controls */
      .zoom-controls {
        position: absolute;
        bottom: 16px;
        left: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 40;
      }
      .zoom-btn-group {
        display: flex;
        justify-content: space-between;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        overflow: hidden;
        border: 1px solid #e2e8f0;
      }
      .zoom-btn {
        width: 100%;
        height: 36px;
        border: none;
        background: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        color: #475569;
        margin: 0 auto;
      }
      .zoom-btn:hover {
        background: #f1f5f9;
        color: #3b82f6;
      }
      .zoom-btn:active {
        background: #e2e8f0;
      }
      .zoom-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .zoom-btn:disabled:hover {
        background: white;
        color: #475569;
      }
      .zoom-btn svg {
        width: 18px;
        height: 18px;
        fill: currentColor;
      }
      .zoom-divider {
        width: 1px;
        background: #e2e8f0;
      }
      .zoom-display {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        padding: 6px 12px;
        font-size: 12px;
        font-weight: 600;
        color: #475569;
        text-align: center;
        min-width: 60px;
        border: 1px solid #e2e8f0;
        cursor: pointer;
        transition: all 0.2s;
      }
      .zoom-display:hover {
        background: #f1f5f9;
        color: #3b82f6;
      }
      
      /* Pan indicator */
      .pan-indicator {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 500;
        color: #64748b;
        text-align: center;
        border: 1px solid #e2e8f0;
        display: flex;
        align-items: center;
        gap: 6px;
        opacity: 0;
        transition: opacity 0.2s;
      }
      .pan-indicator.visible {
        opacity: 1;
      }
      .pan-indicator.active {
        background: #3b82f6;
        color: white;
        border-color: #3b82f6;
      }
      .pan-indicator svg {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }
      
      /* Reset pan button */
      .reset-pan-btn {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 500;
        color: #475569;
        text-align: center;
        border: 1px solid #e2e8f0;
        cursor: pointer;
        display: none;
        align-items: center;
        gap: 6px;
        transition: all 0.2s;
      }
      .reset-pan-btn:hover {
        background: #f1f5f9;
        color: #3b82f6;
      }
      .reset-pan-btn.visible {
        display: flex;
      }
      .reset-pan-btn svg {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }
      
      @media (max-width: 480px) {
        .zoom-controls {
          bottom: 12px;
          left: 12px;
        }
        .zoom-btn {
          width: 32px;
          height: 32px;
        }
        .zoom-btn svg {
          width: 16px;
          height: 16px;
        }
        .zoom-display {
          padding: 5px 10px;
          font-size: 11px;
          min-width: 50px;
        }
        .pan-indicator, .reset-pan-btn {
          font-size: 10px;
          padding: 5px 8px;
        }
      }

      /* Canvas container for panning */
      .canvas-container {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      
      /* Canvas cursor states */
      #warpCanvas {
        cursor: default;
      }
      #warpCanvas.can-pan {
        cursor: grab;
      }
      #warpCanvas.space-held {
        cursor: grab;
      }
      #warpCanvas.panning {
        cursor: grabbing !important;
      }

      /* Vector export button style */
      .export-vector {
        background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      }
      .export-vector:hover {
        background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
      }

      /* SVG indicator badge */
      .svg-badge {
        position: absolute;
        top: -8px;
        right: -8px;
        background: #10b981;
        color: white;
        font-size: 9px;
        font-weight: 700;
        padding: 2px 6px;
        border-radius: 10px;
        display: none;
      }
      .svg-badge.visible {
        display: block;
      }
    </style>
  </head>
  <body class="bg-slate-100 flex flex-col h-screen overflow-hidden font-sans">
    <div class="bg-white shadow-md z-10 relative">
      <img src="./assets/terratechpacks.png" alt="Terra Tech Packs" class="site-logo" />
      <div class="container mx-auto pt-4 pb-3 flex justify-center items-end flex-wrap gap-x-6 gap-y-4">
        <div class="flex flex-col">
          <label for="shapeTypeSelect" class="text-xs font-semibold text-slate-600 mb-1">Select Shape Type:</label>
          <select id="shapeTypeSelect" class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 transition cursor-pointer"></select>
        </div>
        <div class="flex flex-col">
          <label for="shapeSelect" class="text-xs font-semibold text-slate-600 mb-1">Select Specific Shape:</label>
          <select id="shapeSelect" class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 transition cursor-pointer"></select>
        </div>
        <div id="viewSelector" class="hidden self-end pb-1">
          <div class="radio-group flex flex-col gap-1">
            <div class="radio-container">
              <input type="radio" id="viewTopRadio" name="view_type" value="top" class="cursor-pointer accent-blue-600" />
              <label for="viewTopRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Top</label>
            </div>
            <div class="radio-container">
              <input type="radio" id="viewBottomRadio" name="view_type" value="bottom" checked class="cursor-pointer accent-blue-600" />
              <label for="viewBottomRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Bottom</label>
            </div>
          </div>
        </div>
        <div id="dropArea" class="flex flex-col relative">
          <label for="imageUpload" class="text-xs font-semibold text-slate-600 mb-1">Upload Label:</label>
          <label class="file-upload-label h-12 min-w-[180px] flex items-center justify-center px-5 bg-slate-50 border-2 border-dashed border-slate-400 rounded-lg cursor-pointer hover:border-blue-500 transition relative" for="imageUpload">
            <input type="file" id="imageUpload" class="hidden" accept="image/*,.svg" />
            <small id="uploadText" class="font-medium text-slate-700">Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span></small>
            <span id="svgBadge" class="svg-badge">SVG</span>
          </label>
        </div>
        <button class="export h-12 px-6 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition" id="exportPngBtn">Export PNG</button>
        <button class="export export-vector h-12 px-6 text-white font-semibold rounded-lg transition" id="exportVectorSvgBtn" title="Export as vector SVG">Export SVG</button>
        <button class="export h-12 px-6 bg-red-700 text-white font-semibold rounded-lg hover:bg-red-800 transition" id="exportPdfBtn">Export PDF</button>
      </div>
    </div>

    <div class="flex-grow p-4 md:p-6 flex items-center justify-center relative">
      <div class="canvas-container">
        <canvas id="warpCanvas" class="w-full h-full bg-white rounded-lg shadow-sm"></canvas>
      </div>
      
      <!-- Zoom Controls -->
      <div class="zoom-controls">
        <div class="zoom-btn-group">
          <button id="zoomInBtn" class="zoom-btn" title="Zoom In (Ctrl++)">
            <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
          </button>
          <div class="zoom-divider"></div>
          <button id="zoomOutBtn" class="zoom-btn" title="Zoom Out (Ctrl+-)">
            <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
          </button>
        </div>
        <div id="zoomDisplay" class="zoom-display" title="Click to reset zoom">100%</div>
        
        <!-- Pan indicator -->
        <div id="panIndicator" class="pan-indicator">
          <svg viewBox="0 0 24 24"><path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"/></svg>
          <span id="panIndicatorText">Hold Space + Drag</span>
        </div>
        
        <!-- Reset pan button -->
        <button id="resetPanBtn" class="reset-pan-btn" title="Reset pan position">
          <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
          <span>Reset View</span>
        </button>
      </div>
      
      <!-- 3D Viewer -->
      <div id="viewer3DContainer">
        <div class="viewer3D-controls">
          <button id="viewer3DExpand" class="viewer3D-btn" title="Expand">
            <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
          </button>
          <button id="viewer3DToggle" class="viewer3D-btn" title="Minimize">
            <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
          </button>
        </div>
        
        <div class="viewer3D-loading" id="viewer3DLoading">
          <div class="mini-spinner"></div>
          <span>Loading...</span>
        </div>
        <div class="viewer3D-status hidden" id="viewer3DStatus"></div>
        
        <model-viewer
          id="modelViewer"
          alt="3D product preview"
          camera-controls
          auto-rotate
          rotation-per-second="30deg"
          exposure="1.0"
          shadow-intensity="1"
          environment-image="neutral"
          interaction-prompt="none"
          style="background: transparent"
        ></model-viewer>
      </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-box">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Processing...</div>
        <div class="loading-subtext" id="loadingSubtext">Please wait</div>
      </div>
    </div>

    <!-- Error Popup Modal -->
    <div id="errorOverlay" class="error-overlay">
      <div class="error-popup">
        <div class="error-icon">
          <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
        </div>
        <div class="error-title" id="errorTitle">Error</div>
        <div class="error-message" id="errorMessage">Something went wrong.</div>
        <button class="error-close-btn" id="errorCloseBtn">OK</button>
      </div>
    </div>
        <script type="module">
      // ========== HELPERS ==========
      function debounce(fn, wait = 150) {
        let t;
        return (...args) => {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, args), wait);
        };
      }

      // ========== PATH SAMPLER ==========
      class PathSampler {
        constructor(pathData) {
          this.pathNode = document.createElementNS("http://www.w3.org/2000/svg", "path");
          this.pathNode.setAttribute("d", pathData);
          this.length = this.pathNode.getTotalLength();
        }
        getPointAt(percentage) {
          return this.pathNode.getPointAtLength(this.length * percentage);
        }
      }

      // ========== ENHANCED MESH WARPER CLASS ==========
      class MeshWarper {
        constructor(topPath, bottomPath, sourceWidth, sourceHeight, options = {}) {
          this.topSampler = new PathSampler(topPath);
          this.bottomSampler = new PathSampler(bottomPath);
          this.sourceWidth = sourceWidth;
          this.sourceHeight = sourceHeight;
          this.gridCols = options.gridCols || 50;
          this.gridRows = options.gridRows || 20;
          this.topIsReversed = options.topIsReversed || false;
          this.bottomIsReversed = options.bottomIsReversed || false;
          this.mesh = null;
          this.buildMesh();
        }

        buildMesh() {
          this.mesh = [];
          for (let row = 0; row <= this.gridRows; row++) {
            const rowPoints = [];
            const v = row / this.gridRows;
            
            for (let col = 0; col <= this.gridCols; col++) {
              const u = col / this.gridCols;
              
              const tTop = this.topIsReversed ? 1 - u : u;
              const tBot = this.bottomIsReversed ? 1 - u : u;
              
              const topPoint = this.topSampler.getPointAt(Math.max(0, Math.min(1, tTop)));
              const bottomPoint = this.bottomSampler.getPointAt(Math.max(0, Math.min(1, tBot)));
              
              // Smooth interpolation using cosine for better curve quality
              const smoothV = v;
              const x = topPoint.x + (bottomPoint.x - topPoint.x) * smoothV;
              const y = topPoint.y + (bottomPoint.y - topPoint.y) * smoothV;
              
              rowPoints.push({ x, y, u, v });
            }
            this.mesh.push(rowPoints);
          }
        }

        transformPoint(srcX, srcY) {
          const u = srcX / this.sourceWidth;
          const v = srcY / this.sourceHeight;
          return this.transformNormalized(u, v);
        }

        transformNormalized(u, v) {
          u = Math.max(0, Math.min(1, u));
          v = Math.max(0, Math.min(1, v));
          
          const colFloat = u * this.gridCols;
          const rowFloat = v * this.gridRows;
          
          const col = Math.min(Math.floor(colFloat), this.gridCols - 1);
          const row = Math.min(Math.floor(rowFloat), this.gridRows - 1);
          
          const colFrac = colFloat - col;
          const rowFrac = rowFloat - row;
          
          const p00 = this.mesh[row][col];
          const p01 = this.mesh[row][col + 1];
          const p10 = this.mesh[row + 1][col];
          const p11 = this.mesh[row + 1][col + 1];
          
          const x = (1 - colFrac) * (1 - rowFrac) * p00.x +
                    colFrac * (1 - rowFrac) * p01.x +
                    (1 - colFrac) * rowFrac * p10.x +
                    colFrac * rowFrac * p11.x;
                    
          const y = (1 - colFrac) * (1 - rowFrac) * p00.y +
                    colFrac * (1 - rowFrac) * p01.y +
                    (1 - colFrac) * rowFrac * p10.y +
                    colFrac * rowFrac * p11.y;
          
          return { x, y };
        }

        getMeshPoints() {
          return this.mesh;
        }
      }

      // ========== SVG PATH PARSER ==========
      class SVGPathParser {
        static parse(pathData) {
          const commands = [];
          let match;
          const regex = /([MmLlHhVvCcSsQqTtAaZz])([^MmLlHhVvCcSsQqTtAaZz]*)/g;
          while ((match = regex.exec(pathData)) !== null) {
            const type = match[1];
            const argsStr = match[2].trim();
            const args = argsStr.match(/-?(?:\d+\.?\d*|\.\d+)(?:[eE][-+]?\d+)?/g)?.map(Number) || [];
            commands.push({ type, args });
          }
          return commands;
        }

        static toAbsolute(commands) {
          const result = [];
          let currentX = 0, currentY = 0;
          let startX = 0, startY = 0;

          for (const cmd of commands) {
            const { type, args } = cmd;
            const newArgs = [...args];
            let newType = type.toUpperCase();

            switch (type) {
              case 'm':
                newArgs[0] += currentX;
                newArgs[1] += currentY;
                currentX = newArgs[0];
                currentY = newArgs[1];
                startX = currentX;
                startY = currentY;
                break;
              case 'M':
                currentX = args[0];
                currentY = args[1];
                startX = currentX;
                startY = currentY;
                break;
              case 'l':
                newArgs[0] += currentX;
                newArgs[1] += currentY;
                currentX = newArgs[0];
                currentY = newArgs[1];
                break;
              case 'L':
                currentX = args[0];
                currentY = args[1];
                break;
              case 'h':
                newArgs[0] = currentX + args[0];
                newArgs[1] = currentY;
                newType = 'L';
                currentX = newArgs[0];
                break;
              case 'H':
                newArgs[0] = args[0];
                newArgs[1] = currentY;
                newType = 'L';
                currentX = args[0];
                break;
              case 'v':
                newArgs[0] = currentX;
                newArgs[1] = currentY + args[0];
                newType = 'L';
                currentY = newArgs[1];
                break;
              case 'V':
                newArgs[0] = currentX;
                newArgs[1] = args[0];
                newType = 'L';
                currentY = args[0];
                break;
              case 'c':
                for (let i = 0; i < 6; i += 2) {
                  newArgs[i] += currentX;
                  newArgs[i + 1] += currentY;
                }
                currentX = newArgs[4];
                currentY = newArgs[5];
                break;
              case 'C':
                currentX = args[4];
                currentY = args[5];
                break;
              case 's':
                for (let i = 0; i < 4; i += 2) {
                  newArgs[i] += currentX;
                  newArgs[i + 1] += currentY;
                }
                currentX = newArgs[2];
                currentY = newArgs[3];
                break;
              case 'S':
                currentX = args[2];
                currentY = args[3];
                break;
              case 'q':
                for (let i = 0; i < 4; i += 2) {
                  newArgs[i] += currentX;
                  newArgs[i + 1] += currentY;
                }
                currentX = newArgs[2];
                currentY = newArgs[3];
                break;
              case 'Q':
                currentX = args[2];
                currentY = args[3];
                break;
              case 't':
                newArgs[0] += currentX;
                newArgs[1] += currentY;
                currentX = newArgs[0];
                currentY = newArgs[1];
                break;
              case 'T':
                currentX = args[0];
                currentY = args[1];
                break;
              case 'a':
                newArgs[5] += currentX;
                newArgs[6] += currentY;
                currentX = newArgs[5];
                currentY = newArgs[6];
                break;
              case 'A':
                currentX = args[5];
                currentY = args[6];
                break;
              case 'z':
              case 'Z':
                currentX = startX;
                currentY = startY;
                break;
            }
            result.push({ type: newType, args: newArgs });
          }
          return result;
        }

        static toString(commands, precision = 3) {
          return commands.map(cmd => {
            const argsStr = cmd.args.map(n => 
              Number.isInteger(n) ? n : parseFloat(n.toFixed(precision))
            ).join(' ');
            return `${cmd.type}${argsStr}`;
          }).join(' ');
        }
      }

      // ========== SVG PATH WARPER ==========
      class SVGPathWarper {
        constructor(warper) {
          this.warper = warper;
        }

        subdivideCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, segments = 16) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const mt = 1 - t;
            const mt2 = mt * mt;
            const mt3 = mt2 * mt;
            const t2 = t * t;
            const t3 = t2 * t;
            
            const x = mt3 * x0 + 3 * mt2 * t * x1 + 3 * mt * t2 * x2 + t3 * x3;
            const y = mt3 * y0 + 3 * mt2 * t * y1 + 3 * mt * t2 * y2 + t3 * y3;
            
            points.push({ x, y });
          }
          return points;
        }

        subdivideQuadraticBezier(x0, y0, x1, y1, x2, y2, segments = 16) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const mt = 1 - t;
            const mt2 = mt * mt;
            const t2 = t * t;
            
            const x = mt2 * x0 + 2 * mt * t * x1 + t2 * x2;
            const y = mt2 * y0 + 2 * mt * t * y1 + t2 * y2;
            
            points.push({ x, y });
          }
          return points;
        }

        subdivideLine(x0, y0, x1, y1, segments) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            points.push({
              x: x0 + (x1 - x0) * t,
              y: y0 + (y1 - y0) * t
            });
          }
          return points;
        }

        approximateArc(x0, y0, rx, ry, xAxisRotation, largeArc, sweep, x1, y1, segments) {
          const phi = xAxisRotation * Math.PI / 180;
          const cosPhi = Math.cos(phi);
          const sinPhi = Math.sin(phi);
          
          const dx = (x0 - x1) / 2;
          const dy = (y0 - y1) / 2;
          const x1p = cosPhi * dx + sinPhi * dy;
          const y1p = -sinPhi * dx + cosPhi * dy;
          
          let rxSq = rx * rx;
          let rySq = ry * ry;
          const x1pSq = x1p * x1p;
          const y1pSq = y1p * y1p;
          
          const lambda = x1pSq / rxSq + y1pSq / rySq;
          if (lambda > 1) {
            rx *= Math.sqrt(lambda);
            ry *= Math.sqrt(lambda);
            rxSq = rx * rx;
            rySq = ry * ry;
          }
          
          let sq = Math.max(0, (rxSq * rySq - rxSq * y1pSq - rySq * x1pSq) / (rxSq * y1pSq + rySq * x1pSq));
          sq = Math.sqrt(sq) * (largeArc === sweep ? -1 : 1);
          
          const cxp = sq * rx * y1p / ry;
          const cyp = -sq * ry * x1p / rx;
          
          const cx = cosPhi * cxp - sinPhi * cyp + (x0 + x1) / 2;
          const cy = sinPhi * cxp + cosPhi * cyp + (y0 + y1) / 2;
          
          const ux = (x1p - cxp) / rx;
          const uy = (y1p - cyp) / ry;
          const vx = (-x1p - cxp) / rx;
          const vy = (-y1p - cyp) / ry;
          
          const n = Math.sqrt(ux * ux + uy * uy);
          let theta1 = Math.acos(Math.max(-1, Math.min(1, ux / n)));
          if (uy < 0) theta1 = -theta1;
          
          const nn = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));
          let dTheta = Math.acos(Math.max(-1, Math.min(1, (ux * vx + uy * vy) / nn)));
          if (ux * vy - uy * vx < 0) dTheta = -dTheta;
          
          if (sweep && dTheta < 0) dTheta += 2 * Math.PI;
          if (!sweep && dTheta > 0) dTheta -= 2 * Math.PI;
          
          const points = [{ x: x0, y: y0 }];
          for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            const angle = theta1 + dTheta * t;
            const xp = rx * Math.cos(angle);
            const yp = ry * Math.sin(angle);
            const x = cosPhi * xp - sinPhi * yp + cx;
            const y = sinPhi * xp + cosPhi * yp + cy;
            points.push({ x, y });
          }
          
          return points;
        }

        transformPoint(x, y) {
          return this.warper.transformPoint(x, y);
        }

        warpPath(pathData, subdivisions = 12) {
          const commands = SVGPathParser.parse(pathData);
          const absolute = SVGPathParser.toAbsolute(commands);
          
          const result = [];
          let currentX = 0, currentY = 0;
          let lastControlX = 0, lastControlY = 0;
          let startX = 0, startY = 0;

          for (const cmd of absolute) {
            const { type, args } = cmd;

            switch (type) {
              case 'M': {
                const warped = this.transformPoint(args[0], args[1]);
                result.push({ type: 'M', args: [warped.x, warped.y] });
                currentX = args[0];
                currentY = args[1];
                startX = currentX;
                startY = currentY;
                lastControlX = currentX;
                lastControlY = currentY;
                break;
              }

              case 'L': {
                const points = this.subdivideLine(currentX, currentY, args[0], args[1], subdivisions);
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                currentX = args[0];
                currentY = args[1];
                lastControlX = currentX;
                lastControlY = currentY;
                break;
              }

              case 'C': {
                const points = this.subdivideCubicBezier(
                  currentX, currentY,
                  args[0], args[1],
                  args[2], args[3],
                  args[4], args[5],
                  subdivisions * 2
                );
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                lastControlX = args[2];
                lastControlY = args[3];
                currentX = args[4];
                currentY = args[5];
                break;
              }

              case 'S': {
                const cx1 = 2 * currentX - lastControlX;
                const cy1 = 2 * currentY - lastControlY;
                const points = this.subdivideCubicBezier(
                  currentX, currentY,
                  cx1, cy1,
                  args[0], args[1],
                  args[2], args[3],
                  subdivisions * 2
                );
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                lastControlX = args[0];
                lastControlY = args[1];
                currentX = args[2];
                currentY = args[3];
                break;
              }

              case 'Q': {
                const points = this.subdivideQuadraticBezier(
                  currentX, currentY,
                  args[0], args[1],
                  args[2], args[3],
                  subdivisions * 2
                );
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                lastControlX = args[0];
                lastControlY = args[1];
                currentX = args[2];
                currentY = args[3];
                break;
              }

              case 'T': {
                const cx = 2 * currentX - lastControlX;
                const cy = 2 * currentY - lastControlY;
                const points = this.subdivideQuadraticBezier(
                  currentX, currentY,
                  cx, cy,
                  args[0], args[1],
                  subdivisions * 2
                );
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                lastControlX = cx;
                lastControlY = cy;
                currentX = args[0];
                currentY = args[1];
                break;
              }

              case 'A': {
                const points = this.approximateArc(
                  currentX, currentY,
                  args[0], args[1], args[2], 
                  args[3] === 1, args[4] === 1,
                  args[5], args[6],
                  subdivisions * 3
                );
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                currentX = args[5];
                currentY = args[6];
                lastControlX = currentX;
                lastControlY = currentY;
                break;
              }

              case 'Z': {
                if (currentX !== startX || currentY !== startY) {
                  const points = this.subdivideLine(currentX, currentY, startX, startY, subdivisions);
                  for (let i = 1; i < points.length; i++) {
                    const warped = this.transformPoint(points[i].x, points[i].y);
                    result.push({ type: 'L', args: [warped.x, warped.y] });
                  }
                }
                result.push({ type: 'Z', args: [] });
                currentX = startX;
                currentY = startY;
                break;
              }
            }
          }

          return SVGPathParser.toString(result);
        }
      }

      // ===== END OF PART 2 =====

            // ========== SVG DOCUMENT TRANSFORMER ==========
      class SVGDocumentTransformer {
        constructor(warper, sourceWidth, sourceHeight) {
          this.pathWarper = new SVGPathWarper(warper);
          this.sourceWidth = sourceWidth;
          this.sourceHeight = sourceHeight;
          this.warper = warper;
        }

        transformSVG(svgString, targetWidth, targetHeight) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgString, 'image/svg+xml');
          const svgElement = doc.querySelector('svg');
          
          if (!svgElement) {
            throw new Error('Invalid SVG document');
          }

          const viewBox = svgElement.getAttribute('viewBox');
          let vbWidth = this.sourceWidth;
          let vbHeight = this.sourceHeight;
          let vbX = 0, vbY = 0;
          
          if (viewBox) {
            const parts = viewBox.split(/[\s,]+/).map(Number);
            if (parts.length === 4) {
              vbX = parts[0];
              vbY = parts[1];
              vbWidth = parts[2];
              vbHeight = parts[3];
            }
          } else {
            const w = parseFloat(svgElement.getAttribute('width'));
            const h = parseFloat(svgElement.getAttribute('height'));
            if (w && h) {
              vbWidth = w;
              vbHeight = h;
            }
          }

          const scaleX = this.sourceWidth / vbWidth;
          const scaleY = this.sourceHeight / vbHeight;

          this.transformElement(svgElement, scaleX, scaleY, vbX, vbY);

          svgElement.setAttribute('viewBox', `0 0 ${targetWidth} ${targetHeight}`);
          svgElement.setAttribute('width', targetWidth);
          svgElement.setAttribute('height', targetHeight);
          svgElement.removeAttribute('xmlns:xlink');

          return new XMLSerializer().serializeToString(doc);
        }

        transformElement(element, scaleX, scaleY, offsetX = 0, offsetY = 0) {
          if (element.nodeType !== 1) return;

          const tagName = element.tagName?.toLowerCase();

          if (tagName === 'path') {
            const d = element.getAttribute('d');
            if (d) {
              const scaledPath = this.scalePath(d, scaleX, scaleY, offsetX, offsetY);
              const warpedPath = this.pathWarper.warpPath(scaledPath, 16);
              element.setAttribute('d', warpedPath);
            }
          }

          if (tagName === 'circle') {
            const cx = (parseFloat(element.getAttribute('cx') || 0) - offsetX) * scaleX;
            const cy = (parseFloat(element.getAttribute('cy') || 0) - offsetY) * scaleY;
            const r = parseFloat(element.getAttribute('r') || 0) * Math.min(scaleX, scaleY);
            
            const pathData = this.circleToPath(cx, cy, r);
            const warpedPath = this.pathWarper.warpPath(pathData, 16);
            
            const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', warpedPath);
            this.copyAttributes(element, path, ['cx', 'cy', 'r']);
            element.parentNode.replaceChild(path, element);
            return;
          }

          if (tagName === 'ellipse') {
            const cx = (parseFloat(element.getAttribute('cx') || 0) - offsetX) * scaleX;
            const cy = (parseFloat(element.getAttribute('cy') || 0) - offsetY) * scaleY;
            const rx = parseFloat(element.getAttribute('rx') || 0) * scaleX;
            const ry = parseFloat(element.getAttribute('ry') || 0) * scaleY;
            
            const pathData = this.ellipseToPath(cx, cy, rx, ry);
            const warpedPath = this.pathWarper.warpPath(pathData, 16);
            
            const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', warpedPath);
            this.copyAttributes(element, path, ['cx', 'cy', 'rx', 'ry']);
            element.parentNode.replaceChild(path, element);
            return;
          }

          if (tagName === 'rect') {
            const x = (parseFloat(element.getAttribute('x') || 0) - offsetX) * scaleX;
            const y = (parseFloat(element.getAttribute('y') || 0) - offsetY) * scaleY;
            const w = parseFloat(element.getAttribute('width') || 0) * scaleX;
            const h = parseFloat(element.getAttribute('height') || 0) * scaleY;
            let rx = parseFloat(element.getAttribute('rx') || 0) * scaleX;
            let ry = parseFloat(element.getAttribute('ry') || 0) * scaleY;
            
            if (rx && !ry) ry = rx;
            if (ry && !rx) rx = ry;
            
            const pathData = this.rectToPath(x, y, w, h, rx, ry);
            const warpedPath = this.pathWarper.warpPath(pathData, 16);
            
            const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', warpedPath);
            this.copyAttributes(element, path, ['x', 'y', 'width', 'height', 'rx', 'ry']);
            element.parentNode.replaceChild(path, element);
            return;
          }

          if (tagName === 'line') {
            const x1 = (parseFloat(element.getAttribute('x1') || 0) - offsetX) * scaleX;
            const y1 = (parseFloat(element.getAttribute('y1') || 0) - offsetY) * scaleY;
            const x2 = (parseFloat(element.getAttribute('x2') || 0) - offsetX) * scaleX;
            const y2 = (parseFloat(element.getAttribute('y2') || 0) - offsetY) * scaleY;
            
            const pathData = `M${x1},${y1}L${x2},${y2}`;
            const warpedPath = this.pathWarper.warpPath(pathData, 16);
            
            const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', warpedPath);
            this.copyAttributes(element, path, ['x1', 'y1', 'x2', 'y2']);
            element.parentNode.replaceChild(path, element);
            return;
          }

          if (tagName === 'polygon') {
            const points = element.getAttribute('points');
            if (points) {
              const pathData = this.polygonToPath(points, scaleX, scaleY, offsetX, offsetY);
              const warpedPath = this.pathWarper.warpPath(pathData, 16);
              
              const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
              path.setAttribute('d', warpedPath);
              this.copyAttributes(element, path, ['points']);
              element.parentNode.replaceChild(path, element);
              return;
            }
          }

          if (tagName === 'polyline') {
            const points = element.getAttribute('points');
            if (points) {
              const pathData = this.polylineToPath(points, scaleX, scaleY, offsetX, offsetY);
              const warpedPath = this.pathWarper.warpPath(pathData, 16);
              
              const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
              path.setAttribute('d', warpedPath);
              this.copyAttributes(element, path, ['points']);
              element.parentNode.replaceChild(path, element);
              return;
            }
          }

          if (tagName === 'text') {
            const x = (parseFloat(element.getAttribute('x') || 0) - offsetX) * scaleX;
            const y = (parseFloat(element.getAttribute('y') || 0) - offsetY) * scaleY;
            const warped = this.warper.transformPoint(x, y);
            element.setAttribute('x', warped.x.toFixed(3));
            element.setAttribute('y', warped.y.toFixed(3));
            
            const fontSize = element.getAttribute('font-size');
            if (fontSize) {
              const size = parseFloat(fontSize);
              if (!isNaN(size)) {
                element.setAttribute('font-size', (size * Math.min(scaleX, scaleY)).toFixed(3));
              }
            }
          }

          if (tagName === 'image') {
            const x = (parseFloat(element.getAttribute('x') || 0) - offsetX) * scaleX;
            const y = (parseFloat(element.getAttribute('y') || 0) - offsetY) * scaleY;
            const w = parseFloat(element.getAttribute('width') || 0) * scaleX;
            const h = parseFloat(element.getAttribute('height') || 0) * scaleY;
            
            const topLeft = this.warper.transformPoint(x, y);
            const topRight = this.warper.transformPoint(x + w, y);
            const bottomLeft = this.warper.transformPoint(x, y + h);
            const bottomRight = this.warper.transformPoint(x + w, y + h);
            
            const minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
            const minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
            const maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
            const maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
            
            element.setAttribute('x', minX.toFixed(3));
            element.setAttribute('y', minY.toFixed(3));
            element.setAttribute('width', (maxX - minX).toFixed(3));
            element.setAttribute('height', (maxY - minY).toFixed(3));
          }

          const children = Array.from(element.children);
          for (const child of children) {
            this.transformElement(child, scaleX, scaleY, offsetX, offsetY);
          }
        }

        scalePath(pathData, scaleX, scaleY, offsetX = 0, offsetY = 0) {
          const commands = SVGPathParser.parse(pathData);
          const scaled = commands.map(cmd => {
            const newArgs = [...cmd.args];
            const type = cmd.type.toUpperCase();
            const isRelative = cmd.type !== cmd.type.toUpperCase();
            
            switch (type) {
              case 'M':
              case 'L':
              case 'T':
                if (isRelative) {
                  newArgs[0] *= scaleX;
                  newArgs[1] *= scaleY;
                } else {
                  newArgs[0] = (newArgs[0] - offsetX) * scaleX;
                  newArgs[1] = (newArgs[1] - offsetY) * scaleY;
                }
                break;
              case 'H':
                if (isRelative) {
                  newArgs[0] *= scaleX;
                } else {
                  newArgs[0] = (newArgs[0] - offsetX) * scaleX;
                }
                break;
              case 'V':
                if (isRelative) {
                  newArgs[0] *= scaleY;
                } else {
                  newArgs[0] = (newArgs[0] - offsetY) * scaleY;
                }
                break;
              case 'C':
                for (let i = 0; i < 6; i += 2) {
                  if (isRelative) {
                    newArgs[i] *= scaleX;
                    newArgs[i + 1] *= scaleY;
                  } else {
                    newArgs[i] = (newArgs[i] - offsetX) * scaleX;
                    newArgs[i + 1] = (newArgs[i + 1] - offsetY) * scaleY;
                  }
                }
                break;
              case 'S':
              case 'Q':
                for (let i = 0; i < 4; i += 2) {
                  if (isRelative) {
                    newArgs[i] *= scaleX;
                    newArgs[i + 1] *= scaleY;
                  } else {
                    newArgs[i] = (newArgs[i] - offsetX) * scaleX;
                    newArgs[i + 1] = (newArgs[i + 1] - offsetY) * scaleY;
                  }
                }
                break;
              case 'A':
                newArgs[0] *= scaleX;
                newArgs[1] *= scaleY;
                if (isRelative) {
                  newArgs[5] *= scaleX;
                  newArgs[6] *= scaleY;
                } else {
                  newArgs[5] = (newArgs[5] - offsetX) * scaleX;
                  newArgs[6] = (newArgs[6] - offsetY) * scaleY;
                }
                break;
            }
            
            return { type: cmd.type, args: newArgs };
          });
          
          return SVGPathParser.toString(scaled);
        }

        circleToPath(cx, cy, r) {
          return `M${cx - r},${cy}` +
                 `A${r},${r} 0 0 1 ${cx},${cy - r}` +
                 `A${r},${r} 0 0 1 ${cx + r},${cy}` +
                 `A${r},${r} 0 0 1 ${cx},${cy + r}` +
                 `A${r},${r} 0 0 1 ${cx - r},${cy}Z`;
        }

        ellipseToPath(cx, cy, rx, ry) {
          return `M${cx - rx},${cy}` +
                 `A${rx},${ry} 0 0 1 ${cx},${cy - ry}` +
                 `A${rx},${ry} 0 0 1 ${cx + rx},${cy}` +
                 `A${rx},${ry} 0 0 1 ${cx},${cy + ry}` +
                 `A${rx},${ry} 0 0 1 ${cx - rx},${cy}Z`;
        }

        rectToPath(x, y, w, h, rx = 0, ry = 0) {
          if (rx === 0 && ry === 0) {
            return `M${x},${y}L${x + w},${y}L${x + w},${y + h}L${x},${y + h}Z`;
          }
          rx = Math.min(rx, w / 2);
          ry = Math.min(ry, h / 2);
          return `M${x + rx},${y}` +
                 `L${x + w - rx},${y}` +
                 `A${rx},${ry} 0 0 1 ${x + w},${y + ry}` +
                 `L${x + w},${y + h - ry}` +
                 `A${rx},${ry} 0 0 1 ${x + w - rx},${y + h}` +
                 `L${x + rx},${y + h}` +
                 `A${rx},${ry} 0 0 1 ${x},${y + h - ry}` +
                 `L${x},${y + ry}` +
                 `A${rx},${ry} 0 0 1 ${x + rx},${y}Z`;
        }

        polygonToPath(points, scaleX, scaleY, offsetX = 0, offsetY = 0) {
          const nums = points.trim().split(/[\s,]+/).map(Number);
          let d = '';
          for (let i = 0; i < nums.length; i += 2) {
            const x = (nums[i] - offsetX) * scaleX;
            const y = (nums[i + 1] - offsetY) * scaleY;
            d += (i === 0 ? 'M' : 'L') + `${x},${y}`;
          }
          return d + 'Z';
        }

        polylineToPath(points, scaleX, scaleY, offsetX = 0, offsetY = 0) {
          const nums = points.trim().split(/[\s,]+/).map(Number);
          let d = '';
          for (let i = 0; i < nums.length; i += 2) {
            const x = (nums[i] - offsetX) * scaleX;
            const y = (nums[i + 1] - offsetY) * scaleY;
            d += (i === 0 ? 'M' : 'L') + `${x},${y}`;
          }
          return d;
        }

        copyAttributes(from, to, exclude = []) {
          for (const attr of from.attributes) {
            if (!exclude.includes(attr.name)) {
              to.setAttribute(attr.name, attr.value);
            }
          }
        }
      }

      // ========== ENHANCED MESH-BASED CANVAS DRAWING (NO WHITE LINES) ==========
      function drawTexturedQuad(ctx, img, 
        sx0, sy0, sx1, sy1, sx2, sy2, sx3, sy3,  // Source quad corners (TL, TR, BR, BL)
        dx0, dy0, dx1, dy1, dx2, dy2, dx3, dy3,  // Destination quad corners
        subDivisions = 2
      ) {
        // Recursively subdivide for better quality
        if (subDivisions > 0) {
          // Calculate midpoints
          const smx01 = (sx0 + sx1) / 2, smy01 = (sy0 + sy1) / 2;
          const smx12 = (sx1 + sx2) / 2, smy12 = (sy1 + sy2) / 2;
          const smx23 = (sx2 + sx3) / 2, smy23 = (sy2 + sy3) / 2;
          const smx30 = (sx3 + sx0) / 2, smy30 = (sy3 + sy0) / 2;
          const smxC = (sx0 + sx1 + sx2 + sx3) / 4, smyC = (sy0 + sy1 + sy2 + sy3) / 4;
          
          const dmx01 = (dx0 + dx1) / 2, dmy01 = (dy0 + dy1) / 2;
          const dmx12 = (dx1 + dx2) / 2, dmy12 = (dy1 + dy2) / 2;
          const dmx23 = (dx2 + dx3) / 2, dmy23 = (dy2 + dy3) / 2;
          const dmx30 = (dx3 + dx0) / 2, dmy30 = (dy3 + dy0) / 2;
          const dmxC = (dx0 + dx1 + dx2 + dx3) / 4, dmyC = (dy0 + dy1 + dy2 + dy3) / 4;
          
          const nextSub = subDivisions - 1;
          
          // Top-left quadrant
          drawTexturedQuad(ctx, img,
            sx0, sy0, smx01, smy01, smxC, smyC, smx30, smy30,
            dx0, dy0, dmx01, dmy01, dmxC, dmyC, dmx30, dmy30, nextSub);
          // Top-right quadrant
          drawTexturedQuad(ctx, img,
            smx01, smy01, sx1, sy1, smx12, smy12, smxC, smyC,
            dmx01, dmy01, dx1, dy1, dmx12, dmy12, dmxC, dmyC, nextSub);
          // Bottom-right quadrant
          drawTexturedQuad(ctx, img,
            smxC, smyC, smx12, smy12, sx2, sy2, smx23, smy23,
            dmxC, dmyC, dmx12, dmy12, dx2, dy2, dmx23, dmy23, nextSub);
          // Bottom-left quadrant
          drawTexturedQuad(ctx, img,
            smx30, smy30, smxC, smyC, smx23, smy23, sx3, sy3,
            dmx30, dmy30, dmxC, dmyC, dmx23, dmy23, dx3, dy3, nextSub);
          return;
        }
        
        // Draw two triangles with slight overlap to prevent seams
        const overlap = 0.5;
        
        // Triangle 1: TL, TR, BL
        drawTexturedTriangleSeamless(ctx, img,
          sx0, sy0, sx1, sy1, sx3, sy3,
          dx0, dy0, dx1, dy1, dx3, dy3, overlap);
        
        // Triangle 2: TR, BR, BL
        drawTexturedTriangleSeamless(ctx, img,
          sx1, sy1, sx2, sy2, sx3, sy3,
          dx1, dy1, dx2, dy2, dx3, dy3, overlap);
      }

      function drawTexturedTriangleSeamless(ctx, img, 
        sx0, sy0, sx1, sy1, sx2, sy2,
        dx0, dy0, dx1, dy1, dx2, dy2,
        overlap = 0.5
      ) {
        ctx.save();
        
        // Expand the clipping region slightly to overlap with neighbors
        const cx = (dx0 + dx1 + dx2) / 3;
        const cy = (dy0 + dy1 + dy2) / 3;
        
        const expandPoint = (x, y) => {
          const vx = x - cx;
          const vy = y - cy;
          const len = Math.sqrt(vx * vx + vy * vy);
          if (len > 0) {
            return {
              x: x + (vx / len) * overlap,
              y: y + (vy / len) * overlap
            };
          }
          return { x, y };
        };
        
        const p0 = expandPoint(dx0, dy0);
        const p1 = expandPoint(dx1, dy1);
        const p2 = expandPoint(dx2, dy2);
        
        ctx.beginPath();
        ctx.moveTo(p0.x, p0.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.closePath();
        ctx.clip();

        const denom = (sx0 * (sy1 - sy2) + sx1 * (sy2 - sy0) + sx2 * (sy0 - sy1));
        
        if (Math.abs(denom) < 0.0001) {
          ctx.restore();
          return;
        }

        const a = (dx0 * (sy1 - sy2) + dx1 * (sy2 - sy0) + dx2 * (sy0 - sy1)) / denom;
        const b = (dx0 * (sx2 - sx1) + dx1 * (sx0 - sx2) + dx2 * (sx1 - sx0)) / denom;
        const c = (dx0 * (sx1 * sy2 - sx2 * sy1) + dx1 * (sx2 * sy0 - sx0 * sy2) + dx2 * (sx0 * sy1 - sx1 * sy0)) / denom;
        const d = (dy0 * (sy1 - sy2) + dy1 * (sy2 - sy0) + dy2 * (sy0 - sy1)) / denom;
        const e = (dy0 * (sx2 - sx1) + dy1 * (sx0 - sx2) + dy2 * (sx1 - sx0)) / denom;
        const f = (dy0 * (sx1 * sy2 - sx2 * sy1) + dy1 * (sx2 * sy0 - sx0 * sy2) + dy2 * (sx0 * sy1 - sx1 * sy0)) / denom;

        ctx.transform(a, d, b, e, c, f);
        
        // Draw with margin to cover seams
        const margin = 1;
        const minX = Math.max(0, Math.min(sx0, sx1, sx2) - margin);
        const minY = Math.max(0, Math.min(sy0, sy1, sy2) - margin);
        const maxX = Math.min(img.width, Math.max(sx0, sx1, sx2) + margin);
        const maxY = Math.min(img.height, Math.max(sy0, sy1, sy2) + margin);
        
        ctx.drawImage(img, 
          minX, minY, maxX - minX, maxY - minY,
          minX, minY, maxX - minX, maxY - minY
        );
        
        ctx.restore();
      }

      function drawWarpWithMesh(localCtx, img, shape, offsetX, offsetY, finalScale, isExport) {
        // Use higher grid resolution for exports to ensure smooth curves
        const gridCols = isExport ? 120 : 50;
        const gridRows = isExport ? 50 : 20;
        const subDivisions = isExport ? 2 : 1;
        
        const warper = new MeshWarper(shape.topPath, shape.bottomPath, img.width, img.height, {
          gridCols: gridCols,
          gridRows: gridRows,
          topIsReversed: shape.topIsReversed,
          bottomIsReversed: shape.bottomIsReversed
        });

        const mesh = warper.getMeshPoints();
        const cellWidth = img.width / gridCols;
        const cellHeight = img.height / gridRows;

        // Draw each cell as a textured quad
        for (let row = 0; row < gridRows; row++) {
          for (let col = 0; col < gridCols; col++) {
            const p00 = mesh[row][col];         // Top-left
            const p01 = mesh[row][col + 1];     // Top-right
            const p10 = mesh[row + 1][col];     // Bottom-left
            const p11 = mesh[row + 1][col + 1]; // Bottom-right

            // Source rectangle from image
            const srcX = col * cellWidth;
            const srcY = row * cellHeight;

            // Transform mesh points to canvas coordinates
            const t00 = { x: p00.x * finalScale + offsetX, y: p00.y * finalScale + offsetY };
            const t01 = { x: p01.x * finalScale + offsetX, y: p01.y * finalScale + offsetY };
            const t10 = { x: p10.x * finalScale + offsetX, y: p10.y * finalScale + offsetY };
            const t11 = { x: p11.x * finalScale + offsetX, y: p11.y * finalScale + offsetY };

            // Draw quad with subdivisions to prevent seams
            drawTexturedQuad(localCtx, img,
              // Source corners: TL, TR, BR, BL
              srcX, srcY,
              srcX + cellWidth, srcY,
              srcX + cellWidth, srcY + cellHeight,
              srcX, srcY + cellHeight,
              // Destination corners: TL, TR, BR, BL
              t00.x, t00.y,
              t01.x, t01.y,
              t11.x, t11.y,
              t10.x, t10.y,
              subDivisions
            );
          }
        }
      }

      // ========== STATE ==========
      let currentImage = null;
      let currentImageDataUrl = null;
      let textureImageDataUrl = null;
      let uploadedSVGContent = null;
      let uploadedSVGDimensions = null;
      let currentView = "bottom";
      let currentShapeType = "round";
      let currentShape = "250ml_round";
      const EXPORT_SCALE = 6;
      let isExporting = false;

      // Zoom state
      let zoomLevel = 1;
      const MIN_ZOOM = 0.25;
      const MAX_ZOOM = 5;
      const ZOOM_STEP = 0.25;

      // Pan state
      let panX = 0;
      let panY = 0;
      let isPanning = false;
      let isSpacePressed = false;
      let lastMouseX = 0;
      let lastMouseY = 0;

      let isViewer3DMinimized = false;
      let isViewer3DExpanded = false;
      let isModelLoaded = false;

      // DOM Elements
      const canvas = document.getElementById("warpCanvas");
      const ctx = canvas.getContext("2d");
      const uploadText = document.getElementById("uploadText");
      const svgBadge = document.getElementById("svgBadge");
      const fileInput = document.getElementById("imageUpload");
      const exportPngBtn = document.getElementById("exportPngBtn");
      const exportVectorSvgBtn = document.getElementById("exportVectorSvgBtn");
      const exportPdfBtn = document.getElementById("exportPdfBtn");
      const shapeTypeSelect = document.getElementById("shapeTypeSelect");
      const shapeSelect = document.getElementById("shapeSelect");
      const viewSelector = document.getElementById("viewSelector");
      
      // Loading elements
      const loadingOverlay = document.getElementById("loadingOverlay");
      const loadingText = document.getElementById("loadingText");
      const loadingSubtext = document.getElementById("loadingSubtext");
      
      // Error popup elements
      const errorOverlay = document.getElementById("errorOverlay");
      const errorTitle = document.getElementById("errorTitle");
      const errorMessage = document.getElementById("errorMessage");
      const errorCloseBtn = document.getElementById("errorCloseBtn");

      // Zoom elements
      const zoomInBtn = document.getElementById("zoomInBtn");
      const zoomOutBtn = document.getElementById("zoomOutBtn");
      const zoomDisplay = document.getElementById("zoomDisplay");
      
      // Pan elements
      const panIndicator = document.getElementById("panIndicator");
      const panIndicatorText = document.getElementById("panIndicatorText");
      const resetPanBtn = document.getElementById("resetPanBtn");

      // 3D Viewer elements
      const viewer3DContainer = document.getElementById("viewer3DContainer");
      const modelViewer = document.getElementById("modelViewer");
      const viewer3DLoading = document.getElementById("viewer3DLoading");
      const viewer3DStatus = document.getElementById("viewer3DStatus");
      const viewer3DToggle = document.getElementById("viewer3DToggle");
      const viewer3DExpand = document.getElementById("viewer3DExpand");

      // ===== END OF PART 3 =====

            // ========== LOADING & ERROR FUNCTIONS ==========
      
      function showLoading(message = "Processing...", subtext = "Please wait") {
        loadingText.textContent = message;
        loadingSubtext.textContent = subtext;
        loadingOverlay.classList.add("show");
        exportPngBtn.disabled = true;
        exportVectorSvgBtn.disabled = true;
        exportPdfBtn.disabled = true;
      }

      function updateLoading(message, subtext = "") {
        loadingText.textContent = message;
        if (subtext) loadingSubtext.textContent = subtext;
      }

      function hideLoading() {
        loadingOverlay.classList.remove("show");
        exportPngBtn.disabled = false;
        exportVectorSvgBtn.disabled = false;
        exportPdfBtn.disabled = false;
        isExporting = false;
      }

      function showError(title, message) {
        errorTitle.textContent = title;
        errorMessage.textContent = message;
        errorOverlay.classList.add("show");
      }

      function hideError() {
        errorOverlay.classList.remove("show");
      }

      errorCloseBtn.addEventListener("click", hideError);

      // ========== DOWNLOAD HELPER ==========
      
      function triggerDownload(blob, filename) {
        return new Promise((resolve, reject) => {
          try {
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            link.style.display = "none";
            document.body.appendChild(link);
            
            setTimeout(() => {
              link.click();
              setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                resolve();
              }, 500);
            }, 100);
          } catch (error) {
            reject(error);
          }
        });
      }

      // ========== ZOOM FUNCTIONS ==========
      
      function canPan() {
        return zoomLevel > 1;
      }

      function updateZoomDisplay() {
        const percentage = Math.round(zoomLevel * 100);
        zoomDisplay.textContent = `${percentage}%`;
        
        zoomInBtn.disabled = zoomLevel >= MAX_ZOOM;
        zoomOutBtn.disabled = zoomLevel <= MIN_ZOOM;
        
        if (canPan()) {
          panIndicator.classList.add("visible");
        } else {
          panIndicator.classList.remove("visible");
          panIndicator.classList.remove("active");
        }
        
        if (panX !== 0 || panY !== 0) {
          resetPanBtn.classList.add("visible");
        } else {
          resetPanBtn.classList.remove("visible");
        }
        
        updateCanvasCursor();
      }

      function updateCanvasCursor() {
        canvas.classList.remove("can-pan", "space-held", "panning");
        
        if (isPanning) {
          canvas.classList.add("panning");
        } else if (isSpacePressed && canPan()) {
          canvas.classList.add("space-held");
        } else if (canPan()) {
          canvas.classList.add("can-pan");
        }
      }

      function zoomIn() {
        if (zoomLevel < MAX_ZOOM) {
          zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
          if (zoomLevel <= 1) { panX = 0; panY = 0; }
          mainDraw();
          updateZoomDisplay();
        }
      }

      function zoomOut() {
        if (zoomLevel > MIN_ZOOM) {
          zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
          if (zoomLevel <= 1) { panX = 0; panY = 0; }
          mainDraw();
          updateZoomDisplay();
        }
      }

      function resetZoom() {
        zoomLevel = 1;
        panX = 0;
        panY = 0;
        mainDraw();
        updateZoomDisplay();
      }

      function resetPan() {
        panX = 0;
        panY = 0;
        mainDraw();
        updateZoomDisplay();
      }

      function handleWheelZoom(event) {
        if (event.ctrlKey || event.metaKey) {
          event.preventDefault();
          if (event.deltaY < 0) zoomIn();
          else zoomOut();
        }
      }

      // ========== PAN FUNCTIONS ==========
      
      function startPan(event) {
        if (!canPan()) return;
        if (!isSpacePressed && event.button !== 1) return;
        
        isPanning = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        
        updateCanvasCursor();
        panIndicator.classList.add("active");
        panIndicatorText.textContent = "Panning...";
        
        event.preventDefault();
      }

      function doPan(event) {
        if (!isPanning) return;
        
        const deltaX = event.clientX - lastMouseX;
        const deltaY = event.clientY - lastMouseY;
        
        panX += deltaX;
        panY += deltaY;
        
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        
        mainDraw();
        updateZoomDisplay();
      }

      function endPan() {
        if (isPanning) {
          isPanning = false;
          updateCanvasCursor();
          panIndicator.classList.remove("active");
          panIndicatorText.textContent = "Hold Space + Drag";
        }
      }

      function handleSpaceDown(event) {
        if (event.code === "Space" && !event.repeat && canPan()) {
          const activeElement = document.activeElement;
          const isInputFocused = activeElement && (
            activeElement.tagName === "INPUT" || 
            activeElement.tagName === "TEXTAREA" || 
            activeElement.tagName === "SELECT"
          );
          
          if (!isInputFocused) {
            event.preventDefault();
            isSpacePressed = true;
            updateCanvasCursor();
            panIndicator.classList.add("active");
            panIndicatorText.textContent = "Click & Drag to Pan";
          }
        }
      }

      function handleSpaceUp(event) {
        if (event.code === "Space") {
          isSpacePressed = false;
          if (!isPanning) {
            panIndicator.classList.remove("active");
            panIndicatorText.textContent = "Hold Space + Drag";
          }
          updateCanvasCursor();
          endPan();
        }
      }

      // Touch support for panning
      let touchStartX = 0;
      let touchStartY = 0;
      let isTouchPanning = false;

      function handleTouchStart(event) {
        if (!canPan()) return;
        if (event.touches.length === 2) {
          isTouchPanning = true;
          const touch = event.touches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          lastMouseX = touchStartX;
          lastMouseY = touchStartY;
          isPanning = true;
          updateCanvasCursor();
          event.preventDefault();
        }
      }

      function handleTouchMove(event) {
        if (!isTouchPanning || !isPanning) return;
        if (event.touches.length === 2) {
          const touch = event.touches[0];
          const deltaX = touch.clientX - lastMouseX;
          const deltaY = touch.clientY - lastMouseY;
          
          panX += deltaX;
          panY += deltaY;
          
          lastMouseX = touch.clientX;
          lastMouseY = touch.clientY;
          
          mainDraw();
          updateZoomDisplay();
          event.preventDefault();
        }
      }

      function handleTouchEnd() {
        isTouchPanning = false;
        endPan();
      }

      // ========== SHAPE DEFINITIONS ==========
      const shapeTypes = {
        round: "Round",
        round_square: "Round Square",
        rectangle: "Rectangle",
        sweet_box: "Sweet Box",
        sweet_box_te: "Sweet Box TE",
      };

      const COMMON_LABEL_MATERIALS = [
        "Bottom", "Label", "Wrap", "Decal", "Logo", "Sticker",
        "label", "bottom", "wrap", "decal", "logo", "sticker",
        "Material", "Material.001", "Material.002", "Material_0"
      ];

      const allBottleShapes = {
        "250ml_round": {
          type: "round",
          view: "bottom",
          name: "250ml Round",
          width: 837,
          height: 244,
          uploadDimensions: { width: 2908, height: 448 },
          path: "M1.37,162.42L73.32,242.27C283.84,56.41,576.84,75.5,764.01,242.27L835.96,162.42C597.61,-50.29,240.85,-53.15,1.37,162.42Z",
          topPath: "M 835.96,162.42 C 597.61,-50.29 240.85,-53.15 1.37,162.42",
          bottomPath: "M 73.32,242.27 C 283.84,56.41 576.84,75.5 764.01,242.27",
          topIsReversed: true,
          bottomIsReversed: false,
          modelPath: "./assets/models/250ml_round_t.glb",
          targetMaterials: ["Texture"],
        },
        "300ml_round": {
          type: "round",
          view: "bottom",
          name: "300ml Round",
          width: 986.98,
          height: 332.17,
          uploadDimensions: { width: 2906, height: 448 },
          path: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0l-5.32,1.98-45.71-122.15,6.01-2.21c286.86-105.52,601.92-105.52,888.78,0l6.04,2.15-45.75,122.2-5.3-1.98Z",
          topPath: "M49.08,172.19c286.86-105.52,601.92-105.52,888.78,0",
          bottomPath: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0",
          topIsReversed: false,
          bottomIsReversed: true,
          modelPath: "./assets/models/300ml_round_container.glb",
          targetMaterials: ["Texture"],
        },
         "500ml_round": {
          type: "round",
          view: "bottom",
          name: "500ml Round",
          width: 945.18,
          height: 430.84,
          uploadDimensions: { width: 2890, height: 886 },
          path: "M846.13,387.86c-120.06-43.77-245.71-65.96-373.55-65.96s-252.55,22.02-372.2,65.47l-.61-1.56L24.95,193.11l2.66-.97c143.01-52.15,292.69-78.58,444.97-78.58s301.97,26.44,444.98,78.59l2.65,1.01-74.09,194.71Z",
          topPath:
            "M27.61,192.14c143.01-52.15,292.69-78.58,444.97-78.58s301.97,26.44,444.98,78.59",
          bottomPath:
            "M846.13,387.86c-120.06-43.77-245.71-65.96-373.55-65.96s-252.55,22.02-372.2,65.47",
          topIsReversed: false,
          bottomIsReversed: true,
          modelPath: "./assets/models/500ml_round_container_t.glb",
          targetMaterials: ["Texture"],
        },
        "750ml_round": {
          type: "round",
          view: "bottom",
          name: "750ml Round",
          width: 1187.25,
          height: 279.7,
          uploadDimensions: { width: 4360, height: 701 },
          path: "M3.26,122.79c376.81-163.05,803.93-163.05,1180.74,0l2.6,1.21-1.14,2.55-67.28,150.03-1.21,2.45-2.49-1.01c-332.55-143.26-709.13-143.26-1041.68,0l-2.54,1.04-1.17-2.48L1.8,126.55l-1.14-2.63,2.6-1.13Z",
          topPath: "M3.26,122.79c376.81-163.05,803.93-163.05,1180.74,0",
          bottomPath: "M1114.48,278.02c-332.55-143.26-709.13-143.26-1041.68,0",
          topIsReversed: false,
          bottomIsReversed: true,
          modelPath: "./assets/models/750ml_round_container_t.glb",
          targetMaterials: [" Texture"],
        },
        "1000ml_round": {
          type: "round",
          view: "bottom",
          name: "1000ml Round",
          width: 1186.89,
          height: 332.33,
          uploadDimensions: { width: 4153, height: 929 },
          path: "M97.62,331.03L114.97,323.22L137.59,313.59L160.4,304.43L183.4,295.74L206.58,287.53L229.93,279.8L253.44,272.55L277.1,265.79L300.9,259.51L324.82,253.73L348.86,248.44L373.02,243.64L397.25,239.35L421.59,235.56L446,232.27L470.46,229.48L494.99,227.2L519.56,225.42L544.16,224.15L568.78,223.39L593.42,223.14L618.06,223.39L642.68,224.15L667.28,225.42L691.84,227.2L716.36,229.48L740.84,232.27L765.25,235.56L789.58,239.35L813.82,243.64L837.98,248.44L862.02,253.73L885.93,259.51L909.74,265.79L933.4,272.55L956.9,279.8L980.26,287.53L1003.43,295.74L1026.43,304.43L1049.25,313.59L1071.87,323.22L1089.23,331.04L1091.77,332.1L1092.96,329.66L1185.4,132.99L1186.65,130.47L1184,129.2L1161.31,118.99L1134.45,107.56L1107.36,96.68L1080.05,86.36L1052.53,76.61L1024.8,67.43L996.9,58.83L968.81,50.8L940.56,43.35L912.17,36.48L883.63,30.21L854.97,24.52L826.19,19.42L797.32,14.92L768.35,11.01L739.31,7.71L710.21,5L681.06,2.89L651.87,1.39L622.65,.48L593.42,.18L564.19,.48L534.97,1.39L505.78,2.89L476.63,5L447.52,7.71L418.48,11.01L389.52,14.92L360.64,19.42L331.87,24.52L303.21,30.21L274.67,36.48L246.27,43.35L218.03,50.8L189.94,58.83L162.03,67.43L134.31,76.61L106.79,86.36L79.47,96.68L52.38,107.56L25.53,118.99L2.83,129.21L.24,130.46L1.42,132.99L93.89,329.65L95.16,332.1L97.62,331.03Z",
          topPath:
            "M2.83,129.21L25.53,118.99L52.38,107.56L79.47,96.68L106.79,86.36L134.31,76.61L162.03,67.43L189.94,58.83L218.03,50.8L246.27,43.35L274.67,36.48L303.21,30.21L331.87,24.52L360.64,19.42L389.52,14.92L418.48,11.01L447.52,7.71L476.63,5L505.78,2.89L534.97,1.39L564.19,.48L593.42,.18L622.65,.48L651.87,1.39L681.06,2.89L710.21,5L739.31,7.71L768.35,11.01L797.32,14.92L826.19,19.42L854.97,24.52L883.63,30.21L912.17,36.48L940.56,43.35L968.81,50.8L996.9,58.83L1024.8,67.43L1052.53,76.61L1080.05,86.36L1107.36,96.68L1134.45,107.56L1161.31,118.99L1184,129.2",
          bottomPath:
            "M97.62,331.03L114.97,323.22L137.59,313.59L160.4,304.43L183.4,295.74L206.58,287.53L229.93,279.8L253.44,272.55L277.1,265.79L300.9,259.51L324.82,253.73L348.86,248.44L373.02,243.64L397.25,239.35L421.59,235.56L446,232.27L470.46,229.48L494.99,227.2L519.56,225.42L544.16,224.15L568.78,223.39L593.42,223.14L618.06,223.39L642.68,224.15L667.28,225.42L691.84,227.2L716.36,229.48L740.84,232.27L765.25,235.56L789.58,239.35L813.82,243.64L837.98,248.44L862.02,253.73L885.93,259.51L909.74,265.79L933.4,272.55L956.9,279.8L980.26,287.53L1003.43,295.74L1026.43,304.43L1049.25,313.59L1071.87,323.22L1089.23,331.04",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/1000mlcontainer_t.glb",
          targetMaterials: ["Texture"],
        },
        "450ml_round_square": {
          type: "round_square",
          view: "bottom",
          name: "450ml Round Square",
          width: 879.22,
          height: 276.16,
          uploadDimensions: { width: 2923, height: 748 },
          path: "M93.16,274.8l9.48-5.52c16.09-9.47,32.49-18.51,49.08-27.07l8.02-3.94c9.34-4.49,18.91-8.56,28.62-12.17,8.99-3.3,18.11-6.37,27.27-9.18,15.76-4.79,31.65-9.33,47.56-13.57,18.8-5.19,37.79-9.92,56.83-14.14l9.07-1.84,8.27-1.5c10.82-1.83,21.76-3.15,32.71-3.94,9.81-.7,19.67-1.17,29.5-1.4,21.39-.46,42.86-.55,64.25-.29,12.27.09,24.57.47,36.82,1.13,13.8.7,27.58,2.2,41.2,4.49,9.2,1.6,18.39,3.47,27.48,5.58,15.63,3.68,31.23,7.65,46.71,11.9,15.9,4.24,31.78,8.78,47.53,13.56,9.16,2.81,18.27,5.88,27.27,9.19,9.71,3.61,19.29,7.68,28.62,12.17,9.02,4.37,17.96,8.98,26.74,13.81,13.78,7.6,26.32,14.75,39.8,22.73l1.29.69.73-1.14,89.79-152.32.72-1.21-1.24-.73-13.45-7.78-11.35-6.29-11.74-6.21-12.33-6.23c-19.27-9.43-38.9-18.29-58.72-26.51l-16-6.53-15.31-5.99-14.52-5.41-13.83-4.89c-23.21-8.03-46.9-14.84-70.84-20.34-19.14-4.36-38.5-8.07-57.9-11.09-11.43-1.81-22.92-3.44-34.4-4.91l-19.63-2.35c-18.16-2.05-36.45-3.52-54.71-4.39-9.72-.44-19.47-.67-29.2-.68h-3.78s-3.78,0-3.78,0l-6.4.04-12.28.25-10.51.39-15.42.86c-13.11.89-26.23,2.07-39.29,3.53l-19.63,2.35c-24.07,3.03-48.1,6.91-71.9,11.61-30.91,6.14-61.46,14.42-91.24,24.74l-13.82,4.89-14.52,5.41-15.31,5.99-16,6.53c-19.82,8.21-39.45,17.07-58.72,26.51l-12.33,6.22-11.74,6.21-11.35,6.29-13.43,7.79-1.22.71.71,1.24,89.83,152.25.7,1.19,1.24-.69Z",
          topPath:
            "M1.22,123.55l13.43-7.79l11.35-6.29l11.74-6.21l12.33-6.22c19.27-9.44,38.9-18.3,58.72-26.51l16-6.53l15.31-5.99l14.52-5.41l13.82-4.89c30.78-10.32,60.33-18.6,91.24-24.74c24.07-4.7,47.83-8.58,71.9-11.61l19.63-2.35c13.06-1.46,26.18-2.64,39.29-3.53l15.42-.86l10.51-.39l12.28-.25l6.4-.04h3.78s3.78,0,3.78,0c9.73.01,19.48.24,29.2.68c18.26.87,36.55,2.34,54.71,4.39l19.63,2.35c11.48,1.47,22.97,3.1,34.4,4.91c19.4,3.02,38.76,6.73,57.9,11.09c23.94,5.5,47.63,12.31,70.84,20.34l13.83,4.89l14.52,5.41l15.31,5.99l16,6.53c19.82,8.22,39.45,17.08,58.72,26.51l12.33,6.23l11.74,6.21l11.35,6.29l13.45,7.78",
          bottomPath:
            "M93.16,274.8l9.48-5.52c16.09-9.47,32.49-18.51,49.08-27.07l8.02-3.94c9.34-4.49,18.91-8.56,28.62-12.17,8.99-3.3,18.11-6.37,27.27-9.18,15.76-4.79,31.65-9.33,47.56-13.57,18.8-5.19,37.79-9.92,56.83-14.14l9.07-1.84,8.27-1.5c10.82-1.83,21.76-3.15,32.71-3.94,9.81-.7,19.67-1.17,29.5-1.4,21.39-.46,42.86-.55,64.25-.29,12.27.09,24.57.47,36.82,1.13,13.8.7,27.58,2.2,41.2,4.49,9.2,1.6,18.39,3.47,27.48,5.58,15.63,3.68,31.23,7.65,46.71,11.9,15.9,4.24,31.78,8.78,47.53,13.56,9.16,2.81,18.27,5.88,27.27,9.19,9.71,3.61,19.29,7.68,28.62,12.17,9.02,4.37,17.96,8.98,26.74,13.81,13.78,7.6,26.32,14.75,39.8,22.73",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/500gms&450ml container_t.glb",
          targetMaterials: [" Texture"],
        },
        "500ml_round_square": {
          type: "round_square",
          view: "bottom",
          name: "500ml Round Square",
          width: 888.9,
          height: 297.78,
          uploadDimensions: { width: 2770, height: 886 },
          path: "M100.22,295.91c7.22-3.68,14.49-7.33,21.74-10.94,12.31-6.17,24.8-12.07,37.38-17.66l8.32-3.56c6.19-2.59,12.48-5.01,18.81-7.25,6.79-2.39,13.66-4.62,20.55-6.67,11.2-3.29,22.5-6.38,33.82-9.23,17.32-4.36,34.73-8.55,52.14-12.54,13.13-3.03,26.38-5.76,39.64-8.17,10.65-1.91,21.41-3.37,32.18-4.37,11.78-1.02,23.62-1.67,35.44-1.95,14.74-.34,29.53-.51,44.27-.49,14.74-.01,29.53.15,44.27.49,9.56.23,19.14.7,28.68,1.39,8.72.64,17.44,1.59,26.09,2.85,7.55,1.11,15.1,2.41,22.59,3.88,14.87,2.96,29.72,6.21,44.47,9.74,16.79,3.93,33.58,8.09,50.26,12.45l11.22,3.06,9.92,2.87,8.8,2.71c10.34,3.28,20.56,7.03,30.56,11.21,9.38,3.95,18.7,8.14,27.88,12.53,13.21,6.34,26.37,12.87,39.42,19.55l2.4,1.28,1.41-2.51,94.51-184.07,1.26-2.46-2.5-1.36-12.45-6.29-12.14-5.86-12.54-5.77-13.15-5.78-14.04-5.89-15.25-6.12-16.64-6.41c-16.62-6.28-33.41-12.25-50.26-17.87-14.15-4.7-28.45-9.06-42.81-13.06-17.59-4.88-35.41-9.14-53.32-12.73-26.55-5.22-53.37-9.42-80.24-12.58-18.01-2.19-36.11-4-54.19-5.45l-17.34-1.16-14.62-.7c-10.74-.42-21.52-.6-32.26-.54-10.72-.06-21.47.13-32.18.54l-14.58.7-17.36,1.16-4.33.34-14.71,1.29-18.35,1.87c-25.34,2.71-50.66,6.23-75.78,10.52-29.81,5.17-59.39,12.09-88.41,20.67l-14.1,4.3c-10.3,3.24-20.58,6.65-30.78,10.2l-16.94,6.02c-16.55,5.99-33.03,12.33-49.33,18.98l-14.02,5.88-13.15,5.78-12.54,5.77-12.14,5.86-12.59,6.36-2.54,1.32,1.3,2.52c31.81,61.1,63.35,122.59,94.42,184.07l1.32,2.45,2.5-1.2Z",
          topPath:
            "M 881.89,111.84 l-12.45-6.29 -12.14-5.86 -12.54-5.77 -13.15-5.78 -14.04-5.89 -15.25-6.12 -16.64-6.41 c-16.62-6.28 -33.41-12.25 -50.26-17.87 -14.15-4.7 -28.45-9.06 -42.81-13.06 -17.59-4.88 -35.41-9.14 -53.32-12.73 -26.55-5.22 -53.37-9.42 -80.24-12.58 -18.01-2.19 -36.11-4 -54.19-5.45 l-17.34-1.16 -14.62-0.7 c-10.74-.42 -21.52-.6 -32.26-.54 -10.72-.06 -21.47.13 -32.18.54 l-14.58.7 -17.36,1.16 -4.33.34 -14.71,1.29 -18.35,1.87 c-25.34,2.71 -50.66,6.23 -75.78,10.52 -29.81,5.17 -59.39,12.09 -88.41,20.67 l-14.1,4.3 c-10.3,3.24 -20.58,6.65 -30.78,10.2 l-16.94,6.02 c-16.55,5.99 -33.03,12.33 -49.33,18.98 l-14.02,5.88 -13.15,5.78 -12.54,5.77 -12.14,5.86 -12.59,6.36",
          bottomPath:
            "M100.22,295.91c7.22-3.68,14.49-7.33,21.74-10.94,12.31-6.17,24.8-12.07,37.38-17.66l8.32-3.56c6.19-2.59,12.48-5.01,18.81-7.25,6.79-2.39,13.66-4.62,20.55-6.67,11.2-3.29,22.5-6.38,33.82-9.23,17.32-4.36,34.73-8.55,52.14-12.54,13.13-3.03,26.38-5.76,39.64-8.17,10.65-1.91,21.41-3.37,32.18-4.37,11.78-1.02,23.62-1.67,35.44-1.95,14.74-.34,29.53-.51,44.27-.49,14.74-.01,29.53.15,44.27.49,9.56.23,19.14.7,28.68,1.39,8.72.64,17.44,1.59,26.09,2.85,7.55,1.11,15.1,2.41,22.59,3.88,14.87,2.96,29.72,6.21,44.47,9.74,16.79,3.93,33.58,8.09,50.26,12.45l11.22,3.06,9.92,2.87,8.8,2.71c10.34,3.28,20.56,7.03,30.56,11.21,9.38,3.95,18.7,8.14,27.88,12.53,13.21,6.34,26.37,12.87,39.42,19.55",
          topIsReversed: true,
          bottomIsReversed: false,
          modelPath: "./assets/models/500ml_container_t.glb",
          targetMaterials: [" Texture"],
        },
        "750ml_rectangle": {
          type: "rectangle",
          view: "bottom",
          name: "500ml / 750ml Rectangle",
          width: 462.62,
          height: 309.76,
          uploadDimensions: { width: 1926, height: 1289 },
          path: "M.99,47.31 C.99,21.73 21.73,.99 47.31,.99 H 415.31 C 440.89,.99 461.63,21.73 461.63,47.31 V 262.45 C 461.63,288.03 440.89,308.77 415.31,308.77 H 47.31 C 21.73,308.77 .99,288.03 .99,262.45 Z",
          topPath:
            "M.99,47.31 C.99,21.73 21.73,.99 47.31,.99 H 415.31 C 440.89,.99 461.63,21.73 461.63,47.31",
          bottomPath:
            "M.99,262.45 C.99,288.03 21.73,308.77 47.31,308.77 H 415.31 C 440.89,308.77 461.63,288.03 461.63,262.45",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/750ml rectangular_t.glb",
          targetMaterials: [" Texture"],
        },
        "1kg_sweet_box_top": {
          type: "sweet_box",
          view: "top",
          name: "1kg Sweet Box",
          width: 636.39,
          height: 455.59,
          uploadDimensions: { width: 1926, height: 1289 },
          path: "M.5.5 h635.39 v454.59 h-635.39 Z",
          topPath: "M0,0 H636.39",
          bottomPath: "M0,455.59 H636.39",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/1000gms_sweet_t.glb",
          targetMaterials: [" Texture"],
        },
        "250ml_sweet_box_top": {
          type: "sweet_box",
          view: "top",
          name: "250g Sweet Box",
          width: 361,
          height: 273.49,
          uploadDimensions: { width: 1461, height: 1100 },
          path: "M9.29.5h342.4c4.85,0,8.82,3.94,8.82,8.79v254.92c0,4.82-3.97,8.79-8.82,8.79H9.29c-4.85,0-8.79-3.97-8.79-8.79V9.29C.5,4.44,4.44.5,9.29.5Z",
          topPath: "M0,0 H361",
          bottomPath: "M0,273.49 H361",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/250gms_sweet_t.glb",
          targetMaterials: ["TopTexture"],
        },
        "500ml_sweet_box_top": {
          type: "sweet_box",
          view: "top",
          name: "500g Sweet Box",
          width: 495.82,
          height: 351.4,
          uploadDimensions: { width: 2064, height: 1463 },
          path: "M489.44,351.01H6.42c-3.32,0-6.04-2.72-6.04-6.04V6.38C.38,3.1,3.09.38,6.42.38h483.02c3.29,0,6.01,2.72,6.01,6.01v338.6c0,3.32-2.72,6.04-6.01,6.04h0Z",
          topPath: "M0,0 H495.82",
          bottomPath: "M0,351.4 H495.82",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/500gms_sweet_t.glb",
          targetMaterials: ["TopTexture"],
        },
        "250ml_sweet_box_bottom": {
          type: "sweet_box",
          view: "bottom",
          name: "250g Sweet Box",
          width: 1342.58,
          height: 189.54,
          uploadDimensions: { width: 5533, height: 404 },
          path: "M662.63.55l-278.9,13.66c-.26,0-.48.03-.74.09L8.88,81.16l-8.31,1.59,1.42,8.27,15.85,89.69,1.64,8.25,8.26-1.36,367.77-65.74c1.19-.23,2.41-.37,3.6-.43l259.43-12.7c1.3-.06,2.64-.03,3.94.09h.11l365.58,24.6c1.84.14,3.69.45,5.44.93.14.03.26.06.37.09l266.12,52.89,7.12,1.34,2.57-6.92,29.28-86.34,2.87-8.88-9.25-2.2-289.39-57.68c-2.38-.62-4.82-1.02-7.28-1.19L668.08.66c-1.16-.11-2.33-.16-3.49-.16-.65,0-1.3.02-1.95.05",
          topPath:
            "M8.88,81.16 L382.99,14.3 c.26-.06 .48-.09 .74-.09 L662.63,0.55 c.65-.03 1.3-.05 1.95-.05 c1.16,0 2.33.05 3.49.16 L1042.28,24.34 c2.46.17 4.9.57 7.28,1.19 l289.39,57.68",
          bottomPath:
            "M27.74, 187.6 l367.77-65.74 c1.19-.23,2.41-.37,3.6-.43 l259.43-12.7 c1.3-.06,2.64-.03,3.94.09 h.11 l365.58,24.6 c1.84.14,3.69.45,5.44.93 .14.03 .26.06 .37.09 l266.12,52.89",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/250gms_sweet_t.glb",
          targetMaterials: ["Bottom1"],
        },
        "500ml_sweet_box_bottom": {
          type: "sweet_box",
          view: "bottom",
          name: "500g Sweet Box",
          width: 1798.7,
          height: 215.31,
          uploadDimensions: { width: 7446, height: 403 },
          path: "M1758.59,213.74l-356.09-70.07c-3.32-.65-6.69-1.11-10.09-1.33l-505.42-33.33c-2.98-.2-5.98-.23-8.96-.09l-341.4,15.99c-3.4.14-6.8.54-10.15,1.13L31.24,213.68l-4.25.74c-3.77.65-7.4-1.84-8.14-5.64L.63,115.74c-.37-1.87.06-3.83,1.13-5.41,1.1-1.59,2.78-2.64,4.68-2.92l4.14-.68L503.67,19.45c3.83-.68,7.68-1.1,11.57-1.3L890,.6c3.4-.17,6.83-.11,10.23.11l495.47,32.68c3.85.25,7.71.76,11.54,1.5l381.26,75.03,4.05.85c1.96.4,3.63,1.59,4.65,3.29,1.02,1.73,1.28,3.77.71,5.67l-26.79,90c-1.05,3.54-4.68,5.7-8.28,4.9l-4.25-.91Z",
          topPath:
            "M.63,115.74c-.37-1.87.06-3.83,1.13-5.41,1.1-1.59,2.78-2.64,4.68-2.92l4.14-.68L503.67,19.45c3.83-.68,7.68-1.1,11.57-1.3L890,.6c3.4-.17,6.83-.11,10.23.11l495.47,32.68c3.85.25,7.71.76,11.54,1.5l381.26,75.03,4.05.85c1.96.4,3.63,1.59,4.65,3.29,1.02,1.73,1.28,3.77.71,5.67",
          bottomPath:
            "M1758.59,213.74l-356.09-70.07c-3.32-.65-6.69-1.11-10.09-1.33l-505.42-33.33c-2.98-.2-5.98-.23-8.96-.09l-341.4,15.99c-3.4.14-6.8.54-10.15,1.13L31.24,213.68",
          topIsReversed: false,
          bottomIsReversed: true,
          modelPath: "./assets/models/500gms_sweet_t.glb",
          targetMaterials: ["Bottom1"],
        },
        "250ml_sweet_box_te_top": {
          type: "sweet_box_te",
          view: "top",
          name: "250g Sweet Box TE",
          width: 378.23,
          height: 296.16,
          uploadDimensions: { width: 503, height: 394 },
          path: "M 344.73 .5 346.35 .54 347.96 .65 349.57 .85 351.17 1.12 354.31 1.92 357.36 3.01 360.29 4.39 363.07 6.05 365.67 7.98 368.07 10.17 370.24 12.57 372.18 15.16 373.84 17.94 375.23 20.88 376.32 23.93 377.11 27.07 377.38 28.66 377.58 30.27 377.7 31.89 377.73 33.51 377.73 262.66 377.7 264.28 377.58 265.89 377.38 267.5 377.11 269.1 376.32 272.24 375.23 275.29 373.84 278.22 372.18 281 370.24 283.6 368.07 286 365.67 288.17 363.07 290.11 360.29 291.77 357.36 293.15 354.31 294.24 351.17 295.03 349.57 295.31 347.96 295.51 346.35 295.62 344.73 295.66 33.51 295.66 31.89 295.62 30.27 295.51 28.66 295.31 27.07 295.03 23.92 294.24 20.88 293.15 17.94 291.77 15.16 290.11 12.56 288.17 10.17 286 7.99 283.6 6.06 281 4.39 278.22 3.01 275.29 1.92 272.24 1.13 269.1 .85 267.5 .66 265.89 .54 264.28 .5 262.66 .5 33.51 .54 31.89 .66 30.27 .85 28.66 1.13 27.07 1.92 23.93 3.01 20.88 4.39 17.94 6.06 15.16 7.99 12.57 10.17 10.17 12.56 7.98 15.16 6.05 17.94 4.39 20.88 3.01 23.92 1.92 27.07 1.12 28.66 .85 30.27 .65 31.89 .54 33.51 .5 344.73 .5 Z",
          topPath: "M0,0 H378.23",
          bottomPath: "M0,296.16 H378.23",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/texture_250_gms_te_sb.glb",
          targetMaterials: ["TopTexture"],
        },
        "250ml_sweet_box_te_bottom": {
          type: "sweet_box_te",
          view: "bottom",
          name: "250g Sweet Box TE",
          width: 557.78,
          height: 475.73,
          uploadDimensions: { width: 742, height: 633 },
          path: "M437.53,98.37c12.09,0,21.88,9.8,21.88,21.88h97.87v235.23h-97.87c0,12.08-9.79,21.88-21.88,21.88h0v97.87H120.25v-97.86h0c-12.09-.01-21.88-9.81-21.88-21.89H.5V120.25h97.87c0-12.08,9.79-21.88,21.88-21.88h0V.5h317.28v97.86h0Z",
          topPath: "M0,0 H557.78",
          bottomPath: "M0,475.73 H557.78",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/texture_250_gms_te_sb.glb",
          targetMaterials: ["Bottom1"],
        },
        "500ml_sweet_box_te_bottom": {
          type: "sweet_box_te",
          view: "bottom",
          name: "500g Sweet Box TE",
          width: 695.7,
          height: 560.63,
          uploadDimensions: { width: 7446, height: 403 },
          path: "M 122.64 3.76 122.39 .92 572.87 .5 572.62 3.34 563.84 104.14 564.26 104.14 566.94 104.29 569.58 104.7 572.17 105.36 574.68 106.27 577.09 107.42 579.38 108.8 581.52 110.39 583.5 112.18 585.29 114.16 586.88 116.3 588.26 118.59 589.41 121 590.32 123.51 590.98 126.1 591.39 128.74 591.54 131.41 591.54 131.84 692.37 123.05 695.2 122.78 695.2 437.82 692.37 437.58 591.54 428.8 591.54 429.22 591.28 432.82 590.5 436.5 589.18 440.16 587.3 443.69 584.89 446.96 582 449.84 578.74 452.26 575.21 454.14 571.54 455.46 567.86 456.23 564.26 456.5 563.84 456.5 572.62 557.3 572.88 560.13 122.39 559.7 122.64 556.87 131.39 456.5 130.96 456.5 127.37 456.23 123.69 455.46 120.02 454.14 116.49 452.26 113.23 449.84 110.34 446.96 107.93 443.69 106.05 440.16 104.72 436.5 103.95 432.82 103.69 429.22 103.69 428.99 103.69 428.8 3.34 437.54 .5 437.78 .5 122.84 3.34 123.09 103.69 131.84 103.69 131.64 103.69 131.41 103.95 127.82 104.72 124.14 106.05 120.47 107.93 116.94 110.34 113.68 113.23 110.79 116.49 108.38 120.02 106.5 123.69 105.17 127.37 104.4 130.96 104.14 131.39 104.14 122.64 3.76 Z",
          topPath: "M 131.39 104.14 H 563.84",
          bottomPath: "M 131.39 456.5 H 563.84",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/texture_500_gms_te_sb.glb",
          targetMaterials: ["Bottom1"],
        },
        "500ml_sweet_box_te_top": {
          type: "sweet_box_te",
          view: "top",
          name: "500g Sweet Box TE",
          width: 509.61,
          height: 374.16,
          uploadDimensions: { width: 2064, height: 1436 },
          path: "M3.86,28.85C4.36,15.15,15.42,4.2,29.12,3.86,179.56.04,330.06.04,480.5,3.86c13.7.34,24.76,11.29,25.26,24.99,3.82,105.45,3.82,211.01,0,316.46-.5,13.7-11.56,24.65-25.26,25-150.44,3.81-300.94,3.81-451.38,0-13.7-.35-24.76-11.3-25.26-25C.04,239.86.04,134.3,3.86,28.85Z",
          topPath: "M0,0 H509.61",
          bottomPath: "M0,374.16 H509.61",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/texture_500_gms_te_sb.glb",
          targetMaterials: ["TopTexture"],
        },
      };

      const shapeGroups = {};
      const keyToGroupName = {};

      // ========== 3D VIEWER FUNCTIONS ==========

      function showStatus(message) {
        viewer3DStatus.textContent = message;
        viewer3DStatus.classList.remove("hidden");
      }

      function hideStatus() {
        viewer3DStatus.classList.add("hidden");
      }

      function show3DLoading() {
        viewer3DLoading.classList.remove("hidden");
        hideStatus();
      }

      function hide3DLoading() {
        viewer3DLoading.classList.add("hidden");
      }

      function findBestMaterial(viewer, preferredNames) {
        if (!viewer.model || !viewer.model.materials) return null;
        const materials = viewer.model.materials;

        for (const name of preferredNames) {
          const mat = materials.find(m => m.name === name);
          if (mat) return mat;
        }

        for (const name of preferredNames) {
          const mat = materials.find(m => m.name.toLowerCase() === name.toLowerCase());
          if (mat) return mat;
        }

        for (const name of preferredNames) {
          const mat = materials.find(m => 
            m.name.toLowerCase().includes(name.toLowerCase()) ||
            name.toLowerCase().includes(m.name.toLowerCase())
          );
          if (mat) return mat;
        }

        for (const name of COMMON_LABEL_MATERIALS) {
          const mat = materials.find(m => m.name === name);
          if (mat) return mat;
        }

        return materials.length > 0 ? materials[0] : null;
      }

      async function applyTextureToMaterial(viewer, material, textureUrl) {
        if (!viewer || !material || !textureUrl) return false;

        try {
          const texture = await viewer.createTexture(textureUrl);
          if (!texture) return false;

          const pbr = material.pbrMetallicRoughness;

          if (typeof pbr.setBaseColorFactor === 'function') {
            pbr.setBaseColorFactor([1.0, 1.0, 1.0, 1.0]);
          }

          if (pbr.baseColorTexture) {
            pbr.baseColorTexture.setTexture(texture);
          }

          try {
            const texInfo = pbr.baseColorTexture;
            if (texInfo && texInfo.texture && texInfo.texture.sampler) {
              const sampler = texInfo.texture.sampler;
              const GL_CLAMP_TO_EDGE = 33071;
              const GL_LINEAR = 9729;
              const GL_LINEAR_MIPMAP_LINEAR = 9987;

              if (typeof sampler.setWrapS === 'function') {
                sampler.setWrapS(GL_CLAMP_TO_EDGE);
                sampler.setWrapT(GL_CLAMP_TO_EDGE);
              }
              if (typeof sampler.setMinFilter === 'function') {
                sampler.setMinFilter(GL_LINEAR_MIPMAP_LINEAR);
              }
              if (typeof sampler.setMagFilter === 'function') {
                sampler.setMagFilter(GL_LINEAR);
              }
            }
          } catch (e) {
            console.warn("Could not set sampler settings:", e);
          }

          if (typeof pbr.setMetallicFactor === 'function') {
            pbr.setMetallicFactor(0.0);
          }
          if (typeof pbr.setRoughnessFactor === 'function') {
            pbr.setRoughnessFactor(0.5);
          }

          return true;
        } catch (error) {
          console.error("Error applying texture:", error);
          return false;
        }
      }

      async function applyTextureToModel() {
        if (!modelViewer.model || !textureImageDataUrl) return;

        const shape = getCurrentShape();
        if (!shape) return;

        const materialNames = shape.targetMaterials || COMMON_LABEL_MATERIALS;
        const material = findBestMaterial(modelViewer, materialNames);

        if (!material) return;

        await applyTextureToMaterial(modelViewer, material, textureImageDataUrl);
      }

      async function load3DModel(shape) {
        isModelLoaded = false;

        if (!shape || !shape.modelPath) {
          showStatus("No 3D model");
          modelViewer.src = "";
          return;
        }

        show3DLoading();
        modelViewer.src = shape.modelPath + "?t=" + Date.now();
      }

      modelViewer.addEventListener("load", async () => {
        isModelLoaded = true;
        hide3DLoading();
        hideStatus();

        let attempts = 0;
        while (!modelViewer.model && attempts < 100) {
          await new Promise(r => setTimeout(r, 50));
          attempts++;
        }

        if (textureImageDataUrl && modelViewer.model) {
          await applyTextureToModel();
        }
      });

      modelViewer.addEventListener("error", () => {
        hide3DLoading();
        showStatus("Load failed");
        isModelLoaded = false;
      });

      modelViewer.addEventListener("progress", (event) => {
        const progress = event.detail.totalProgress;
        if (progress < 1) {
          const percent = Math.round(progress * 100);
          viewer3DLoading.querySelector("span").textContent = `${percent}%`;
        }
      });

      function toggleViewer3D() {
        isViewer3DMinimized = !isViewer3DMinimized;
        viewer3DContainer.classList.toggle("minimized", isViewer3DMinimized);
        
        if (isViewer3DMinimized) {
          isViewer3DExpanded = false;
          viewer3DContainer.classList.remove("expanded");
        }
      }

      function toggleViewer3DExpand() {
        if (isViewer3DMinimized) return;
        isViewer3DExpanded = !isViewer3DExpanded;
        viewer3DContainer.classList.toggle("expanded", isViewer3DExpanded);
      }

      viewer3DToggle.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleViewer3D();
      });

      viewer3DExpand.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleViewer3DExpand();
      });

      viewer3DContainer.addEventListener("click", (e) => {
        if (isViewer3DMinimized && !e.target.closest('.viewer3D-btn')) {
          toggleViewer3D();
        }
      });

      // ========== SHAPE FUNCTIONS ==========

      function preProcessShapes() {
        for (const [key, shape] of Object.entries(allBottleShapes)) {
          shape.topSampler = new PathSampler(shape.topPath);
          shape.bottomSampler = new PathSampler(shape.bottomPath);

          if (!shapeGroups[shape.name]) {
            shapeGroups[shape.name] = {};
          }
          shapeGroups[shape.name][shape.view] = key;
          keyToGroupName[key] = shape.name;
        }
      }

      function getCurrentShape() {
        return currentShape ? allBottleShapes[currentShape] : null;
      }

      function updateUploadPlaceholder() {
        const shape = getCurrentShape();
        if (shape && shape.uploadDimensions) {
          const { width, height } = shape.uploadDimensions;
          uploadText.innerHTML = `<span class="text-xs text-slate-500 block text-center">${width}  ${height}px</span>Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>`;
        } else {
          uploadText.innerHTML = 'Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>';
        }
        svgBadge.classList.remove("visible");
      }

      function toggleViewSelector() {
        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          viewSelector.classList.remove("hidden");
        } else {
          viewSelector.classList.add("hidden");
        }
      }

      function syncSweetBoxViewControls() {
        const topRadioDiv = document.getElementById("viewTopRadio").parentElement;
        const bottomRadioDiv = document.getElementById("viewBottomRadio").parentElement;

        if ((currentShapeType !== "sweet_box" && currentShapeType !== "sweet_box_te") || !currentShape) {
          topRadioDiv.classList.add("hidden");
          bottomRadioDiv.classList.add("hidden");
          return;
        }

        const groupName = keyToGroupName[currentShape];
        const group = shapeGroups[groupName];

        topRadioDiv.classList.toggle("hidden", !group.top);
        bottomRadioDiv.classList.toggle("hidden", !group.bottom);

        if (currentShape.endsWith("_top")) {
          currentView = "top";
          document.getElementById("viewTopRadio").checked = true;
        } else if (currentShape.endsWith("_bottom")) {
          currentView = "bottom";
          document.getElementById("viewBottomRadio").checked = true;
        }
      }

      function updateSpecificShapeSelector() {
        shapeSelect.innerHTML = "";
        let firstShapeKey = null;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const uniqueNames = new Set();
          for (const key in allBottleShapes) {
            const shape = allBottleShapes[key];
            if (shape.type === currentShapeType && !uniqueNames.has(shape.name)) {
              uniqueNames.add(shape.name);
              const option = document.createElement("option");
              option.value = shape.name;
              option.textContent = shape.name;
              shapeSelect.appendChild(option);
            }
          }
          if (shapeSelect.options.length > 0) {
            const selectedName = shapeSelect.options[0].value;
            shapeSelect.value = selectedName;
            const group = shapeGroups[selectedName];
            firstShapeKey = group.top || group.bottom;
          }
        } else {
          for (const [key, shape] of Object.entries(allBottleShapes)) {
            if (shape.type === currentShapeType) {
              const option = document.createElement("option");
              option.value = key;
              option.textContent = shape.name;
              shapeSelect.appendChild(option);
              if (!firstShapeKey) firstShapeKey = key;
            }
          }
          if (firstShapeKey) shapeSelect.value = firstShapeKey;
        }

        currentShape = firstShapeKey;
        syncSweetBoxViewControls();

        const shape = getCurrentShape();
        load3DModel(shape);
      }

      function populateShapeTypes() {
        shapeTypeSelect.innerHTML = "";
        for (const [key, name] of Object.entries(shapeTypes)) {
          const option = document.createElement("option");
          option.value = key;
          option.textContent = name;
          shapeTypeSelect.appendChild(option);
        }
        shapeTypeSelect.value = currentShapeType;
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
      }

      // ========== MAIN DRAWING FUNCTIONS ==========

      function renderImageContent(localCtx, targetW, targetH, isExport, exportScale, clearBackground, applyPan = false) {
        if (clearBackground) localCtx.clearRect(0, 0, targetW, targetH);

        const shape = getCurrentShape();
        if (!shape) return;

        const margin = isExport ? 0 : 20;
        const scaleXFit = (targetW - 2 * margin) / shape.width;
        const scaleYFit = (targetH - 2 * margin) / shape.height;
        let finalScale = isExport ? exportScale : Math.min(scaleXFit, scaleYFit);
        
        if (!isExport) {
          finalScale *= zoomLevel;
        }

        const scaledW = shape.width * finalScale;
        const scaledH = shape.height * finalScale;
        let offsetX = (targetW - scaledW) / 2;
        let offsetY = (targetH - scaledH) / 2;
        
        if (applyPan && !isExport) {
          offsetX += panX;
          offsetY += panY;
        }

        const path = new Path2D(shape.path);
        const transformMatrix = new DOMMatrix();
        transformMatrix.translateSelf(offsetX, offsetY);
        transformMatrix.scaleSelf(finalScale, finalScale);

        if (currentImage) {
          localCtx.save();
          localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
          localCtx.clip(path);
          localCtx.setTransform(1, 0, 0, 1, 0, 0);

          if (!isExport && window.devicePixelRatio && localCtx === ctx) {
            localCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
          }

          let imageOffsetX = 0;
          const needsHorizontalShift = ["500ml_round", "750ml_round", "1000ml_round", "450ml_round_square", "500ml_round_square"].includes(currentShape);
          if (needsHorizontalShift) imageOffsetX = isExport ? 22 : 5;

          if (shape.type === "rectangle" || shape.view === "top" || shape.type === "sweet_box_te") {
            let drawOffsetX = offsetX + imageOffsetX;
            let drawOffsetY = offsetY;
            let drawScaledW = scaledW;
            let drawScaledH = scaledH;

            if (currentShape === "250ml_sweet_box_te_bottom") {
              const scaleFactor = 1.029;
              drawScaledW = scaledW * scaleFactor;
              drawScaledH = scaledH * scaleFactor;
              drawOffsetX = offsetX - (drawScaledW - scaledW) / 2 + imageOffsetX;
              drawOffsetY = offsetY - (drawScaledH - scaledH) / 2;
            }

            localCtx.drawImage(currentImage, drawOffsetX, drawOffsetY, drawScaledW, drawScaledH);
          } else {
            // Use enhanced mesh-based warping for curved shapes
            drawWarpWithMesh(localCtx, currentImage, shape, offsetX + imageOffsetX, offsetY, finalScale, isExport);
          }

          localCtx.restore();
        } else {
          localCtx.save();
          localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
          localCtx.fillStyle = "#eee";
          localCtx.fill(path);
          localCtx.restore();
        }
      }

      function drawShape(localCtx, targetW, targetH, isExport, exportScale, clearBackground, applyPan = false) {
        localCtx.imageSmoothingEnabled = true;
        localCtx.imageSmoothingQuality = "high";

        renderImageContent(localCtx, targetW, targetH, isExport, exportScale, clearBackground, applyPan);

        const shape = getCurrentShape();
        if (!shape) {
          if (clearBackground) localCtx.clearRect(0, 0, targetW * (window.devicePixelRatio || 1), targetH * (window.devicePixelRatio || 1));
          const dpr = window.devicePixelRatio || 1;
          localCtx.font = `${16 * dpr}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
          localCtx.textAlign = "center";
          localCtx.fillStyle = "#9ca3af";
          localCtx.fillText("No shapes available for this type/view.", (targetW * dpr) / 2, (targetH * dpr) / 2);
          return;
        }

        const margin = isExport ? 0 : 20;
        const scaleXFit = (targetW - 2 * margin) / shape.width;
        const scaleYFit = (targetH - 2 * margin) / shape.height;
        let finalScale = isExport ? exportScale : Math.min(scaleXFit, scaleYFit);
        
        if (!isExport) {
          finalScale *= zoomLevel;
        }
        
        const scaledW = shape.width * finalScale;
        const scaledH = shape.height * finalScale;
        let offsetX = (targetW - scaledW) / 2;
        let offsetY = (targetH - scaledH) / 2;
        
        if (applyPan && !isExport) {
          offsetX += panX;
          offsetY += panY;
        }

        const path = new Path2D(shape.path);
        const transformMatrix = new DOMMatrix();
        transformMatrix.translateSelf(offsetX, offsetY);
        transformMatrix.scaleSelf(finalScale, finalScale);

        // Draw outline (preview only)
        localCtx.save();
        localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
        if (!isExport) {
          localCtx.strokeStyle = "#ed312c";
          localCtx.lineWidth = 2 / finalScale;
          localCtx.stroke(path);
        }
        localCtx.restore();
      }

      function mainDraw() {
        resizeCanvas();
        drawShape(ctx, canvas.clientWidth, canvas.clientHeight, false, 1, true, true);
      }

      // ===== END OF PART 4 =====

            // ========== IMAGE UPLOAD HANDLING ==========

      async function processUploadedImage(img, shape) {
        updateLoading("Applying to shape...", "Almost done");
        
        currentImage = img;

        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.drawImage(img, 0, 0);
        currentImageDataUrl = tempCanvas.toDataURL("image/png");
        textureImageDataUrl = currentImageDataUrl;

        await new Promise(r => setTimeout(r, 100));

        if (isModelLoaded && modelViewer.model) {
          updateLoading("Applying 3D texture...", "Finishing up");
          await applyTextureToModel();
        }

        mainDraw();
        hideLoading();
      }

      async function handleImageUpload(event) {
        const file = (event.target.files || [])[0];

        if (!file) {
          currentImage = null;
          currentImageDataUrl = null;
          textureImageDataUrl = null;
          uploadedSVGContent = null;
          uploadedSVGDimensions = null;
          mainDraw();
          updateUploadPlaceholder();
          const shape = getCurrentShape();
          if (shape) load3DModel(shape);
          return;
        }

        showLoading("Loading image...", "Reading file");

        const isSVG = file.type === "image/svg+xml" || file.name.toLowerCase().endsWith(".svg");
        const shape = getCurrentShape();

        if (isSVG) {
          const reader = new FileReader();
          reader.onload = async function (e) {
            updateLoading("Processing SVG...", "Parsing file");
            
            let svgText = e.target.result;
            
            // Store original SVG content for vector export
            uploadedSVGContent = svgText;
            
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
            const svgElement = svgDoc.querySelector("svg");

            const parserError = svgDoc.querySelector("parsererror");
            if (parserError || !svgElement) {
              hideLoading();
              showError("Invalid SVG File", "The SVG file could not be parsed. Please make sure it's a valid SVG file.");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              uploadedSVGContent = null;
              uploadedSVGDimensions = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
              return;
            }

            let width = svgElement.getAttribute("width");
            let height = svgElement.getAttribute("height");
            const viewBox = svgElement.getAttribute("viewBox");

            if (width) width = parseFloat(width);
            if (height) height = parseFloat(height);

            if ((!width || !height) && viewBox) {
              const vbParts = viewBox.split(/[\s,]+/).map(parseFloat);
              if (vbParts.length === 4) {
                if (!width) width = vbParts[2];
                if (!height) height = vbParts[3];
              }
            }

            if (!width || !height || isNaN(width) || isNaN(height)) {
              if (shape && shape.uploadDimensions) {
                width = width || shape.uploadDimensions.width;
                height = height || shape.uploadDimensions.height;
              } else {
                width = width || 1000;
                height = height || 1000;
              }
            }

            // Store SVG dimensions for vector export
            uploadedSVGDimensions = { width, height };

            svgElement.setAttribute("width", width);
            svgElement.setAttribute("height", height);
            if (!viewBox) svgElement.setAttribute("viewBox", `0 0 ${width} ${height}`);

            svgText = new XMLSerializer().serializeToString(svgDoc);
            
            // Update stored SVG content with normalized version
            uploadedSVGContent = svgText;
            
            const blob = new Blob([svgText], { type: "image/svg+xml" });
            const url = URL.createObjectURL(blob);

            const img = new Image();
            img.onload = async () => {
              if (shape && shape.uploadDimensions) {
                const expectedWidth = shape.uploadDimensions.width;
                const expectedHeight = shape.uploadDimensions.height;

                if (width < expectedWidth || height < expectedHeight) {
                  hideLoading();
                  showError(
                    "Image Too Small",
                    `The image dimensions (${Math.round(width)}  ${Math.round(height)}px) are smaller than required.\n\nMinimum size: ${expectedWidth}  ${expectedHeight}px`
                  );
                  currentImage = null;
                  currentImageDataUrl = null;
                  textureImageDataUrl = null;
                  uploadedSVGContent = null;
                  uploadedSVGDimensions = null;
                  fileInput.value = "";
                  updateUploadPlaceholder();
                  URL.revokeObjectURL(url);
                  mainDraw();
                  return;
                }
              }

              const fullName = file.name;
              const dotIndex = fullName.lastIndexOf(".");
              let name = dotIndex !== -1 ? fullName.substring(0, dotIndex) : fullName;
              const ext = dotIndex !== -1 ? fullName.substring(dotIndex) : "";
              if (name.length > 12) name = name.substring(0, 12) + "...";
              uploadText.textContent = `${name}${ext}`;
              
              // Show SVG badge
              svgBadge.classList.add("visible");

              await processUploadedImage(img, shape);
              URL.revokeObjectURL(url);
            };

            img.onerror = () => {
              URL.revokeObjectURL(url);
              hideLoading();
              showError("Failed to Load SVG", "The SVG file could not be loaded. Please try a different file.");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              uploadedSVGContent = null;
              uploadedSVGDimensions = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
            };

            img.src = url;
          };

          reader.onerror = () => {
            hideLoading();
            showError("File Read Error", "Failed to read the SVG file. Please try again.");
            fileInput.value = "";
            updateUploadPlaceholder();
            mainDraw();
          };

          reader.readAsText(file);
        } else {
          // Clear SVG content for non-SVG files
          uploadedSVGContent = null;
          uploadedSVGDimensions = null;
          svgBadge.classList.remove("visible");
          
          const reader = new FileReader();
          reader.onload = async function (e) {
            updateLoading("Processing image...", "Loading pixels");
            
            const img = new Image();
            img.onload = async () => {
              if (shape && shape.uploadDimensions) {
                const expectedWidth = shape.uploadDimensions.width;
                const expectedHeight = shape.uploadDimensions.height;

                if (img.width < expectedWidth || img.height < expectedHeight) {
                  hideLoading();
                  showError(
                    "Image Too Small",
                    `The image dimensions (${img.width}  ${img.height}px) are smaller than required.\n\nMinimum size: ${expectedWidth}  ${expectedHeight}px`
                  );
                  currentImage = null;
                  currentImageDataUrl = null;
                  textureImageDataUrl = null;
                  fileInput.value = "";
                  updateUploadPlaceholder();
                  mainDraw();
                  return;
                }
              }

              const fullName = file.name;
              const dotIndex = fullName.lastIndexOf(".");
              let name = dotIndex !== -1 ? fullName.substring(0, dotIndex) : fullName;
              const ext = dotIndex !== -1 ? fullName.substring(dotIndex) : "";
              if (name.length > 12) name = name.substring(0, 12) + "...";
              uploadText.textContent = `${name}${ext}`;

              await processUploadedImage(img, shape);
            };
            img.onerror = () => {
              hideLoading();
              showError("Failed to Load Image", "The image file could not be loaded. Please try a different file format (PNG, JPG, etc.).");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
            };
            img.src = e.target.result;
          };
          
          reader.onerror = () => {
            hideLoading();
            showError("File Read Error", "Failed to read the image file. Please try again.");
            fileInput.value = "";
            updateUploadPlaceholder();
            mainDraw();
          };
          
          reader.readAsDataURL(file);
        }
      }

      // ========== VIEW & SHAPE CHANGE HANDLERS ==========

      async function handleViewChange(event) {
        const newView = event.target.value;
        currentView = newView;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const groupName = shapeSelect.value;
          const group = shapeGroups[groupName];
          const newShapeKey = group[newView];

          if (newShapeKey) {
            currentShape = newShapeKey;
            updateUploadPlaceholder();
            currentImage = null;
            currentImageDataUrl = null;
            textureImageDataUrl = null;
            uploadedSVGContent = null;
            uploadedSVGDimensions = null;
            fileInput.value = "";

            const shape = getCurrentShape();
            load3DModel(shape);
            mainDraw();
          }
        }
      }

      async function handleShapeTypeChange(event) {
        currentShapeType = event.target.value;
        toggleViewSelector();
        updateSpecificShapeSelector();
        updateUploadPlaceholder();
        currentImage = null;
        currentImageDataUrl = null;
        textureImageDataUrl = null;
        uploadedSVGContent = null;
        uploadedSVGDimensions = null;
        fileInput.value = "";
        // Reset zoom and pan when changing shape type
        zoomLevel = 1;
        panX = 0;
        panY = 0;
        updateZoomDisplay();
        mainDraw();
      }

      async function handleShapeChange(event) {
        const selectedValue = event.target.value;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const group = shapeGroups[selectedValue];
          currentShape = group.top || group.bottom;
        } else {
          currentShape = selectedValue;
        }

        syncSweetBoxViewControls();
        updateUploadPlaceholder();
        currentImage = null;
        currentImageDataUrl = null;
        textureImageDataUrl = null;
        uploadedSVGContent = null;
        uploadedSVGDimensions = null;
        fileInput.value = "";
        // Reset zoom and pan when changing shape
        zoomLevel = 1;
        panX = 0;
        panY = 0;
        updateZoomDisplay();

        const shape = getCurrentShape();
        load3DModel(shape);
        mainDraw();
      }

      // ===== END OF PART 5 =====

            // ========== EXPORT FUNCTIONS ==========

      // Upscale image for better quality export
      function upscaleImage(img, targetWidth, targetHeight) {
        return new Promise((resolve) => {
          const upscaleCanvas = document.createElement("canvas");
          upscaleCanvas.width = targetWidth;
          upscaleCanvas.height = targetHeight;
          const upscaleCtx = upscaleCanvas.getContext("2d");
          
          upscaleCtx.imageSmoothingEnabled = true;
          upscaleCtx.imageSmoothingQuality = "high";
          upscaleCtx.drawImage(img, 0, 0, targetWidth, targetHeight);
          
          const upscaledImg = new Image();
          upscaledImg.onload = () => resolve(upscaledImg);
          upscaledImg.src = upscaleCanvas.toDataURL("image/png", 1.0);
        });
      }

      async function exportPNG() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }

        isExporting = true;
        showLoading("Exporting PNG...", "Generating high-resolution image");

        await new Promise(r => setTimeout(r, 50));

        try {
          updateLoading("Exporting PNG...", "Upscaling image");
          
          // Upscale the source image if needed for better quality
          const targetImgWidth = shape.uploadDimensions ? shape.uploadDimensions.width * 2 : currentImage.width * 2;
          const targetImgHeight = shape.uploadDimensions ? shape.uploadDimensions.height * 2 : currentImage.height * 2;
          
          let processedImage = currentImage;
          if (currentImage.width < targetImgWidth || currentImage.height < targetImgHeight) {
            processedImage = await upscaleImage(currentImage, 
              Math.max(currentImage.width, targetImgWidth), 
              Math.max(currentImage.height, targetImgHeight)
            );
          }
          
          // Temporarily swap currentImage for export
          const originalImage = currentImage;
          currentImage = processedImage;
          
          updateLoading("Exporting PNG...", "Creating canvas");
          
          const exportWidth = shape.width * EXPORT_SCALE;
          const exportHeight = shape.height * EXPORT_SCALE;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const exportCtx = exportCanvas.getContext("2d", { alpha: true });

          // Clear with transparent background
          exportCtx.clearRect(0, 0, exportWidth, exportHeight);

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PNG...", "Rendering high-quality mesh");

          drawShape(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, false, false);
          
          // Restore original image
          currentImage = originalImage;

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PNG...", "Generating file");

          const blob = await new Promise((resolve, reject) => {
            exportCanvas.toBlob(
              (b) => {
                if (b) resolve(b);
                else reject(new Error("Failed to create blob"));
              },
              "image/png",
              1.0
            );
          });

          updateLoading("Exporting PNG...", "Starting download");
          
          await triggerDownload(blob, `${currentShape}_Wrap.png`);
          
          hideLoading();
        } catch (error) {
          console.error("Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the PNG file. Please try again.");
        }
      }

      // ========== SVG EXPORT (Vector or Rasterized based on input) ==========
      
      function createRasterizedSVGString() {
        const shape = getCurrentShape();
        if (!shape) return null;
        
        const exportWidth = shape.width * EXPORT_SCALE;
        const exportHeight = shape.height * EXPORT_SCALE;
        const exportCanvas = document.createElement("canvas");
        exportCanvas.width = exportWidth;
        exportCanvas.height = exportHeight;
        const exportCtx = exportCanvas.getContext("2d", { alpha: true });
        
        exportCtx.clearRect(0, 0, exportWidth, exportHeight);
        renderImageContent(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, false, false);
        
        const rasterData = exportCanvas.toDataURL("image/png");
        const svgContent = `<image x="0" y="0" width="${shape.width}" height="${shape.height}" href="${rasterData}" preserveAspectRatio="none" />`;

        return `<?xml version="1.0" encoding="UTF-8"?>
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
     viewBox="0 0 ${shape.width} ${shape.height}" 
     width="${shape.width}" height="${shape.height}">
${svgContent}
</svg>`;
      }

      async function exportSVG() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }

        isExporting = true;
        
        // Check if we have vector SVG content to export
        if (uploadedSVGContent) {
          // Export as vector SVG
          showLoading("Exporting Vector SVG...", "Preparing transformation");

          try {
            await new Promise(r => setTimeout(r, 50));
            
            // Get source dimensions
            const sourceWidth = uploadedSVGDimensions?.width || shape.uploadDimensions?.width || 1000;
            const sourceHeight = uploadedSVGDimensions?.height || shape.uploadDimensions?.height || 1000;
            
            updateLoading("Exporting Vector SVG...", "Building high-resolution mesh");
            
            // Create warper with very high resolution for smooth curves
            const warper = new MeshWarper(
              shape.topPath, 
              shape.bottomPath, 
              sourceWidth,
              sourceHeight,
              {
                gridCols: 150,  // Very high resolution for smooth vector output
                gridRows: 60,
                topIsReversed: shape.topIsReversed,
                bottomIsReversed: shape.bottomIsReversed
              }
            );

            await new Promise(r => setTimeout(r, 50));
            updateLoading("Exporting Vector SVG...", "Transforming paths");

            const transformer = new SVGDocumentTransformer(
              warper,
              sourceWidth,
              sourceHeight
            );

            const transformedSVG = transformer.transformSVG(
              uploadedSVGContent, 
              shape.width, 
              shape.height
            );
            
            await new Promise(r => setTimeout(r, 50));
            updateLoading("Exporting Vector SVG...", "Starting download");
            
            const blob = new Blob([transformedSVG], { type: "image/svg+xml;charset=utf-8" });
            await triggerDownload(blob, `${currentShape}_Wrap.svg`);
            
            hideLoading();
          } catch (error) {
            console.error("Vector SVG export error:", error);
            hideLoading();
            showError("Vector Export Failed", "Failed to transform the SVG paths. Falling back to rasterized export.\n\nThe file may have complex or unsupported elements.");
            
            // Fallback to rasterized export
            isExporting = true;
            await exportRasterizedSVG();
          }
        } else {
          // Export as rasterized SVG for non-SVG uploads
          await exportRasterizedSVG();
        }
      }

      async function exportRasterizedSVG() {
        showLoading("Exporting SVG...", "Creating rasterized SVG");

        await new Promise(r => setTimeout(r, 50));

        try {
          updateLoading("Exporting SVG...", "Generating content");
          
          const svgString = createRasterizedSVGString();
          if (!svgString) {
            throw new Error("Failed to create SVG content");
          }

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting SVG...", "Starting download");

          const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
          await triggerDownload(blob, `${currentShape}_Wrap.svg`);
          
          hideLoading();
        } catch (error) {
          console.error("Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the SVG file. Please try again.");
        }
      }

      // ========== PDF EXPORT ==========
      async function exportPDF() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }
        
        // Check if jsPDF is loaded
        if (typeof window.jspdf === 'undefined') {
          showError("Library Error", "PDF library not loaded. Please refresh the page and try again.");
          return;
        }

        isExporting = true;
        showLoading("Exporting PDF...", "Creating document");

        await new Promise(r => setTimeout(r, 50));

        try {
          const { jsPDF } = window.jspdf;
          
          updateLoading("Exporting PDF...", "Rendering high-quality image");
          
          // Create high-resolution canvas with transparency
          const exportWidth = shape.width * EXPORT_SCALE;
          const exportHeight = shape.height * EXPORT_SCALE;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const exportCtx = exportCanvas.getContext("2d", { alpha: true });
          
          // Clear with transparent background
          exportCtx.clearRect(0, 0, exportWidth, exportHeight);
          
          // Draw only the shape content (no background)
          renderImageContent(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, false, false);

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PDF...", "Generating PDF");

          // Get image data as PNG to preserve transparency
          const imgData = exportCanvas.toDataURL('image/png');
          
          // Create PDF with exact dimensions
          const pdf = new jsPDF({
            orientation: shape.width > shape.height ? 'landscape' : 'portrait',
            unit: 'pt',
            format: [shape.width, shape.height],
            compress: true
          });
          
          // Add the transparent PNG image
          pdf.addImage(imgData, 'PNG', 0, 0, shape.width, shape.height, undefined, 'FAST');
          
          // Add metadata
          pdf.setProperties({
            title: `${currentShape}_Wrap`,
            subject: 'Label Wrap Export - Transparent Background',
            creator: 'Terra Tech Packs',
            keywords: 'label, wrap, packaging, transparent'
          });

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PDF...", "Starting download");

          // Save the PDF
          pdf.save(`${currentShape}_Wrap.pdf`);
          
          await new Promise(r => setTimeout(r, 500));
          
          hideLoading();
        } catch (error) {
          console.error("PDF Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the PDF file. Please try again.");
        }
      }

      // ========== EVENT LISTENERS ==========
      
      // Window resize
      window.addEventListener("resize", debounce(mainDraw, 150));
      
      // File input
      fileInput.addEventListener("input", handleImageUpload);
      
      // Export buttons
      exportPngBtn.addEventListener("click", exportPNG);
      exportVectorSvgBtn.addEventListener("click", exportSVG);
      exportPdfBtn.addEventListener("click", exportPDF);
      
      // Shape selectors
      shapeTypeSelect.addEventListener("change", handleShapeTypeChange);
      shapeSelect.addEventListener("change", handleShapeChange);
      
      // View radio buttons
      document.querySelectorAll('input[name="view_type"]').forEach((radio) => {
        radio.addEventListener("change", handleViewChange);
      });

      // Zoom controls
      zoomInBtn.addEventListener("click", zoomIn);
      zoomOutBtn.addEventListener("click", zoomOut);
      zoomDisplay.addEventListener("click", resetZoom);
      resetPanBtn.addEventListener("click", resetPan);
      canvas.addEventListener("wheel", handleWheelZoom, { passive: false });

      // Pan controls - Mouse
      canvas.addEventListener("mousedown", startPan);
      window.addEventListener("mousemove", doPan);
      window.addEventListener("mouseup", endPan);
      window.addEventListener("mouseleave", endPan);

      // Pan controls - Touch
      canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
      canvas.addEventListener("touchend", handleTouchEnd);
      canvas.addEventListener("touchcancel", handleTouchEnd);

      // Pan controls - Keyboard (Space)
      window.addEventListener("keydown", handleSpaceDown);
      window.addEventListener("keyup", handleSpaceUp);

      // Handle window blur to reset space state
      window.addEventListener("blur", () => {
        isSpacePressed = false;
        endPan();
        updateCanvasCursor();
      });

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey || e.metaKey) {
          if (e.key === "p") {
            e.preventDefault();
            exportPNG();
          } else if (e.key === "s") {
            e.preventDefault();
            exportSVG();
          } else if (e.key === "=" || e.key === "+") {
            e.preventDefault();
            zoomIn();
          } else if (e.key === "-") {
            e.preventDefault();
            zoomOut();
          } else if (e.key === "0") {
            e.preventDefault();
            resetZoom();
          }
        }
      });

      // Drag and drop for file upload
      const fileUploadLabel = document.querySelector(".file-upload-label");
      fileUploadLabel.addEventListener("dragover", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.add("dragover");
      });
      fileUploadLabel.addEventListener("dragleave", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.remove("dragover");
      });
      fileUploadLabel.addEventListener("drop", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.remove("dragover");
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          fileInput.files = e.dataTransfer.files;
          fileInput.dispatchEvent(new Event("input", { bubbles: true }));
        }
      });

      // ========== INITIALIZATION ==========
      function initializeApp() {
        preProcessShapes();
        populateShapeTypes();
        toggleViewSelector();
        updateSpecificShapeSelector();
        updateUploadPlaceholder();
        updateZoomDisplay();
        mainDraw();
      }

      initializeApp();
    </script>
  </body>
</html>