<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Terra Tech Packs KLD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script
      type="module"
      src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.3.0/model-viewer.min.js"
    ></script>
    <style>
      .dragover { border-color: #3b82f6; }
      .radio-container.hidden { display: none; }
      
      /* Loading Overlay */
      .loading-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        flex-direction: column;
        backdrop-filter: blur(4px);
      }
      .loading-overlay.show { display: flex; }
      .loading-box {
        background: white;
        padding: 30px 50px;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
      }
      .spinner {
        border: 4px solid #e5e7eb;
        border-top: 4px solid #3b82f6;
        border-radius: 50%;
        width: 50px; height: 50px;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      .loading-text {
        color: #374151;
        font-size: 16px;
        font-weight: 500;
      }
      .loading-subtext {
        color: #9ca3af;
        font-size: 13px;
      }
      
      /* Error Popup Modal */
      .error-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1001;
        backdrop-filter: blur(2px);
      }
      .error-overlay.show { display: flex; }
      .error-popup {
        background: white;
        padding: 24px 32px;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 400px;
        width: 90%;
        text-align: center;
        animation: popIn 0.2s ease-out;
      }
      @keyframes popIn {
        0% { transform: scale(0.9); opacity: 0; }
        100% { transform: scale(1); opacity: 1; }
      }
      .error-icon {
        width: 56px;
        height: 56px;
        background: #fef2f2;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
      }
      .error-icon svg {
        width: 28px;
        height: 28px;
        fill: #ef4444;
      }
      .error-title {
        color: #1f2937;
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 8px;
      }
      .error-message {
        color: #6b7280;
        font-size: 14px;
        line-height: 1.5;
        margin-bottom: 20px;
        white-space: pre-line;
      }
      .error-close-btn {
        background: #3b82f6;
        color: white;
        border: none;
        padding: 10px 32px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
      }
      .error-close-btn:hover {
        background: #2563eb;
      }
      
      .site-logo {
        position: absolute;
        left: 2vw;
        top: 50%;
        transform: translateY(-50%);
        height: 2vw;
        object-fit: contain;
        z-index: 60;
      }
      @media (max-width: 420px) { .site-logo { display: none; } }
      @media (max-width: 640px) { .site-logo { height: 36px; left: 8px; } }
      
      /* 3D Viewer Container */
      #viewer3DContainer {
        position: absolute;
        top: 12px; right: 12px;
        width: 200px; height: 200px;
        background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
        border-radius: 12px;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
        overflow: hidden;
        z-index: 50;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
      }
      #viewer3DContainer:hover { box-shadow: 0 10px 35px rgba(0, 0, 0, 0.4); }
      #viewer3DContainer.expanded {
        width: 400px;
        height: 350px;
      }
      #modelViewer {
        width: 100%; height: 100%;
        display: block;
        --poster-color: transparent;
        --progress-bar-color: #3b82f6;
        --progress-bar-height: 2px;
      }
      .viewer3D-loading {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #64748b;
        font-size: 11px;
        text-align: center;
        z-index: 5;
        pointer-events: none;
      }
      .viewer3D-loading.hidden { display: none; }
      .viewer3D-loading .mini-spinner {
        width: 20px; height: 20px;
        border: 2px solid rgba(100, 116, 139, 0.3);
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 6px;
      }
      .viewer3D-status {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #64748b;
        font-size: 11px;
        text-align: center;
        z-index: 5;
        padding: 8px;
      }
      .viewer3D-status.hidden { display: none; }
      
      /* Viewer Controls */
      .viewer3D-controls {
        position: absolute;
        top: 6px; right: 6px;
        display: flex;
        gap: 4px;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.2s;
      }
      #viewer3DContainer:hover .viewer3D-controls { opacity: 1; }
      .viewer3D-btn {
        width: 24px; height: 24px;
        background: rgba(0, 0, 0, 0.6);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }
      .viewer3D-btn:hover { background: rgba(59, 130, 246, 0.8); }
      .viewer3D-btn svg { width: 14px; height: 14px; fill: #fff; }
      
      /* Minimized State */
      #viewer3DContainer.minimized { 
        width: 80px; 
        height: 28px; 
        cursor: pointer; 
      }
      #viewer3DContainer.minimized #modelViewer,
      #viewer3DContainer.minimized .viewer3D-loading,
      #viewer3DContainer.minimized .viewer3D-status { display: none !important; }
      #viewer3DContainer.minimized::after {
        content: "3D View";
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #94a3b8;
        font-size: 11px;
        font-weight: 600;
      }
      #viewer3DContainer.minimized #viewer3DExpand { display: none !important; }
      #viewer3DContainer.minimized .viewer3D-controls {
        opacity: 1;
        top: 50%;
        right: 6px;
        transform: translateY(-50%);
      }
      
      @media (max-width: 768px) {
        #viewer3DContainer { width: 160px; height: 160px; top: 8px; right: 8px; }
        #viewer3DContainer.expanded { width: 300px; height: 260px; }
      }
      @media (max-width: 480px) {
        #viewer3DContainer { width: 130px; height: 130px; }
        #viewer3DContainer.expanded { width: 240px; height: 210px; }
        #viewer3DContainer.minimized { width: 70px; height: 24px; }
      }
      
      /* Disable buttons during loading */
      .export:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      /* Zoom Controls */
      .zoom-controls {
        position: absolute;
        bottom: 16px;
        left: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 40;
      }
      .zoom-btn-group {
        display: flex;
        justify-content: space-between;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        overflow: hidden;
        border: 1px solid #e2e8f0;
      }
      .zoom-btn {
        width: 100%;
        height: 36px;
        border: none;
        background: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        color: #475569;
        margin: 0 auto;
      }
      .zoom-btn:hover {
        background: #f1f5f9;
        color: #3b82f6;
      }
      .zoom-btn:active {
        background: #e2e8f0;
      }
      .zoom-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .zoom-btn:disabled:hover {
        background: white;
        color: #475569;
      }
      .zoom-btn svg {
        width: 18px;
        height: 18px;
        fill: currentColor;
      }
      .zoom-divider {
        width: 1px;
        background: #e2e8f0;
      }
      .zoom-display {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        padding: 6px 12px;
        font-size: 12px;
        font-weight: 600;
        color: #475569;
        text-align: center;
        min-width: 60px;
        border: 1px solid #e2e8f0;
        cursor: pointer;
        transition: all 0.2s;
      }
      .zoom-display:hover {
        background: #f1f5f9;
        color: #3b82f6;
      }
      
      /* Pan indicator */
      .pan-indicator {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 500;
        color: #64748b;
        text-align: center;
        border: 1px solid #e2e8f0;
        display: flex;
        align-items: center;
        gap: 6px;
        opacity: 0;
        transition: opacity 0.2s;
      }
      .pan-indicator.visible {
        opacity: 1;
      }
      .pan-indicator.active {
        background: #3b82f6;
        color: white;
        border-color: #3b82f6;
      }
      .pan-indicator svg {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }
      
      /* Reset pan button */
      .reset-pan-btn {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 500;
        color: #475569;
        text-align: center;
        border: 1px solid #e2e8f0;
        cursor: pointer;
        display: none;
        align-items: center;
        gap: 6px;
        transition: all 0.2s;
      }
      .reset-pan-btn:hover {
        background: #f1f5f9;
        color: #3b82f6;
      }
      .reset-pan-btn.visible {
        display: flex;
      }
      .reset-pan-btn svg {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }
      
      @media (max-width: 480px) {
        .zoom-controls {
          bottom: 12px;
          left: 12px;
        }
        .zoom-btn {
          width: 32px;
          height: 32px;
        }
        .zoom-btn svg {
          width: 16px;
          height: 16px;
        }
        .zoom-display {
          padding: 5px 10px;
          font-size: 11px;
          min-width: 50px;
        }
        .pan-indicator, .reset-pan-btn {
          font-size: 10px;
          padding: 5px 8px;
        }
      }

      /* Canvas container for panning */
      .canvas-container {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      
      /* Canvas cursor states */
      #warpCanvas {
        cursor: default;
      }
      #warpCanvas.can-pan {
        cursor: grab;
      }
      #warpCanvas.space-held {
        cursor: grab;
      }
      #warpCanvas.panning {
        cursor: grabbing !important;
      }

      /* Vector export button style */
      .export-vector {
        background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      }
      .export-vector:hover {
        background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
      }

      /* SVG indicator badge */
      .svg-badge {
        position: absolute;
        top: -8px;
        right: -8px;
        background: #10b981;
        color: white;
        font-size: 9px;
        font-weight: 700;
        padding: 2px 6px;
        border-radius: 10px;
        display: none;
      }
      .svg-badge.visible {
        display: block;
      }
    </style>
  </head>
  <body class="bg-slate-100 flex flex-col h-screen overflow-hidden font-sans">
    <div class="bg-white shadow-md z-10 relative">
      <img src="./assets/terratechpacks.png" alt="Terra Tech Packs" class="site-logo" />
      <div class="container mx-auto pt-4 pb-3 flex justify-center items-end flex-wrap gap-x-6 gap-y-4">
        <div class="flex flex-col">
          <label for="shapeTypeSelect" class="text-xs font-semibold text-slate-600 mb-1">Select Shape Type:</label>
          <select id="shapeTypeSelect" class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 transition cursor-pointer"></select>
        </div>
        <div class="flex flex-col">
          <label for="shapeSelect" class="text-xs font-semibold text-slate-600 mb-1">Select Specific Shape:</label>
          <select id="shapeSelect" class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 transition cursor-pointer"></select>
        </div>
        <div id="viewSelector" class="hidden self-end pb-1">
          <div class="radio-group flex flex-col gap-1">
            <div class="radio-container">
              <input type="radio" id="viewTopRadio" name="view_type" value="top" class="cursor-pointer accent-blue-600" />
              <label for="viewTopRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Top</label>
            </div>
            <div class="radio-container">
              <input type="radio" id="viewBottomRadio" name="view_type" value="bottom" checked class="cursor-pointer accent-blue-600" />
              <label for="viewBottomRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Bottom</label>
            </div>
          </div>
        </div>
        <div id="dropArea" class="flex flex-col relative">
          <label for="imageUpload" class="text-xs font-semibold text-slate-600 mb-1">Upload Label:</label>
          <label class="file-upload-label h-12 min-w-[180px] flex items-center justify-center px-5 bg-slate-50 border-2 border-dashed border-slate-400 rounded-lg cursor-pointer hover:border-blue-500 transition relative" for="imageUpload">
            <input type="file" id="imageUpload" class="hidden" accept="image/*,.svg" />
            <small id="uploadText" class="font-medium text-slate-700">Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span></small>
            <span id="svgBadge" class="svg-badge">SVG</span>
          </label>
        </div>
        <button class="export h-12 px-6 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition" id="exportPngBtn">Export PNG</button>
        <button class="export export-vector h-12 px-6 text-white font-semibold rounded-lg transition" id="exportVectorSvgBtn" title="Export as vector SVG">Export SVG</button>
        <button class="export h-12 px-6 bg-red-700 text-white font-semibold rounded-lg hover:bg-red-800 transition" id="exportPdfBtn">Export PDF</button>
      </div>
    </div>

    <div class="flex-grow p-4 md:p-6 flex items-center justify-center relative">
      <div class="canvas-container">
        <canvas id="warpCanvas" class="w-full h-full bg-white rounded-lg shadow-sm"></canvas>
      </div>
      
      <!-- Zoom Controls -->
      <div class="zoom-controls">
        <div class="zoom-btn-group">
          <button id="zoomInBtn" class="zoom-btn" title="Zoom In (Ctrl++)">
            <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
          </button>
          <div class="zoom-divider"></div>
          <button id="zoomOutBtn" class="zoom-btn" title="Zoom Out (Ctrl+-)">
            <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
          </button>
        </div>
        <div id="zoomDisplay" class="zoom-display" title="Click to reset zoom">100%</div>
        
        <!-- Pan indicator -->
        <div id="panIndicator" class="pan-indicator">
          <svg viewBox="0 0 24 24"><path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"/></svg>
          <span id="panIndicatorText">Hold Space + Drag</span>
        </div>
        
        <!-- Reset pan button -->
        <button id="resetPanBtn" class="reset-pan-btn" title="Reset pan position">
          <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
          <span>Reset View</span>
        </button>
      </div>
      
      <!-- 3D Viewer -->
      <div id="viewer3DContainer">
        <div class="viewer3D-controls">
          <button id="viewer3DExpand" class="viewer3D-btn" title="Expand">
            <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
          </button>
          <button id="viewer3DToggle" class="viewer3D-btn" title="Minimize">
            <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
          </button>
        </div>
        
        <div class="viewer3D-loading" id="viewer3DLoading">
          <div class="mini-spinner"></div>
          <span>Loading...</span>
        </div>
        <div class="viewer3D-status hidden" id="viewer3DStatus"></div>
        
        <model-viewer
          id="modelViewer"
          alt="3D product preview"
          camera-controls
          auto-rotate
          rotation-per-second="30deg"
          exposure="1.0"
          shadow-intensity="1"
          environment-image="neutral"
          interaction-prompt="none"
          style="background: transparent"
        ></model-viewer>
      </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-box">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Processing...</div>
        <div class="loading-subtext" id="loadingSubtext">Please wait</div>
      </div>
    </div>

    <!-- Error Popup Modal -->
    <div id="errorOverlay" class="error-overlay">
      <div class="error-popup">
        <div class="error-icon">
          <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
        </div>
        <div class="error-title" id="errorTitle">Error</div>
        <div class="error-message" id="errorMessage">Something went wrong.</div>
        <button class="error-close-btn" id="errorCloseBtn">OK</button>
      </div>
    </div>
        <script type="module">
      // ========== HELPERS ==========
      function debounce(fn, wait = 150) {
        let t;
        return (...args) => {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, args), wait);
        };
      }

      // ========== PATH SAMPLER ==========
      class PathSampler {
        constructor(pathData) {
          this.pathNode = document.createElementNS("http://www.w3.org/2000/svg", "path");
          this.pathNode.setAttribute("d", pathData);
          this.length = this.pathNode.getTotalLength();
        }
        getPointAt(percentage) {
          return this.pathNode.getPointAtLength(this.length * percentage);
        }
      }

      // ========== ENHANCED MESH WARPER CLASS ==========
      class MeshWarper {
        constructor(topPath, bottomPath, sourceWidth, sourceHeight, options = {}) {
          this.topSampler = new PathSampler(topPath);
          this.bottomSampler = new PathSampler(bottomPath);
          this.sourceWidth = sourceWidth;
          this.sourceHeight = sourceHeight;
          this.gridCols = options.gridCols || 50;
          this.gridRows = options.gridRows || 20;
          this.topIsReversed = options.topIsReversed || false;
          this.bottomIsReversed = options.bottomIsReversed || false;
          this.mesh = null;
          this.buildMesh();
        }

        buildMesh() {
          this.mesh = [];
          for (let row = 0; row <= this.gridRows; row++) {
            const rowPoints = [];
            const v = row / this.gridRows;
            
            for (let col = 0; col <= this.gridCols; col++) {
              const u = col / this.gridCols;
              
              const tTop = this.topIsReversed ? 1 - u : u;
              const tBot = this.bottomIsReversed ? 1 - u : u;
              
              const topPoint = this.topSampler.getPointAt(Math.max(0, Math.min(1, tTop)));
              const bottomPoint = this.bottomSampler.getPointAt(Math.max(0, Math.min(1, tBot)));
              
              // Smooth interpolation using cosine for better curve quality
              const smoothV = v;
              const x = topPoint.x + (bottomPoint.x - topPoint.x) * smoothV;
              const y = topPoint.y + (bottomPoint.y - topPoint.y) * smoothV;
              
              rowPoints.push({ x, y, u, v });
            }
            this.mesh.push(rowPoints);
          }
        }

        transformPoint(srcX, srcY) {
          const u = srcX / this.sourceWidth;
          const v = srcY / this.sourceHeight;
          return this.transformNormalized(u, v);
        }

        transformNormalized(u, v) {
          u = Math.max(0, Math.min(1, u));
          v = Math.max(0, Math.min(1, v));
          
          const colFloat = u * this.gridCols;
          const rowFloat = v * this.gridRows;
          
          const col = Math.min(Math.floor(colFloat), this.gridCols - 1);
          const row = Math.min(Math.floor(rowFloat), this.gridRows - 1);
          
          const colFrac = colFloat - col;
          const rowFrac = rowFloat - row;
          
          const p00 = this.mesh[row][col];
          const p01 = this.mesh[row][col + 1];
          const p10 = this.mesh[row + 1][col];
          const p11 = this.mesh[row + 1][col + 1];
          
          const x = (1 - colFrac) * (1 - rowFrac) * p00.x +
                    colFrac * (1 - rowFrac) * p01.x +
                    (1 - colFrac) * rowFrac * p10.x +
                    colFrac * rowFrac * p11.x;
                    
          const y = (1 - colFrac) * (1 - rowFrac) * p00.y +
                    colFrac * (1 - rowFrac) * p01.y +
                    (1 - colFrac) * rowFrac * p10.y +
                    colFrac * rowFrac * p11.y;
          
          return { x, y };
        }

        getMeshPoints() {
          return this.mesh;
        }
      }

      // ========== SVG PATH PARSER ==========
      class SVGPathParser {
        static parse(pathData) {
          const commands = [];
          let match;
          const regex = /([MmLlHhVvCcSsQqTtAaZz])([^MmLlHhVvCcSsQqTtAaZz]*)/g;
          while ((match = regex.exec(pathData)) !== null) {
            const type = match[1];
            const argsStr = match[2].trim();
            const args = argsStr.match(/-?(?:\d+\.?\d*|\.\d+)(?:[eE][-+]?\d+)?/g)?.map(Number) || [];
            commands.push({ type, args });
          }
          return commands;
        }

        static toAbsolute(commands) {
          const result = [];
          let currentX = 0, currentY = 0;
          let startX = 0, startY = 0;

          for (const cmd of commands) {
            const { type, args } = cmd;
            const newArgs = [...args];
            let newType = type.toUpperCase();

            switch (type) {
              case 'm':
                newArgs[0] += currentX;
                newArgs[1] += currentY;
                currentX = newArgs[0];
                currentY = newArgs[1];
                startX = currentX;
                startY = currentY;
                break;
              case 'M':
                currentX = args[0];
                currentY = args[1];
                startX = currentX;
                startY = currentY;
                break;
              case 'l':
                newArgs[0] += currentX;
                newArgs[1] += currentY;
                currentX = newArgs[0];
                currentY = newArgs[1];
                break;
              case 'L':
                currentX = args[0];
                currentY = args[1];
                break;
              case 'h':
                newArgs[0] = currentX + args[0];
                newArgs[1] = currentY;
                newType = 'L';
                currentX = newArgs[0];
                break;
              case 'H':
                newArgs[0] = args[0];
                newArgs[1] = currentY;
                newType = 'L';
                currentX = args[0];
                break;
              case 'v':
                newArgs[0] = currentX;
                newArgs[1] = currentY + args[0];
                newType = 'L';
                currentY = newArgs[1];
                break;
              case 'V':
                newArgs[0] = currentX;
                newArgs[1] = args[0];
                newType = 'L';
                currentY = args[0];
                break;
              case 'c':
                for (let i = 0; i < 6; i += 2) {
                  newArgs[i] += currentX;
                  newArgs[i + 1] += currentY;
                }
                currentX = newArgs[4];
                currentY = newArgs[5];
                break;
              case 'C':
                currentX = args[4];
                currentY = args[5];
                break;
              case 's':
                for (let i = 0; i < 4; i += 2) {
                  newArgs[i] += currentX;
                  newArgs[i + 1] += currentY;
                }
                currentX = newArgs[2];
                currentY = newArgs[3];
                break;
              case 'S':
                currentX = args[2];
                currentY = args[3];
                break;
              case 'q':
                for (let i = 0; i < 4; i += 2) {
                  newArgs[i] += currentX;
                  newArgs[i + 1] += currentY;
                }
                currentX = newArgs[2];
                currentY = newArgs[3];
                break;
              case 'Q':
                currentX = args[2];
                currentY = args[3];
                break;
              case 't':
                newArgs[0] += currentX;
                newArgs[1] += currentY;
                currentX = newArgs[0];
                currentY = newArgs[1];
                break;
              case 'T':
                currentX = args[0];
                currentY = args[1];
                break;
              case 'a':
                newArgs[5] += currentX;
                newArgs[6] += currentY;
                currentX = newArgs[5];
                currentY = newArgs[6];
                break;
              case 'A':
                currentX = args[5];
                currentY = args[6];
                break;
              case 'z':
              case 'Z':
                currentX = startX;
                currentY = startY;
                break;
            }
            result.push({ type: newType, args: newArgs });
          }
          return result;
        }

        static toString(commands, precision = 3) {
          return commands.map(cmd => {
            const argsStr = cmd.args.map(n => 
              Number.isInteger(n) ? n : parseFloat(n.toFixed(precision))
            ).join(' ');
            return `${cmd.type}${argsStr}`;
          }).join(' ');
        }
      }

      // ========== SVG PATH WARPER ==========
      class SVGPathWarper {
        constructor(warper) {
          this.warper = warper;
        }

        subdivideCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, segments = 16) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const mt = 1 - t;
            const mt2 = mt * mt;
            const mt3 = mt2 * mt;
            const t2 = t * t;
            const t3 = t2 * t;
            
            const x = mt3 * x0 + 3 * mt2 * t * x1 + 3 * mt * t2 * x2 + t3 * x3;
            const y = mt3 * y0 + 3 * mt2 * t * y1 + 3 * mt * t2 * y2 + t3 * y3;
            
            points.push({ x, y });
          }
          return points;
        }

        subdivideQuadraticBezier(x0, y0, x1, y1, x2, y2, segments = 16) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const mt = 1 - t;
            const mt2 = mt * mt;
            const t2 = t * t;
            
            const x = mt2 * x0 + 2 * mt * t * x1 + t2 * x2;
            const y = mt2 * y0 + 2 * mt * t * y1 + t2 * y2;
            
            points.push({ x, y });
          }
          return points;
        }

        subdivideLine(x0, y0, x1, y1, segments) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            points.push({
              x: x0 + (x1 - x0) * t,
              y: y0 + (y1 - y0) * t
            });
          }
          return points;
        }

        approximateArc(x0, y0, rx, ry, xAxisRotation, largeArc, sweep, x1, y1, segments) {
          const phi = xAxisRotation * Math.PI / 180;
          const cosPhi = Math.cos(phi);
          const sinPhi = Math.sin(phi);
          
          const dx = (x0 - x1) / 2;
          const dy = (y0 - y1) / 2;
          const x1p = cosPhi * dx + sinPhi * dy;
          const y1p = -sinPhi * dx + cosPhi * dy;
          
          let rxSq = rx * rx;
          let rySq = ry * ry;
          const x1pSq = x1p * x1p;
          const y1pSq = y1p * y1p;
          
          const lambda = x1pSq / rxSq + y1pSq / rySq;
          if (lambda > 1) {
            rx *= Math.sqrt(lambda);
            ry *= Math.sqrt(lambda);
            rxSq = rx * rx;
            rySq = ry * ry;
          }
          
          let sq = Math.max(0, (rxSq * rySq - rxSq * y1pSq - rySq * x1pSq) / (rxSq * y1pSq + rySq * x1pSq));
          sq = Math.sqrt(sq) * (largeArc === sweep ? -1 : 1);
          
          const cxp = sq * rx * y1p / ry;
          const cyp = -sq * ry * x1p / rx;
          
          const cx = cosPhi * cxp - sinPhi * cyp + (x0 + x1) / 2;
          const cy = sinPhi * cxp + cosPhi * cyp + (y0 + y1) / 2;
          
          const ux = (x1p - cxp) / rx;
          const uy = (y1p - cyp) / ry;
          const vx = (-x1p - cxp) / rx;
          const vy = (-y1p - cyp) / ry;
          
          const n = Math.sqrt(ux * ux + uy * uy);
          let theta1 = Math.acos(Math.max(-1, Math.min(1, ux / n)));
          if (uy < 0) theta1 = -theta1;
          
          const nn = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));
          let dTheta = Math.acos(Math.max(-1, Math.min(1, (ux * vx + uy * vy) / nn)));
          if (ux * vy - uy * vx < 0) dTheta = -dTheta;
          
          if (sweep && dTheta < 0) dTheta += 2 * Math.PI;
          if (!sweep && dTheta > 0) dTheta -= 2 * Math.PI;
          
          const points = [{ x: x0, y: y0 }];
          for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            const angle = theta1 + dTheta * t;
            const xp = rx * Math.cos(angle);
            const yp = ry * Math.sin(angle);
            const x = cosPhi * xp - sinPhi * yp + cx;
            const y = sinPhi * xp + cosPhi * yp + cy;
            points.push({ x, y });
          }
          
          return points;
        }

        transformPoint(x, y) {
          return this.warper.transformPoint(x, y);
        }

        warpPath(pathData, subdivisions = 12) {
          const commands = SVGPathParser.parse(pathData);
          const absolute = SVGPathParser.toAbsolute(commands);
          
          const result = [];
          let currentX = 0, currentY = 0;
          let lastControlX = 0, lastControlY = 0;
          let startX = 0, startY = 0;

          for (const cmd of absolute) {
            const { type, args } = cmd;

            switch (type) {
              case 'M': {
                const warped = this.transformPoint(args[0], args[1]);
                result.push({ type: 'M', args: [warped.x, warped.y] });
                currentX = args[0];
                currentY = args[1];
                startX = currentX;
                startY = currentY;
                lastControlX = currentX;
                lastControlY = currentY;
                break;
              }

              case 'L': {
                const points = this.subdivideLine(currentX, currentY, args[0], args[1], subdivisions);
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                currentX = args[0];
                currentY = args[1];
                lastControlX = currentX;
                lastControlY = currentY;
                break;
              }

              case 'C': {
                const points = this.subdivideCubicBezier(
                  currentX, currentY,
                  args[0], args[1],
                  args[2], args[3],
                  args[4], args[5],
                  subdivisions * 2
                );
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                lastControlX = args[2];
                lastControlY = args[3];
                currentX = args[4];
                currentY = args[5];
                break;
              }

              case 'S': {
                const cx1 = 2 * currentX - lastControlX;
                const cy1 = 2 * currentY - lastControlY;
                const points = this.subdivideCubicBezier(
                  currentX, currentY,
                  cx1, cy1,
                  args[0], args[1],
                  args[2], args[3],
                  subdivisions * 2
                );
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                lastControlX = args[0];
                lastControlY = args[1];
                currentX = args[2];
                currentY = args[3];
                break;
              }

              case 'Q': {
                const points = this.subdivideQuadraticBezier(
                  currentX, currentY,
                  args[0], args[1],
                  args[2], args[3],
                  subdivisions * 2
                );
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                lastControlX = args[0];
                lastControlY = args[1];
                currentX = args[2];
                currentY = args[3];
                break;
              }

              case 'T': {
                const cx = 2 * currentX - lastControlX;
                const cy = 2 * currentY - lastControlY;
                const points = this.subdivideQuadraticBezier(
                  currentX, currentY,
                  cx, cy,
                  args[0], args[1],
                  subdivisions * 2
                );
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                lastControlX = cx;
                lastControlY = cy;
                currentX = args[0];
                currentY = args[1];
                break;
              }

              case 'A': {
                const points = this.approximateArc(
                  currentX, currentY,
                  args[0], args[1], args[2], 
                  args[3] === 1, args[4] === 1,
                  args[5], args[6],
                  subdivisions * 3
                );
                for (let i = 1; i < points.length; i++) {
                  const warped = this.transformPoint(points[i].x, points[i].y);
                  result.push({ type: 'L', args: [warped.x, warped.y] });
                }
                currentX = args[5];
                currentY = args[6];
                lastControlX = currentX;
                lastControlY = currentY;
                break;
              }

              case 'Z': {
                if (currentX !== startX || currentY !== startY) {
                  const points = this.subdivideLine(currentX, currentY, startX, startY, subdivisions);
                  for (let i = 1; i < points.length; i++) {
                    const warped = this.transformPoint(points[i].x, points[i].y);
                    result.push({ type: 'L', args: [warped.x, warped.y] });
                  }
                }
                result.push({ type: 'Z', args: [] });
                currentX = startX;
                currentY = startY;
                break;
              }
            }
          }

          return SVGPathParser.toString(result);
        }
      }

      // ===== END OF PART 2 =====

            // ========== SVG DOCUMENT TRANSFORMER ==========
      class SVGDocumentTransformer {
        constructor(warper, sourceWidth, sourceHeight) {
          this.pathWarper = new SVGPathWarper(warper);
          this.sourceWidth = sourceWidth;
          this.sourceHeight = sourceHeight;
          this.warper = warper;
        }

        transformSVG(svgString, targetWidth, targetHeight) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgString, 'image/svg+xml');
          const svgElement = doc.querySelector('svg');
          
          if (!svgElement) {
            throw new Error('Invalid SVG document');
          }

          const viewBox = svgElement.getAttribute('viewBox');
          let vbWidth = this.sourceWidth;
          let vbHeight = this.sourceHeight;
          let vbX = 0, vbY = 0;
          
          if (viewBox) {
            const parts = viewBox.split(/[\s,]+/).map(Number);
            if (parts.length === 4) {
              vbX = parts[0];
              vbY = parts[1];
              vbWidth = parts[2];
              vbHeight = parts[3];
            }
          } else {
            const w = parseFloat(svgElement.getAttribute('width'));
            const h = parseFloat(svgElement.getAttribute('height'));
            if (w && h) {
              vbWidth = w;
              vbHeight = h;
            }
          }

          const scaleX = this.sourceWidth / vbWidth;
          const scaleY = this.sourceHeight / vbHeight;

          this.transformElement(svgElement, scaleX, scaleY, vbX, vbY);

          svgElement.setAttribute('viewBox', `0 0 ${targetWidth} ${targetHeight}`);
          svgElement.setAttribute('width', targetWidth);
          svgElement.setAttribute('height', targetHeight);
          svgElement.removeAttribute('xmlns:xlink');

          return new XMLSerializer().serializeToString(doc);
        }

        transformElement(element, scaleX, scaleY, offsetX = 0, offsetY = 0) {
          if (element.nodeType !== 1) return;

          const tagName = element.tagName?.toLowerCase();

          if (tagName === 'path') {
            const d = element.getAttribute('d');
            if (d) {
              const scaledPath = this.scalePath(d, scaleX, scaleY, offsetX, offsetY);
              const warpedPath = this.pathWarper.warpPath(scaledPath, 16);
              element.setAttribute('d', warpedPath);
            }
          }

          if (tagName === 'circle') {
            const cx = (parseFloat(element.getAttribute('cx') || 0) - offsetX) * scaleX;
            const cy = (parseFloat(element.getAttribute('cy') || 0) - offsetY) * scaleY;
            const r = parseFloat(element.getAttribute('r') || 0) * Math.min(scaleX, scaleY);
            
            const pathData = this.circleToPath(cx, cy, r);
            const warpedPath = this.pathWarper.warpPath(pathData, 16);
            
            const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', warpedPath);
            this.copyAttributes(element, path, ['cx', 'cy', 'r']);
            element.parentNode.replaceChild(path, element);
            return;
          }

          if (tagName === 'ellipse') {
            const cx = (parseFloat(element.getAttribute('cx') || 0) - offsetX) * scaleX;
            const cy = (parseFloat(element.getAttribute('cy') || 0) - offsetY) * scaleY;
            const rx = parseFloat(element.getAttribute('rx') || 0) * scaleX;
            const ry = parseFloat(element.getAttribute('ry') || 0) * scaleY;
            
            const pathData = this.ellipseToPath(cx, cy, rx, ry);
            const warpedPath = this.pathWarper.warpPath(pathData, 16);
            
            const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', warpedPath);
            this.copyAttributes(element, path, ['cx', 'cy', 'rx', 'ry']);
            element.parentNode.replaceChild(path, element);
            return;
          }

          if (tagName === 'rect') {
            const x = (parseFloat(element.getAttribute('x') || 0) - offsetX) * scaleX;
            const y = (parseFloat(element.getAttribute('y') || 0) - offsetY) * scaleY;
            const w = parseFloat(element.getAttribute('width') || 0) * scaleX;
            const h = parseFloat(element.getAttribute('height') || 0) * scaleY;
            let rx = parseFloat(element.getAttribute('rx') || 0) * scaleX;
            let ry = parseFloat(element.getAttribute('ry') || 0) * scaleY;
            
            if (rx && !ry) ry = rx;
            if (ry && !rx) rx = ry;
            
            const pathData = this.rectToPath(x, y, w, h, rx, ry);
            const warpedPath = this.pathWarper.warpPath(pathData, 16);
            
            const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', warpedPath);
            this.copyAttributes(element, path, ['x', 'y', 'width', 'height', 'rx', 'ry']);
            element.parentNode.replaceChild(path, element);
            return;
          }

          if (tagName === 'line') {
            const x1 = (parseFloat(element.getAttribute('x1') || 0) - offsetX) * scaleX;
            const y1 = (parseFloat(element.getAttribute('y1') || 0) - offsetY) * scaleY;
            const x2 = (parseFloat(element.getAttribute('x2') || 0) - offsetX) * scaleX;
            const y2 = (parseFloat(element.getAttribute('y2') || 0) - offsetY) * scaleY;
            
            const pathData = `M${x1},${y1}L${x2},${y2}`;
            const warpedPath = this.pathWarper.warpPath(pathData, 16);
            
            const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', warpedPath);
            this.copyAttributes(element, path, ['x1', 'y1', 'x2', 'y2']);
            element.parentNode.replaceChild(path, element);
            return;
          }

          if (tagName === 'polygon') {
            const points = element.getAttribute('points');
            if (points) {
              const pathData = this.polygonToPath(points, scaleX, scaleY, offsetX, offsetY);
              const warpedPath = this.pathWarper.warpPath(pathData, 16);
              
              const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
              path.setAttribute('d', warpedPath);
              this.copyAttributes(element, path, ['points']);
              element.parentNode.replaceChild(path, element);
              return;
            }
          }

          if (tagName === 'polyline') {
            const points = element.getAttribute('points');
            if (points) {
              const pathData = this.polylineToPath(points, scaleX, scaleY, offsetX, offsetY);
              const warpedPath = this.pathWarper.warpPath(pathData, 16);
              
              const path = element.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
              path.setAttribute('d', warpedPath);
              this.copyAttributes(element, path, ['points']);
              element.parentNode.replaceChild(path, element);
              return;
            }
          }

          if (tagName === 'text') {
            const x = (parseFloat(element.getAttribute('x') || 0) - offsetX) * scaleX;
            const y = (parseFloat(element.getAttribute('y') || 0) - offsetY) * scaleY;
            const warped = this.warper.transformPoint(x, y);
            element.setAttribute('x', warped.x.toFixed(3));
            element.setAttribute('y', warped.y.toFixed(3));
            
            const fontSize = element.getAttribute('font-size');
            if (fontSize) {
              const size = parseFloat(fontSize);
              if (!isNaN(size)) {
                element.setAttribute('font-size', (size * Math.min(scaleX, scaleY)).toFixed(3));
              }
            }
          }

          if (tagName === 'image') {
            const x = (parseFloat(element.getAttribute('x') || 0) - offsetX) * scaleX;
            const y = (parseFloat(element.getAttribute('y') || 0) - offsetY) * scaleY;
            const w = parseFloat(element.getAttribute('width') || 0) * scaleX;
            const h = parseFloat(element.getAttribute('height') || 0) * scaleY;
            
            const topLeft = this.warper.transformPoint(x, y);
            const topRight = this.warper.transformPoint(x + w, y);
            const bottomLeft = this.warper.transformPoint(x, y + h);
            const bottomRight = this.warper.transformPoint(x + w, y + h);
            
            const minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
            const minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
            const maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
            const maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
            
            element.setAttribute('x', minX.toFixed(3));
            element.setAttribute('y', minY.toFixed(3));
            element.setAttribute('width', (maxX - minX).toFixed(3));
            element.setAttribute('height', (maxY - minY).toFixed(3));
          }

          const children = Array.from(element.children);
          for (const child of children) {
            this.transformElement(child, scaleX, scaleY, offsetX, offsetY);
          }
        }

        scalePath(pathData, scaleX, scaleY, offsetX = 0, offsetY = 0) {
          const commands = SVGPathParser.parse(pathData);
          const scaled = commands.map(cmd => {
            const newArgs = [...cmd.args];
            const type = cmd.type.toUpperCase();
            const isRelative = cmd.type !== cmd.type.toUpperCase();
            
            switch (type) {
              case 'M':
              case 'L':
              case 'T':
                if (isRelative) {
                  newArgs[0] *= scaleX;
                  newArgs[1] *= scaleY;
                } else {
                  newArgs[0] = (newArgs[0] - offsetX) * scaleX;
                  newArgs[1] = (newArgs[1] - offsetY) * scaleY;
                }
                break;
              case 'H':
                if (isRelative) {
                  newArgs[0] *= scaleX;
                } else {
                  newArgs[0] = (newArgs[0] - offsetX) * scaleX;
                }
                break;
              case 'V':
                if (isRelative) {
                  newArgs[0] *= scaleY;
                } else {
                  newArgs[0] = (newArgs[0] - offsetY) * scaleY;
                }
                break;
              case 'C':
                for (let i = 0; i < 6; i += 2) {
                  if (isRelative) {
                    newArgs[i] *= scaleX;
                    newArgs[i + 1] *= scaleY;
                  } else {
                    newArgs[i] = (newArgs[i] - offsetX) * scaleX;
                    newArgs[i + 1] = (newArgs[i + 1] - offsetY) * scaleY;
                  }
                }
                break;
              case 'S':
              case 'Q':
                for (let i = 0; i < 4; i += 2) {
                  if (isRelative) {
                    newArgs[i] *= scaleX;
                    newArgs[i + 1] *= scaleY;
                  } else {
                    newArgs[i] = (newArgs[i] - offsetX) * scaleX;
                    newArgs[i + 1] = (newArgs[i + 1] - offsetY) * scaleY;
                  }
                }
                break;
              case 'A':
                newArgs[0] *= scaleX;
                newArgs[1] *= scaleY;
                if (isRelative) {
                  newArgs[5] *= scaleX;
                  newArgs[6] *= scaleY;
                } else {
                  newArgs[5] = (newArgs[5] - offsetX) * scaleX;
                  newArgs[6] = (newArgs[6] - offsetY) * scaleY;
                }
                break;
            }
            
            return { type: cmd.type, args: newArgs };
          });
          
          return SVGPathParser.toString(scaled);
        }

        circleToPath(cx, cy, r) {
          return `M${cx - r},${cy}` +
                 `A${r},${r} 0 0 1 ${cx},${cy - r}` +
                 `A${r},${r} 0 0 1 ${cx + r},${cy}` +
                 `A${r},${r} 0 0 1 ${cx},${cy + r}` +
                 `A${r},${r} 0 0 1 ${cx - r},${cy}Z`;
        }

        ellipseToPath(cx, cy, rx, ry) {
          return `M${cx - rx},${cy}` +
                 `A${rx},${ry} 0 0 1 ${cx},${cy - ry}` +
                 `A${rx},${ry} 0 0 1 ${cx + rx},${cy}` +
                 `A${rx},${ry} 0 0 1 ${cx},${cy + ry}` +
                 `A${rx},${ry} 0 0 1 ${cx - rx},${cy}Z`;
        }

        rectToPath(x, y, w, h, rx = 0, ry = 0) {
          if (rx === 0 && ry === 0) {
            return `M${x},${y}L${x + w},${y}L${x + w},${y + h}L${x},${y + h}Z`;
          }
          rx = Math.min(rx, w / 2);
          ry = Math.min(ry, h / 2);
          return `M${x + rx},${y}` +
                 `L${x + w - rx},${y}` +
                 `A${rx},${ry} 0 0 1 ${x + w},${y + ry}` +
                 `L${x + w},${y + h - ry}` +
                 `A${rx},${ry} 0 0 1 ${x + w - rx},${y + h}` +
                 `L${x + rx},${y + h}` +
                 `A${rx},${ry} 0 0 1 ${x},${y + h - ry}` +
                 `L${x},${y + ry}` +
                 `A${rx},${ry} 0 0 1 ${x + rx},${y}Z`;
        }

        polygonToPath(points, scaleX, scaleY, offsetX = 0, offsetY = 0) {
          const nums = points.trim().split(/[\s,]+/).map(Number);
          let d = '';
          for (let i = 0; i < nums.length; i += 2) {
            const x = (nums[i] - offsetX) * scaleX;
            const y = (nums[i + 1] - offsetY) * scaleY;
            d += (i === 0 ? 'M' : 'L') + `${x},${y}`;
          }
          return d + 'Z';
        }

        polylineToPath(points, scaleX, scaleY, offsetX = 0, offsetY = 0) {
          const nums = points.trim().split(/[\s,]+/).map(Number);
          let d = '';
          for (let i = 0; i < nums.length; i += 2) {
            const x = (nums[i] - offsetX) * scaleX;
            const y = (nums[i + 1] - offsetY) * scaleY;
            d += (i === 0 ? 'M' : 'L') + `${x},${y}`;
          }
          return d;
        }

        copyAttributes(from, to, exclude = []) {
          for (const attr of from.attributes) {
            if (!exclude.includes(attr.name)) {
              to.setAttribute(attr.name, attr.value);
            }
          }
        }
      }

      // ========== ENHANCED MESH-BASED CANVAS DRAWING (NO WHITE LINES) ==========
      function drawTexturedQuad(ctx, img, 
        sx0, sy0, sx1, sy1, sx2, sy2, sx3, sy3,  // Source quad corners (TL, TR, BR, BL)
        dx0, dy0, dx1, dy1, dx2, dy2, dx3, dy3,  // Destination quad corners
        subDivisions = 2
      ) {
        // Recursively subdivide for better quality
        if (subDivisions > 0) {
          // Calculate midpoints
          const smx01 = (sx0 + sx1) / 2, smy01 = (sy0 + sy1) / 2;
          const smx12 = (sx1 + sx2) / 2, smy12 = (sy1 + sy2) / 2;
          const smx23 = (sx2 + sx3) / 2, smy23 = (sy2 + sy3) / 2;
          const smx30 = (sx3 + sx0) / 2, smy30 = (sy3 + sy0) / 2;
          const smxC = (sx0 + sx1 + sx2 + sx3) / 4, smyC = (sy0 + sy1 + sy2 + sy3) / 4;
          
          const dmx01 = (dx0 + dx1) / 2, dmy01 = (dy0 + dy1) / 2;
          const dmx12 = (dx1 + dx2) / 2, dmy12 = (dy1 + dy2) / 2;
          const dmx23 = (dx2 + dx3) / 2, dmy23 = (dy2 + dy3) / 2;
          const dmx30 = (dx3 + dx0) / 2, dmy30 = (dy3 + dy0) / 2;
          const dmxC = (dx0 + dx1 + dx2 + dx3) / 4, dmyC = (dy0 + dy1 + dy2 + dy3) / 4;
          
          const nextSub = subDivisions - 1;
          
          // Top-left quadrant
          drawTexturedQuad(ctx, img,
            sx0, sy0, smx01, smy01, smxC, smyC, smx30, smy30,
            dx0, dy0, dmx01, dmy01, dmxC, dmyC, dmx30, dmy30, nextSub);
          // Top-right quadrant
          drawTexturedQuad(ctx, img,
            smx01, smy01, sx1, sy1, smx12, smy12, smxC, smyC,
            dmx01, dmy01, dx1, dy1, dmx12, dmy12, dmxC, dmyC, nextSub);
          // Bottom-right quadrant
          drawTexturedQuad(ctx, img,
            smxC, smyC, smx12, smy12, sx2, sy2, smx23, smy23,
            dmxC, dmyC, dmx12, dmy12, dx2, dy2, dmx23, dmy23, nextSub);
          // Bottom-left quadrant
          drawTexturedQuad(ctx, img,
            smx30, smy30, smxC, smyC, smx23, smy23, sx3, sy3,
            dmx30, dmy30, dmxC, dmyC, dmx23, dmy23, dx3, dy3, nextSub);
          return;
        }
        
        // Draw two triangles with slight overlap to prevent seams
        const overlap = 0.5;
        
        // Triangle 1: TL, TR, BL
        drawTexturedTriangleSeamless(ctx, img,
          sx0, sy0, sx1, sy1, sx3, sy3,
          dx0, dy0, dx1, dy1, dx3, dy3, overlap);
        
        // Triangle 2: TR, BR, BL
        drawTexturedTriangleSeamless(ctx, img,
          sx1, sy1, sx2, sy2, sx3, sy3,
          dx1, dy1, dx2, dy2, dx3, dy3, overlap);
      }

      function drawTexturedTriangleSeamless(ctx, img, 
        sx0, sy0, sx1, sy1, sx2, sy2,
        dx0, dy0, dx1, dy1, dx2, dy2,
        overlap = 0.5
      ) {
        ctx.save();
        
        // Expand the clipping region slightly to overlap with neighbors
        const cx = (dx0 + dx1 + dx2) / 3;
        const cy = (dy0 + dy1 + dy2) / 3;
        
        const expandPoint = (x, y) => {
          const vx = x - cx;
          const vy = y - cy;
          const len = Math.sqrt(vx * vx + vy * vy);
          if (len > 0) {
            return {
              x: x + (vx / len) * overlap,
              y: y + (vy / len) * overlap
            };
          }
          return { x, y };
        };
        
        const p0 = expandPoint(dx0, dy0);
        const p1 = expandPoint(dx1, dy1);
        const p2 = expandPoint(dx2, dy2);
        
        ctx.beginPath();
        ctx.moveTo(p0.x, p0.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.closePath();
        ctx.clip();

        const denom = (sx0 * (sy1 - sy2) + sx1 * (sy2 - sy0) + sx2 * (sy0 - sy1));
        
        if (Math.abs(denom) < 0.0001) {
          ctx.restore();
          return;
        }

        const a = (dx0 * (sy1 - sy2) + dx1 * (sy2 - sy0) + dx2 * (sy0 - sy1)) / denom;
        const b = (dx0 * (sx2 - sx1) + dx1 * (sx0 - sx2) + dx2 * (sx1 - sx0)) / denom;
        const c = (dx0 * (sx1 * sy2 - sx2 * sy1) + dx1 * (sx2 * sy0 - sx0 * sy2) + dx2 * (sx0 * sy1 - sx1 * sy0)) / denom;
        const d = (dy0 * (sy1 - sy2) + dy1 * (sy2 - sy0) + dy2 * (sy0 - sy1)) / denom;
        const e = (dy0 * (sx2 - sx1) + dy1 * (sx0 - sx2) + dy2 * (sx1 - sx0)) / denom;
        const f = (dy0 * (sx1 * sy2 - sx2 * sy1) + dy1 * (sx2 * sy0 - sx0 * sy2) + dy2 * (sx0 * sy1 - sx1 * sy0)) / denom;

        ctx.transform(a, d, b, e, c, f);
        
        // Draw with margin to cover seams
        const margin = 1;
        const minX = Math.max(0, Math.min(sx0, sx1, sx2) - margin);
        const minY = Math.max(0, Math.min(sy0, sy1, sy2) - margin);
        const maxX = Math.min(img.width, Math.max(sx0, sx1, sx2) + margin);
        const maxY = Math.min(img.height, Math.max(sy0, sy1, sy2) + margin);
        
        ctx.drawImage(img, 
          minX, minY, maxX - minX, maxY - minY,
          minX, minY, maxX - minX, maxY - minY
        );
        
        ctx.restore();
      }

      function drawWarpWithMesh(localCtx, img, shape, offsetX, offsetY, finalScale, isExport) {
        // Use higher grid resolution for exports to ensure smooth curves
        const gridCols = isExport ? 120 : 50;
        const gridRows = isExport ? 50 : 20;
        const subDivisions = isExport ? 2 : 1;
        
        const warper = new MeshWarper(shape.topPath, shape.bottomPath, img.width, img.height, {
          gridCols: gridCols,
          gridRows: gridRows,
          topIsReversed: shape.topIsReversed,
          bottomIsReversed: shape.bottomIsReversed
        });

        const mesh = warper.getMeshPoints();
        const cellWidth = img.width / gridCols;
        const cellHeight = img.height / gridRows;

        // Draw each cell as a textured quad
        for (let row = 0; row < gridRows; row++) {
          for (let col = 0; col < gridCols; col++) {
            const p00 = mesh[row][col];         // Top-left
            const p01 = mesh[row][col + 1];     // Top-right
            const p10 = mesh[row + 1][col];     // Bottom-left
            const p11 = mesh[row + 1][col + 1]; // Bottom-right

            // Source rectangle from image
            const srcX = col * cellWidth;
            const srcY = row * cellHeight;

            // Transform mesh points to canvas coordinates
            const t00 = { x: p00.x * finalScale + offsetX, y: p00.y * finalScale + offsetY };
            const t01 = { x: p01.x * finalScale + offsetX, y: p01.y * finalScale + offsetY };
            const t10 = { x: p10.x * finalScale + offsetX, y: p10.y * finalScale + offsetY };
            const t11 = { x: p11.x * finalScale + offsetX, y: p11.y * finalScale + offsetY };

            // Draw quad with subdivisions to prevent seams
            drawTexturedQuad(localCtx, img,
              // Source corners: TL, TR, BR, BL
              srcX, srcY,
              srcX + cellWidth, srcY,
              srcX + cellWidth, srcY + cellHeight,
              srcX, srcY + cellHeight,
              // Destination corners: TL, TR, BR, BL
              t00.x, t00.y,
              t01.x, t01.y,
              t11.x, t11.y,
              t10.x, t10.y,
              subDivisions
            );
          }
        }
      }

      // ========== STATE ==========
      let currentImage = null;
      let currentImageDataUrl = null;
      let textureImageDataUrl = null;
      let uploadedSVGContent = null;
      let uploadedSVGDimensions = null;
      let currentView = "bottom";
      let currentShapeType = "round";
      let currentShape = "250ml_round";
      const EXPORT_SCALE = 6;
      let isExporting = false;

      // Zoom state
      let zoomLevel = 1;
      const MIN_ZOOM = 0.25;
      const MAX_ZOOM = 5;
      const ZOOM_STEP = 0.25;

      // Pan state
      let panX = 0;
      let panY = 0;
      let isPanning = false;
      let isSpacePressed = false;
      let lastMouseX = 0;
      let lastMouseY = 0;

      let isViewer3DMinimized = false;
      let isViewer3DExpanded = false;
      let isModelLoaded = false;

      // DOM Elements
      const canvas = document.getElementById("warpCanvas");
      const ctx = canvas.getContext("2d");
      const uploadText = document.getElementById("uploadText");
      const svgBadge = document.getElementById("svgBadge");
      const fileInput = document.getElementById("imageUpload");
      const exportPngBtn = document.getElementById("exportPngBtn");
      const exportVectorSvgBtn = document.getElementById("exportVectorSvgBtn");
      const exportPdfBtn = document.getElementById("exportPdfBtn");
      const shapeTypeSelect = document.getElementById("shapeTypeSelect");
      const shapeSelect = document.getElementById("shapeSelect");
      const viewSelector = document.getElementById("viewSelector");
      
      // Loading elements
      const loadingOverlay = document.getElementById("loadingOverlay");
      const loadingText = document.getElementById("loadingText");
      const loadingSubtext = document.getElementById("loadingSubtext");
      
      // Error popup elements
      const errorOverlay = document.getElementById("errorOverlay");
      const errorTitle = document.getElementById("errorTitle");
      const errorMessage = document.getElementById("errorMessage");
      const errorCloseBtn = document.getElementById("errorCloseBtn");

      // Zoom elements
      const zoomInBtn = document.getElementById("zoomInBtn");
      const zoomOutBtn = document.getElementById("zoomOutBtn");
      const zoomDisplay = document.getElementById("zoomDisplay");
      
      // Pan elements
      const panIndicator = document.getElementById("panIndicator");
      const panIndicatorText = document.getElementById("panIndicatorText");
      const resetPanBtn = document.getElementById("resetPanBtn");

      // 3D Viewer elements
      const viewer3DContainer = document.getElementById("viewer3DContainer");
      const modelViewer = document.getElementById("modelViewer");
      const viewer3DLoading = document.getElementById("viewer3DLoading");
      const viewer3DStatus = document.getElementById("viewer3DStatus");
      const viewer3DToggle = document.getElementById("viewer3DToggle");
      const viewer3DExpand = document.getElementById("viewer3DExpand");

      // ===== END OF PART 3 =====

            // ========== LOADING & ERROR FUNCTIONS ==========
      
      function showLoading(message = "Processing...", subtext = "Please wait") {
        loadingText.textContent = message;
        loadingSubtext.textContent = subtext;
        loadingOverlay.classList.add("show");
        exportPngBtn.disabled = true;
        exportVectorSvgBtn.disabled = true;
        exportPdfBtn.disabled = true;
      }

      function updateLoading(message, subtext = "") {
        loadingText.textContent = message;
        if (subtext) loadingSubtext.textContent = subtext;
      }

      function hideLoading() {
        loadingOverlay.classList.remove("show");
        exportPngBtn.disabled = false;
        exportVectorSvgBtn.disabled = false;
        exportPdfBtn.disabled = false;
        isExporting = false;
      }

      function showError(title, message) {
        errorTitle.textContent = title;
        errorMessage.textContent = message;
        errorOverlay.classList.add("show");
      }

      function hideError() {
        errorOverlay.classList.remove("show");
      }

      errorCloseBtn.addEventListener("click", hideError);

      // ========== DOWNLOAD HELPER ==========
      
      function triggerDownload(blob, filename) {
        return new Promise((resolve, reject) => {
          try {
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            link.style.display = "none";
            document.body.appendChild(link);
            
            setTimeout(() => {
              link.click();
              setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                resolve();
              }, 500);
            }, 100);
          } catch (error) {
            reject(error);
          }
        });
      }

      // ========== ZOOM FUNCTIONS ==========
      
      function canPan() {
        return zoomLevel > 1;
      }

      function updateZoomDisplay() {
        const percentage = Math.round(zoomLevel * 100);
        zoomDisplay.textContent = `${percentage}%`;
        
        zoomInBtn.disabled = zoomLevel >= MAX_ZOOM;
        zoomOutBtn.disabled = zoomLevel <= MIN_ZOOM;
        
        if (canPan()) {
          panIndicator.classList.add("visible");
        } else {
          panIndicator.classList.remove("visible");
          panIndicator.classList.remove("active");
        }
        
        if (panX !== 0 || panY !== 0) {
          resetPanBtn.classList.add("visible");
        } else {
          resetPanBtn.classList.remove("visible");
        }
        
        updateCanvasCursor();
      }

      function updateCanvasCursor() {
        canvas.classList.remove("can-pan", "space-held", "panning");
        
        if (isPanning) {
          canvas.classList.add("panning");
        } else if (isSpacePressed && canPan()) {
          canvas.classList.add("space-held");
        } else if (canPan()) {
          canvas.classList.add("can-pan");
        }
      }

      function zoomIn() {
        if (zoomLevel < MAX_ZOOM) {
          zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
          if (zoomLevel <= 1) { panX = 0; panY = 0; }
          mainDraw();
          updateZoomDisplay();
        }
      }

      function zoomOut() {
        if (zoomLevel > MIN_ZOOM) {
          zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
          if (zoomLevel <= 1) { panX = 0; panY = 0; }
          mainDraw();
          updateZoomDisplay();
        }
      }

      function resetZoom() {
        zoomLevel = 1;
        panX = 0;
        panY = 0;
        mainDraw();
        updateZoomDisplay();
      }

      function resetPan() {
        panX = 0;
        panY = 0;
        mainDraw();
        updateZoomDisplay();
      }

      function handleWheelZoom(event) {
        if (event.ctrlKey || event.metaKey) {
          event.preventDefault();
          if (event.deltaY < 0) zoomIn();
          else zoomOut();
        }
      }

      // ========== PAN FUNCTIONS ==========
      
      function startPan(event) {
        if (!canPan()) return;
        if (!isSpacePressed && event.button !== 1) return;
        
        isPanning = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        
        updateCanvasCursor();
        panIndicator.classList.add("active");
        panIndicatorText.textContent = "Panning...";
        
        event.preventDefault();
      }

      function doPan(event) {
        if (!isPanning) return;
        
        const deltaX = event.clientX - lastMouseX;
        const deltaY = event.clientY - lastMouseY;
        
        panX += deltaX;
        panY += deltaY;
        
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        
        mainDraw();
        updateZoomDisplay();
      }

      function endPan() {
        if (isPanning) {
          isPanning = false;
          updateCanvasCursor();
          panIndicator.classList.remove("active");
          panIndicatorText.textContent = "Hold Space + Drag";
        }
      }

      function handleSpaceDown(event) {
        if (event.code === "Space" && !event.repeat && canPan()) {
          const activeElement = document.activeElement;
          const isInputFocused = activeElement && (
            activeElement.tagName === "INPUT" || 
            activeElement.tagName === "TEXTAREA" || 
            activeElement.tagName === "SELECT"
          );
          
          if (!isInputFocused) {
            event.preventDefault();
            isSpacePressed = true;
            updateCanvasCursor();
            panIndicator.classList.add("active");
            panIndicatorText.textContent = "Click & Drag to Pan";
          }
        }
      }

      function handleSpaceUp(event) {
        if (event.code === "Space") {
          isSpacePressed = false;
          if (!isPanning) {
            panIndicator.classList.remove("active");
            panIndicatorText.textContent = "Hold Space + Drag";
          }
          updateCanvasCursor();
          endPan();
        }
      }

      // Touch support for panning
      let touchStartX = 0;
      let touchStartY = 0;
      let isTouchPanning = false;

      function handleTouchStart(event) {
        if (!canPan()) return;
        if (event.touches.length === 2) {
          isTouchPanning = true;
          const touch = event.touches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          lastMouseX = touchStartX;
          lastMouseY = touchStartY;
          isPanning = true;
          updateCanvasCursor();
          event.preventDefault();
        }
      }

      function handleTouchMove(event) {
        if (!isTouchPanning || !isPanning) return;
        if (event.touches.length === 2) {
          const touch = event.touches[0];
          const deltaX = touch.clientX - lastMouseX;
          const deltaY = touch.clientY - lastMouseY;
          
          panX += deltaX;
          panY += deltaY;
          
          lastMouseX = touch.clientX;
          lastMouseY = touch.clientY;
          
          mainDraw();
          updateZoomDisplay();
          event.preventDefault();
        }
      }

      function handleTouchEnd() {
        isTouchPanning = false;
        endPan();
      }

      // ========== SHAPE DEFINITIONS ==========
      const shapeTypes = {
        round: "Round",
        round_square: "Round Square",
        rectangle: "Rectangle",
        sweet_box: "Sweet Box",
        sweet_box_te: "Sweet Box TE",
      };

      const COMMON_LABEL_MATERIALS = [
        "Bottom", "Label", "Wrap", "Decal", "Logo", "Sticker",
        "label", "bottom", "wrap", "decal", "logo", "sticker",
        "Material", "Material.001", "Material.002", "Material_0"
      ];

      const allBottleShapes = {
        "250ml_round": {
          type: "round",
          view: "bottom",
          name: "250ml Round",
          width: 837,
          height: 244,
          uploadDimensions: { width: 2908, height: 448 },
          path: "M1.37,162.42L73.32,242.27C283.84,56.41,576.84,75.5,764.01,242.27L835.96,162.42C597.61,-50.29,240.85,-53.15,1.37,162.42Z",
          topPath: "M 835.96,162.42 C 597.61,-50.29 240.85,-53.15 1.37,162.42",
          bottomPath: "M 73.32,242.27 C 283.84,56.41 576.84,75.5 764.01,242.27",
          topIsReversed: true,
          bottomIsReversed: false,
          modelPath: "./assets/models/250ml_round_t.glb",
          targetMaterials: ["Texture"],
        },
        "300ml_round": {
          type: "round",
          view: "bottom",
          name: "300ml Round",
          width: 986.98,
          height: 332.17,
          uploadDimensions: { width: 2906, height: 448 },
          path: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0l-5.32,1.98-45.71-122.15,6.01-2.21c286.86-105.52,601.92-105.52,888.78,0l6.04,2.15-45.75,122.2-5.3-1.98Z",
          topPath: "M49.08,172.19c286.86-105.52,601.92-105.52,888.78,0",
          bottomPath: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0",
          topIsReversed: false,
          bottomIsReversed: true,
          modelPath: "./assets/models/300ml_round_container.glb",
          targetMaterials: ["Texture"],
        },
        "450ml_round_square": {
          type: "round_square",
          view: "bottom",
          name: "450ml Round Square",
          width: 879.22,
          height: 276.16,
          uploadDimensions: { width: 2923, height: 748 },
          path: "M93.16,274.8l9.48-5.52c16.09-9.47,32.49-18.51,49.08-27.07l8.02-3.94c9.34-4.49,18.91-8.56,28.62-12.17,8.99-3.3,18.11-6.37,27.27-9.18,15.76-4.79,31.65-9.33,47.56-13.57,18.8-5.19,37.79-9.92,56.83-14.14l9.07-1.84,8.27-1.5c10.82-1.83,21.76-3.15,32.71-3.94,9.81-.7,19.67-1.17,29.5-1.4,21.39-.46,42.86-.55,64.25-.29,12.27.09,24.57.47,36.82,1.13,13.8.7,27.58,2.2,41.2,4.49,9.2,1.6,18.39,3.47,27.48,5.58,15.63,3.68,31.23,7.65,46.71,11.9,15.9,4.24,31.78,8.78,47.53,13.56,9.16,2.81,18.27,5.88,27.27,9.19,9.71,3.61,19.29,7.68,28.62,12.17,9.02,4.37,17.96,8.98,26.74,13.81,13.78,7.6,26.32,14.75,39.8,22.73l1.29.69.73-1.14,89.79-152.32.72-1.21-1.24-.73-13.45-7.78-11.35-6.29-11.74-6.21-12.33-6.23c-19.27-9.43-38.9-18.29-58.72-26.51l-16-6.53-15.31-5.99-14.52-5.41-13.83-4.89c-23.21-8.03-46.9-14.84-70.84-20.34-19.14-4.36-38.5-8.07-57.9-11.09-11.43-1.81-22.92-3.44-34.4-4.91l-19.63-2.35c-18.16-2.05-36.45-3.52-54.71-4.39-9.72-.44-19.47-.67-29.2-.68h-3.78s-3.78,0-3.78,0l-6.4.04-12.28.25-10.51.39-15.42.86c-13.11.89-26.23,2.07-39.29,3.53l-19.63,2.35c-24.07,3.03-48.1,6.91-71.9,11.61-30.91,6.14-61.46,14.42-91.24,24.74l-13.82,4.89-14.52,5.41-15.31,5.99-16,6.53c-19.82,8.21-39.45,17.07-58.72,26.51l-12.33,6.22-11.74,6.21-11.35,6.29-13.43,7.79-1.22.71.71,1.24,89.83,152.25.7,1.19,1.24-.69Z",
          topPath:
            "M1.22,123.55l13.43-7.79l11.35-6.29l11.74-6.21l12.33-6.22c19.27-9.44,38.9-18.3,58.72-26.51l16-6.53l15.31-5.99l14.52-5.41l13.82-4.89c30.78-10.32,60.33-18.6,91.24-24.74c24.07-4.7,47.83-8.58,71.9-11.61l19.63-2.35c13.06-1.46,26.18-2.64,39.29-3.53l15.42-.86l10.51-.39l12.28-.25l6.4-.04h3.78s3.78,0,3.78,0c9.73.01,19.48.24,29.2.68c18.26.87,36.55,2.34,54.71,4.39l19.63,2.35c11.48,1.47,22.97,3.1,34.4,4.91c19.4,3.02,38.76,6.73,57.9,11.09c23.94,5.5,47.63,12.31,70.84,20.34l13.83,4.89l14.52,5.41l15.31,5.99l16,6.53c19.82,8.22,39.45,17.08,58.72,26.51l12.33,6.23l11.74,6.21l11.35,6.29l13.45,7.78",
          bottomPath:
            "M93.16,274.8l9.48-5.52c16.09-9.47,32.49-18.51,49.08-27.07l8.02-3.94c9.34-4.49,18.91-8.56,28.62-12.17,8.99-3.3,18.11-6.37,27.27-9.18,15.76-4.79,31.65-9.33,47.56-13.57,18.8-5.19,37.79-9.92,56.83-14.14l9.07-1.84,8.27-1.5c10.82-1.83,21.76-3.15,32.71-3.94,9.81-.7,19.67-1.17,29.5-1.4,21.39-.46,42.86-.55,64.25-.29,12.27.09,24.57.47,36.82,1.13,13.8.7,27.58,2.2,41.2,4.49,9.2,1.6,18.39,3.47,27.48,5.58,15.63,3.68,31.23,7.65,46.71,11.9,15.9,4.24,31.78,8.78,47.53,13.56,9.16,2.81,18.27,5.88,27.27,9.19,9.71,3.61,19.29,7.68,28.62,12.17,9.02,4.37,17.96,8.98,26.74,13.81,13.78,7.6,26.32,14.75,39.8,22.73",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/500gms&450ml container_t.glb",
          targetMaterials: [" Texture"],
        },
      };

      const shapeGroups = {};
      const keyToGroupName = {};

      // ========== 3D VIEWER FUNCTIONS ==========

      function showStatus(message) {
        viewer3DStatus.textContent = message;
        viewer3DStatus.classList.remove("hidden");
      }

      function hideStatus() {
        viewer3DStatus.classList.add("hidden");
      }

      function show3DLoading() {
        viewer3DLoading.classList.remove("hidden");
        hideStatus();
      }

      function hide3DLoading() {
        viewer3DLoading.classList.add("hidden");
      }

      function findBestMaterial(viewer, preferredNames) {
        if (!viewer.model || !viewer.model.materials) return null;
        const materials = viewer.model.materials;

        for (const name of preferredNames) {
          const mat = materials.find(m => m.name === name);
          if (mat) return mat;
        }

        for (const name of preferredNames) {
          const mat = materials.find(m => m.name.toLowerCase() === name.toLowerCase());
          if (mat) return mat;
        }

        for (const name of preferredNames) {
          const mat = materials.find(m => 
            m.name.toLowerCase().includes(name.toLowerCase()) ||
            name.toLowerCase().includes(m.name.toLowerCase())
          );
          if (mat) return mat;
        }

        for (const name of COMMON_LABEL_MATERIALS) {
          const mat = materials.find(m => m.name === name);
          if (mat) return mat;
        }

        return materials.length > 0 ? materials[0] : null;
      }

      async function applyTextureToMaterial(viewer, material, textureUrl) {
        if (!viewer || !material || !textureUrl) return false;

        try {
          const texture = await viewer.createTexture(textureUrl);
          if (!texture) return false;

          const pbr = material.pbrMetallicRoughness;

          if (typeof pbr.setBaseColorFactor === 'function') {
            pbr.setBaseColorFactor([1.0, 1.0, 1.0, 1.0]);
          }

          if (pbr.baseColorTexture) {
            pbr.baseColorTexture.setTexture(texture);
          }

          try {
            const texInfo = pbr.baseColorTexture;
            if (texInfo && texInfo.texture && texInfo.texture.sampler) {
              const sampler = texInfo.texture.sampler;
              const GL_CLAMP_TO_EDGE = 33071;
              const GL_LINEAR = 9729;
              const GL_LINEAR_MIPMAP_LINEAR = 9987;

              if (typeof sampler.setWrapS === 'function') {
                sampler.setWrapS(GL_CLAMP_TO_EDGE);
                sampler.setWrapT(GL_CLAMP_TO_EDGE);
              }
              if (typeof sampler.setMinFilter === 'function') {
                sampler.setMinFilter(GL_LINEAR_MIPMAP_LINEAR);
              }
              if (typeof sampler.setMagFilter === 'function') {
                sampler.setMagFilter(GL_LINEAR);
              }
            }
          } catch (e) {
            console.warn("Could not set sampler settings:", e);
          }

          if (typeof pbr.setMetallicFactor === 'function') {
            pbr.setMetallicFactor(0.0);
          }
          if (typeof pbr.setRoughnessFactor === 'function') {
            pbr.setRoughnessFactor(0.5);
          }

          return true;
        } catch (error) {
          console.error("Error applying texture:", error);
          return false;
        }
      }

      async function applyTextureToModel() {
        if (!modelViewer.model || !textureImageDataUrl) return;

        const shape = getCurrentShape();
        if (!shape) return;

        const materialNames = shape.targetMaterials || COMMON_LABEL_MATERIALS;
        const material = findBestMaterial(modelViewer, materialNames);

        if (!material) return;

        await applyTextureToMaterial(modelViewer, material, textureImageDataUrl);
      }

      async function load3DModel(shape) {
        isModelLoaded = false;

        if (!shape || !shape.modelPath) {
          showStatus("No 3D model");
          modelViewer.src = "";
          return;
        }

        show3DLoading();
        modelViewer.src = shape.modelPath + "?t=" + Date.now();
      }

      modelViewer.addEventListener("load", async () => {
        isModelLoaded = true;
        hide3DLoading();
        hideStatus();

        let attempts = 0;
        while (!modelViewer.model && attempts < 100) {
          await new Promise(r => setTimeout(r, 50));
          attempts++;
        }

        if (textureImageDataUrl && modelViewer.model) {
          await applyTextureToModel();
        }
      });

      modelViewer.addEventListener("error", () => {
        hide3DLoading();
        showStatus("Load failed");
        isModelLoaded = false;
      });

      modelViewer.addEventListener("progress", (event) => {
        const progress = event.detail.totalProgress;
        if (progress < 1) {
          const percent = Math.round(progress * 100);
          viewer3DLoading.querySelector("span").textContent = `${percent}%`;
        }
      });

      function toggleViewer3D() {
        isViewer3DMinimized = !isViewer3DMinimized;
        viewer3DContainer.classList.toggle("minimized", isViewer3DMinimized);
        
        if (isViewer3DMinimized) {
          isViewer3DExpanded = false;
          viewer3DContainer.classList.remove("expanded");
        }
      }

      function toggleViewer3DExpand() {
        if (isViewer3DMinimized) return;
        isViewer3DExpanded = !isViewer3DExpanded;
        viewer3DContainer.classList.toggle("expanded", isViewer3DExpanded);
      }

      viewer3DToggle.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleViewer3D();
      });

      viewer3DExpand.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleViewer3DExpand();
      });

      viewer3DContainer.addEventListener("click", (e) => {
        if (isViewer3DMinimized && !e.target.closest('.viewer3D-btn')) {
          toggleViewer3D();
        }
      });

      // ========== SHAPE FUNCTIONS ==========

      function preProcessShapes() {
        for (const [key, shape] of Object.entries(allBottleShapes)) {
          shape.topSampler = new PathSampler(shape.topPath);
          shape.bottomSampler = new PathSampler(shape.bottomPath);

          if (!shapeGroups[shape.name]) {
            shapeGroups[shape.name] = {};
          }
          shapeGroups[shape.name][shape.view] = key;
          keyToGroupName[key] = shape.name;
        }
      }

      function getCurrentShape() {
        return currentShape ? allBottleShapes[currentShape] : null;
      }

      function updateUploadPlaceholder() {
        const shape = getCurrentShape();
        if (shape && shape.uploadDimensions) {
          const { width, height } = shape.uploadDimensions;
          uploadText.innerHTML = `<span class="text-xs text-slate-500 block text-center">${width}  ${height}px</span>Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>`;
        } else {
          uploadText.innerHTML = 'Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>';
        }
        svgBadge.classList.remove("visible");
      }

      function toggleViewSelector() {
        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          viewSelector.classList.remove("hidden");
        } else {
          viewSelector.classList.add("hidden");
        }
      }

      function syncSweetBoxViewControls() {
        const topRadioDiv = document.getElementById("viewTopRadio").parentElement;
        const bottomRadioDiv = document.getElementById("viewBottomRadio").parentElement;

        if ((currentShapeType !== "sweet_box" && currentShapeType !== "sweet_box_te") || !currentShape) {
          topRadioDiv.classList.add("hidden");
          bottomRadioDiv.classList.add("hidden");
          return;
        }

        const groupName = keyToGroupName[currentShape];
        const group = shapeGroups[groupName];

        topRadioDiv.classList.toggle("hidden", !group.top);
        bottomRadioDiv.classList.toggle("hidden", !group.bottom);

        if (currentShape.endsWith("_top")) {
          currentView = "top";
          document.getElementById("viewTopRadio").checked = true;
        } else if (currentShape.endsWith("_bottom")) {
          currentView = "bottom";
          document.getElementById("viewBottomRadio").checked = true;
        }
      }

      function updateSpecificShapeSelector() {
        shapeSelect.innerHTML = "";
        let firstShapeKey = null;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const uniqueNames = new Set();
          for (const key in allBottleShapes) {
            const shape = allBottleShapes[key];
            if (shape.type === currentShapeType && !uniqueNames.has(shape.name)) {
              uniqueNames.add(shape.name);
              const option = document.createElement("option");
              option.value = shape.name;
              option.textContent = shape.name;
              shapeSelect.appendChild(option);
            }
          }
          if (shapeSelect.options.length > 0) {
            const selectedName = shapeSelect.options[0].value;
            shapeSelect.value = selectedName;
            const group = shapeGroups[selectedName];
            firstShapeKey = group.top || group.bottom;
          }
        } else {
          for (const [key, shape] of Object.entries(allBottleShapes)) {
            if (shape.type === currentShapeType) {
              const option = document.createElement("option");
              option.value = key;
              option.textContent = shape.name;
              shapeSelect.appendChild(option);
              if (!firstShapeKey) firstShapeKey = key;
            }
          }
          if (firstShapeKey) shapeSelect.value = firstShapeKey;
        }

        currentShape = firstShapeKey;
        syncSweetBoxViewControls();

        const shape = getCurrentShape();
        load3DModel(shape);
      }

      function populateShapeTypes() {
        shapeTypeSelect.innerHTML = "";
        for (const [key, name] of Object.entries(shapeTypes)) {
          const option = document.createElement("option");
          option.value = key;
          option.textContent = name;
          shapeTypeSelect.appendChild(option);
        }
        shapeTypeSelect.value = currentShapeType;
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
      }

      // ========== MAIN DRAWING FUNCTIONS ==========

      function renderImageContent(localCtx, targetW, targetH, isExport, exportScale, clearBackground, applyPan = false) {
        if (clearBackground) localCtx.clearRect(0, 0, targetW, targetH);

        const shape = getCurrentShape();
        if (!shape) return;

        const margin = isExport ? 0 : 20;
        const scaleXFit = (targetW - 2 * margin) / shape.width;
        const scaleYFit = (targetH - 2 * margin) / shape.height;
        let finalScale = isExport ? exportScale : Math.min(scaleXFit, scaleYFit);
        
        if (!isExport) {
          finalScale *= zoomLevel;
        }

        const scaledW = shape.width * finalScale;
        const scaledH = shape.height * finalScale;
        let offsetX = (targetW - scaledW) / 2;
        let offsetY = (targetH - scaledH) / 2;
        
        if (applyPan && !isExport) {
          offsetX += panX;
          offsetY += panY;
        }

        const path = new Path2D(shape.path);
        const transformMatrix = new DOMMatrix();
        transformMatrix.translateSelf(offsetX, offsetY);
        transformMatrix.scaleSelf(finalScale, finalScale);

        if (currentImage) {
          localCtx.save();
          localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
          localCtx.clip(path);
          localCtx.setTransform(1, 0, 0, 1, 0, 0);

          if (!isExport && window.devicePixelRatio && localCtx === ctx) {
            localCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
          }

          let imageOffsetX = 0;
          const needsHorizontalShift = ["500ml_round", "750ml_round", "1000ml_round", "450ml_round_square", "500ml_round_square"].includes(currentShape);
          if (needsHorizontalShift) imageOffsetX = isExport ? 22 : 5;

          if (shape.type === "rectangle" || shape.view === "top" || shape.type === "sweet_box_te") {
            let drawOffsetX = offsetX + imageOffsetX;
            let drawOffsetY = offsetY;
            let drawScaledW = scaledW;
            let drawScaledH = scaledH;

            if (currentShape === "250ml_sweet_box_te_bottom") {
              const scaleFactor = 1.029;
              drawScaledW = scaledW * scaleFactor;
              drawScaledH = scaledH * scaleFactor;
              drawOffsetX = offsetX - (drawScaledW - scaledW) / 2 + imageOffsetX;
              drawOffsetY = offsetY - (drawScaledH - scaledH) / 2;
            }

            localCtx.drawImage(currentImage, drawOffsetX, drawOffsetY, drawScaledW, drawScaledH);
          } else {
            // Use enhanced mesh-based warping for curved shapes
            drawWarpWithMesh(localCtx, currentImage, shape, offsetX + imageOffsetX, offsetY, finalScale, isExport);
          }

          localCtx.restore();
        } else {
          localCtx.save();
          localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
          localCtx.fillStyle = "#eee";
          localCtx.fill(path);
          localCtx.restore();
        }
      }

      function drawShape(localCtx, targetW, targetH, isExport, exportScale, clearBackground, applyPan = false) {
        localCtx.imageSmoothingEnabled = true;
        localCtx.imageSmoothingQuality = "high";

        renderImageContent(localCtx, targetW, targetH, isExport, exportScale, clearBackground, applyPan);

        const shape = getCurrentShape();
        if (!shape) {
          if (clearBackground) localCtx.clearRect(0, 0, targetW * (window.devicePixelRatio || 1), targetH * (window.devicePixelRatio || 1));
          const dpr = window.devicePixelRatio || 1;
          localCtx.font = `${16 * dpr}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
          localCtx.textAlign = "center";
          localCtx.fillStyle = "#9ca3af";
          localCtx.fillText("No shapes available for this type/view.", (targetW * dpr) / 2, (targetH * dpr) / 2);
          return;
        }

        const margin = isExport ? 0 : 20;
        const scaleXFit = (targetW - 2 * margin) / shape.width;
        const scaleYFit = (targetH - 2 * margin) / shape.height;
        let finalScale = isExport ? exportScale : Math.min(scaleXFit, scaleYFit);
        
        if (!isExport) {
          finalScale *= zoomLevel;
        }
        
        const scaledW = shape.width * finalScale;
        const scaledH = shape.height * finalScale;
        let offsetX = (targetW - scaledW) / 2;
        let offsetY = (targetH - scaledH) / 2;
        
        if (applyPan && !isExport) {
          offsetX += panX;
          offsetY += panY;
        }

        const path = new Path2D(shape.path);
        const transformMatrix = new DOMMatrix();
        transformMatrix.translateSelf(offsetX, offsetY);
        transformMatrix.scaleSelf(finalScale, finalScale);

        // Draw outline (preview only)
        localCtx.save();
        localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
        if (!isExport) {
          localCtx.strokeStyle = "#ed312c";
          localCtx.lineWidth = 2 / finalScale;
          localCtx.stroke(path);
        }
        localCtx.restore();
      }

      function mainDraw() {
        resizeCanvas();
        drawShape(ctx, canvas.clientWidth, canvas.clientHeight, false, 1, true, true);
      }

      // ===== END OF PART 4 =====

            // ========== IMAGE UPLOAD HANDLING ==========

      async function processUploadedImage(img, shape) {
        updateLoading("Applying to shape...", "Almost done");
        
        currentImage = img;

        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.drawImage(img, 0, 0);
        currentImageDataUrl = tempCanvas.toDataURL("image/png");
        textureImageDataUrl = currentImageDataUrl;

        await new Promise(r => setTimeout(r, 100));

        if (isModelLoaded && modelViewer.model) {
          updateLoading("Applying 3D texture...", "Finishing up");
          await applyTextureToModel();
        }

        mainDraw();
        hideLoading();
      }

      async function handleImageUpload(event) {
        const file = (event.target.files || [])[0];

        if (!file) {
          currentImage = null;
          currentImageDataUrl = null;
          textureImageDataUrl = null;
          uploadedSVGContent = null;
          uploadedSVGDimensions = null;
          mainDraw();
          updateUploadPlaceholder();
          const shape = getCurrentShape();
          if (shape) load3DModel(shape);
          return;
        }

        showLoading("Loading image...", "Reading file");

        const isSVG = file.type === "image/svg+xml" || file.name.toLowerCase().endsWith(".svg");
        const shape = getCurrentShape();

        if (isSVG) {
          const reader = new FileReader();
          reader.onload = async function (e) {
            updateLoading("Processing SVG...", "Parsing file");
            
            let svgText = e.target.result;
            
            // Store original SVG content for vector export
            uploadedSVGContent = svgText;
            
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
            const svgElement = svgDoc.querySelector("svg");

            const parserError = svgDoc.querySelector("parsererror");
            if (parserError || !svgElement) {
              hideLoading();
              showError("Invalid SVG File", "The SVG file could not be parsed. Please make sure it's a valid SVG file.");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              uploadedSVGContent = null;
              uploadedSVGDimensions = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
              return;
            }

            let width = svgElement.getAttribute("width");
            let height = svgElement.getAttribute("height");
            const viewBox = svgElement.getAttribute("viewBox");

            if (width) width = parseFloat(width);
            if (height) height = parseFloat(height);

            if ((!width || !height) && viewBox) {
              const vbParts = viewBox.split(/[\s,]+/).map(parseFloat);
              if (vbParts.length === 4) {
                if (!width) width = vbParts[2];
                if (!height) height = vbParts[3];
              }
            }

            if (!width || !height || isNaN(width) || isNaN(height)) {
              if (shape && shape.uploadDimensions) {
                width = width || shape.uploadDimensions.width;
                height = height || shape.uploadDimensions.height;
              } else {
                width = width || 1000;
                height = height || 1000;
              }
            }

            // Store SVG dimensions for vector export
            uploadedSVGDimensions = { width, height };

            svgElement.setAttribute("width", width);
            svgElement.setAttribute("height", height);
            if (!viewBox) svgElement.setAttribute("viewBox", `0 0 ${width} ${height}`);

            svgText = new XMLSerializer().serializeToString(svgDoc);
            
            // Update stored SVG content with normalized version
            uploadedSVGContent = svgText;
            
            const blob = new Blob([svgText], { type: "image/svg+xml" });
            const url = URL.createObjectURL(blob);

            const img = new Image();
            img.onload = async () => {
              if (shape && shape.uploadDimensions) {
                const expectedWidth = shape.uploadDimensions.width;
                const expectedHeight = shape.uploadDimensions.height;

                if (width < expectedWidth || height < expectedHeight) {
                  hideLoading();
                  showError(
                    "Image Too Small",
                    `The image dimensions (${Math.round(width)}  ${Math.round(height)}px) are smaller than required.\n\nMinimum size: ${expectedWidth}  ${expectedHeight}px`
                  );
                  currentImage = null;
                  currentImageDataUrl = null;
                  textureImageDataUrl = null;
                  uploadedSVGContent = null;
                  uploadedSVGDimensions = null;
                  fileInput.value = "";
                  updateUploadPlaceholder();
                  URL.revokeObjectURL(url);
                  mainDraw();
                  return;
                }
              }

              const fullName = file.name;
              const dotIndex = fullName.lastIndexOf(".");
              let name = dotIndex !== -1 ? fullName.substring(0, dotIndex) : fullName;
              const ext = dotIndex !== -1 ? fullName.substring(dotIndex) : "";
              if (name.length > 12) name = name.substring(0, 12) + "...";
              uploadText.textContent = `${name}${ext}`;
              
              // Show SVG badge
              svgBadge.classList.add("visible");

              await processUploadedImage(img, shape);
              URL.revokeObjectURL(url);
            };

            img.onerror = () => {
              URL.revokeObjectURL(url);
              hideLoading();
              showError("Failed to Load SVG", "The SVG file could not be loaded. Please try a different file.");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              uploadedSVGContent = null;
              uploadedSVGDimensions = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
            };

            img.src = url;
          };

          reader.onerror = () => {
            hideLoading();
            showError("File Read Error", "Failed to read the SVG file. Please try again.");
            fileInput.value = "";
            updateUploadPlaceholder();
            mainDraw();
          };

          reader.readAsText(file);
        } else {
          // Clear SVG content for non-SVG files
          uploadedSVGContent = null;
          uploadedSVGDimensions = null;
          svgBadge.classList.remove("visible");
          
          const reader = new FileReader();
          reader.onload = async function (e) {
            updateLoading("Processing image...", "Loading pixels");
            
            const img = new Image();
            img.onload = async () => {
              if (shape && shape.uploadDimensions) {
                const expectedWidth = shape.uploadDimensions.width;
                const expectedHeight = shape.uploadDimensions.height;

                if (img.width < expectedWidth || img.height < expectedHeight) {
                  hideLoading();
                  showError(
                    "Image Too Small",
                    `The image dimensions (${img.width}  ${img.height}px) are smaller than required.\n\nMinimum size: ${expectedWidth}  ${expectedHeight}px`
                  );
                  currentImage = null;
                  currentImageDataUrl = null;
                  textureImageDataUrl = null;
                  fileInput.value = "";
                  updateUploadPlaceholder();
                  mainDraw();
                  return;
                }
              }

              const fullName = file.name;
              const dotIndex = fullName.lastIndexOf(".");
              let name = dotIndex !== -1 ? fullName.substring(0, dotIndex) : fullName;
              const ext = dotIndex !== -1 ? fullName.substring(dotIndex) : "";
              if (name.length > 12) name = name.substring(0, 12) + "...";
              uploadText.textContent = `${name}${ext}`;

              await processUploadedImage(img, shape);
            };
            img.onerror = () => {
              hideLoading();
              showError("Failed to Load Image", "The image file could not be loaded. Please try a different file format (PNG, JPG, etc.).");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
            };
            img.src = e.target.result;
          };
          
          reader.onerror = () => {
            hideLoading();
            showError("File Read Error", "Failed to read the image file. Please try again.");
            fileInput.value = "";
            updateUploadPlaceholder();
            mainDraw();
          };
          
          reader.readAsDataURL(file);
        }
      }

      // ========== VIEW & SHAPE CHANGE HANDLERS ==========

      async function handleViewChange(event) {
        const newView = event.target.value;
        currentView = newView;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const groupName = shapeSelect.value;
          const group = shapeGroups[groupName];
          const newShapeKey = group[newView];

          if (newShapeKey) {
            currentShape = newShapeKey;
            updateUploadPlaceholder();
            currentImage = null;
            currentImageDataUrl = null;
            textureImageDataUrl = null;
            uploadedSVGContent = null;
            uploadedSVGDimensions = null;
            fileInput.value = "";

            const shape = getCurrentShape();
            load3DModel(shape);
            mainDraw();
          }
        }
      }

      async function handleShapeTypeChange(event) {
        currentShapeType = event.target.value;
        toggleViewSelector();
        updateSpecificShapeSelector();
        updateUploadPlaceholder();
        currentImage = null;
        currentImageDataUrl = null;
        textureImageDataUrl = null;
        uploadedSVGContent = null;
        uploadedSVGDimensions = null;
        fileInput.value = "";
        // Reset zoom and pan when changing shape type
        zoomLevel = 1;
        panX = 0;
        panY = 0;
        updateZoomDisplay();
        mainDraw();
      }

      async function handleShapeChange(event) {
        const selectedValue = event.target.value;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const group = shapeGroups[selectedValue];
          currentShape = group.top || group.bottom;
        } else {
          currentShape = selectedValue;
        }

        syncSweetBoxViewControls();
        updateUploadPlaceholder();
        currentImage = null;
        currentImageDataUrl = null;
        textureImageDataUrl = null;
        uploadedSVGContent = null;
        uploadedSVGDimensions = null;
        fileInput.value = "";
        // Reset zoom and pan when changing shape
        zoomLevel = 1;
        panX = 0;
        panY = 0;
        updateZoomDisplay();

        const shape = getCurrentShape();
        load3DModel(shape);
        mainDraw();
      }

      // ===== END OF PART 5 =====

            // ========== EXPORT FUNCTIONS ==========

      // Upscale image for better quality export
      function upscaleImage(img, targetWidth, targetHeight) {
        return new Promise((resolve) => {
          const upscaleCanvas = document.createElement("canvas");
          upscaleCanvas.width = targetWidth;
          upscaleCanvas.height = targetHeight;
          const upscaleCtx = upscaleCanvas.getContext("2d");
          
          upscaleCtx.imageSmoothingEnabled = true;
          upscaleCtx.imageSmoothingQuality = "high";
          upscaleCtx.drawImage(img, 0, 0, targetWidth, targetHeight);
          
          const upscaledImg = new Image();
          upscaledImg.onload = () => resolve(upscaledImg);
          upscaledImg.src = upscaleCanvas.toDataURL("image/png", 1.0);
        });
      }

      async function exportPNG() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }

        isExporting = true;
        showLoading("Exporting PNG...", "Generating high-resolution image");

        await new Promise(r => setTimeout(r, 50));

        try {
          updateLoading("Exporting PNG...", "Upscaling image");
          
          // Upscale the source image if needed for better quality
          const targetImgWidth = shape.uploadDimensions ? shape.uploadDimensions.width * 2 : currentImage.width * 2;
          const targetImgHeight = shape.uploadDimensions ? shape.uploadDimensions.height * 2 : currentImage.height * 2;
          
          let processedImage = currentImage;
          if (currentImage.width < targetImgWidth || currentImage.height < targetImgHeight) {
            processedImage = await upscaleImage(currentImage, 
              Math.max(currentImage.width, targetImgWidth), 
              Math.max(currentImage.height, targetImgHeight)
            );
          }
          
          // Temporarily swap currentImage for export
          const originalImage = currentImage;
          currentImage = processedImage;
          
          updateLoading("Exporting PNG...", "Creating canvas");
          
          const exportWidth = shape.width * EXPORT_SCALE;
          const exportHeight = shape.height * EXPORT_SCALE;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const exportCtx = exportCanvas.getContext("2d", { alpha: true });

          // Clear with transparent background
          exportCtx.clearRect(0, 0, exportWidth, exportHeight);

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PNG...", "Rendering high-quality mesh");

          drawShape(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, false, false);
          
          // Restore original image
          currentImage = originalImage;

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PNG...", "Generating file");

          const blob = await new Promise((resolve, reject) => {
            exportCanvas.toBlob(
              (b) => {
                if (b) resolve(b);
                else reject(new Error("Failed to create blob"));
              },
              "image/png",
              1.0
            );
          });

          updateLoading("Exporting PNG...", "Starting download");
          
          await triggerDownload(blob, `${currentShape}_Wrap.png`);
          
          hideLoading();
        } catch (error) {
          console.error("Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the PNG file. Please try again.");
        }
      }

      // ========== SVG EXPORT (Vector or Rasterized based on input) ==========
      
      function createRasterizedSVGString() {
        const shape = getCurrentShape();
        if (!shape) return null;
        
        const exportWidth = shape.width * EXPORT_SCALE;
        const exportHeight = shape.height * EXPORT_SCALE;
        const exportCanvas = document.createElement("canvas");
        exportCanvas.width = exportWidth;
        exportCanvas.height = exportHeight;
        const exportCtx = exportCanvas.getContext("2d", { alpha: true });
        
        exportCtx.clearRect(0, 0, exportWidth, exportHeight);
        renderImageContent(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, false, false);
        
        const rasterData = exportCanvas.toDataURL("image/png");
        const svgContent = `<image x="0" y="0" width="${shape.width}" height="${shape.height}" href="${rasterData}" preserveAspectRatio="none" />`;

        return `<?xml version="1.0" encoding="UTF-8"?>
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
     viewBox="0 0 ${shape.width} ${shape.height}" 
     width="${shape.width}" height="${shape.height}">
${svgContent}
</svg>`;
      }

      async function exportSVG() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }

        isExporting = true;
        
        // Check if we have vector SVG content to export
        if (uploadedSVGContent) {
          // Export as vector SVG
          showLoading("Exporting Vector SVG...", "Preparing transformation");

          try {
            await new Promise(r => setTimeout(r, 50));
            
            // Get source dimensions
            const sourceWidth = uploadedSVGDimensions?.width || shape.uploadDimensions?.width || 1000;
            const sourceHeight = uploadedSVGDimensions?.height || shape.uploadDimensions?.height || 1000;
            
            updateLoading("Exporting Vector SVG...", "Building high-resolution mesh");
            
            // Create warper with very high resolution for smooth curves
            const warper = new MeshWarper(
              shape.topPath, 
              shape.bottomPath, 
              sourceWidth,
              sourceHeight,
              {
                gridCols: 150,  // Very high resolution for smooth vector output
                gridRows: 60,
                topIsReversed: shape.topIsReversed,
                bottomIsReversed: shape.bottomIsReversed
              }
            );

            await new Promise(r => setTimeout(r, 50));
            updateLoading("Exporting Vector SVG...", "Transforming paths");

            const transformer = new SVGDocumentTransformer(
              warper,
              sourceWidth,
              sourceHeight
            );

            const transformedSVG = transformer.transformSVG(
              uploadedSVGContent, 
              shape.width, 
              shape.height
            );
            
            await new Promise(r => setTimeout(r, 50));
            updateLoading("Exporting Vector SVG...", "Starting download");
            
            const blob = new Blob([transformedSVG], { type: "image/svg+xml;charset=utf-8" });
            await triggerDownload(blob, `${currentShape}_Wrap.svg`);
            
            hideLoading();
          } catch (error) {
            console.error("Vector SVG export error:", error);
            hideLoading();
            showError("Vector Export Failed", "Failed to transform the SVG paths. Falling back to rasterized export.\n\nThe file may have complex or unsupported elements.");
            
            // Fallback to rasterized export
            isExporting = true;
            await exportRasterizedSVG();
          }
        } else {
          // Export as rasterized SVG for non-SVG uploads
          await exportRasterizedSVG();
        }
      }

      async function exportRasterizedSVG() {
        showLoading("Exporting SVG...", "Creating rasterized SVG");

        await new Promise(r => setTimeout(r, 50));

        try {
          updateLoading("Exporting SVG...", "Generating content");
          
          const svgString = createRasterizedSVGString();
          if (!svgString) {
            throw new Error("Failed to create SVG content");
          }

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting SVG...", "Starting download");

          const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
          await triggerDownload(blob, `${currentShape}_Wrap.svg`);
          
          hideLoading();
        } catch (error) {
          console.error("Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the SVG file. Please try again.");
        }
      }

      // ========== PDF EXPORT ==========
      async function exportPDF() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }
        
        // Check if jsPDF is loaded
        if (typeof window.jspdf === 'undefined') {
          showError("Library Error", "PDF library not loaded. Please refresh the page and try again.");
          return;
        }

        isExporting = true;
        showLoading("Exporting PDF...", "Creating document");

        await new Promise(r => setTimeout(r, 50));

        try {
          const { jsPDF } = window.jspdf;
          
          updateLoading("Exporting PDF...", "Rendering high-quality image");
          
          // Create high-resolution canvas with transparency
          const exportWidth = shape.width * EXPORT_SCALE;
          const exportHeight = shape.height * EXPORT_SCALE;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const exportCtx = exportCanvas.getContext("2d", { alpha: true });
          
          // Clear with transparent background
          exportCtx.clearRect(0, 0, exportWidth, exportHeight);
          
          // Draw only the shape content (no background)
          renderImageContent(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, false, false);

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PDF...", "Generating PDF");

          // Get image data as PNG to preserve transparency
          const imgData = exportCanvas.toDataURL('image/png');
          
          // Create PDF with exact dimensions
          const pdf = new jsPDF({
            orientation: shape.width > shape.height ? 'landscape' : 'portrait',
            unit: 'pt',
            format: [shape.width, shape.height],
            compress: true
          });
          
          // Add the transparent PNG image
          pdf.addImage(imgData, 'PNG', 0, 0, shape.width, shape.height, undefined, 'FAST');
          
          // Add metadata
          pdf.setProperties({
            title: `${currentShape}_Wrap`,
            subject: 'Label Wrap Export - Transparent Background',
            creator: 'Terra Tech Packs',
            keywords: 'label, wrap, packaging, transparent'
          });

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PDF...", "Starting download");

          // Save the PDF
          pdf.save(`${currentShape}_Wrap.pdf`);
          
          await new Promise(r => setTimeout(r, 500));
          
          hideLoading();
        } catch (error) {
          console.error("PDF Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the PDF file. Please try again.");
        }
      }

      // ========== EVENT LISTENERS ==========
      
      // Window resize
      window.addEventListener("resize", debounce(mainDraw, 150));
      
      // File input
      fileInput.addEventListener("input", handleImageUpload);
      
      // Export buttons
      exportPngBtn.addEventListener("click", exportPNG);
      exportVectorSvgBtn.addEventListener("click", exportSVG);
      exportPdfBtn.addEventListener("click", exportPDF);
      
      // Shape selectors
      shapeTypeSelect.addEventListener("change", handleShapeTypeChange);
      shapeSelect.addEventListener("change", handleShapeChange);
      
      // View radio buttons
      document.querySelectorAll('input[name="view_type"]').forEach((radio) => {
        radio.addEventListener("change", handleViewChange);
      });

      // Zoom controls
      zoomInBtn.addEventListener("click", zoomIn);
      zoomOutBtn.addEventListener("click", zoomOut);
      zoomDisplay.addEventListener("click", resetZoom);
      resetPanBtn.addEventListener("click", resetPan);
      canvas.addEventListener("wheel", handleWheelZoom, { passive: false });

      // Pan controls - Mouse
      canvas.addEventListener("mousedown", startPan);
      window.addEventListener("mousemove", doPan);
      window.addEventListener("mouseup", endPan);
      window.addEventListener("mouseleave", endPan);

      // Pan controls - Touch
      canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
      canvas.addEventListener("touchend", handleTouchEnd);
      canvas.addEventListener("touchcancel", handleTouchEnd);

      // Pan controls - Keyboard (Space)
      window.addEventListener("keydown", handleSpaceDown);
      window.addEventListener("keyup", handleSpaceUp);

      // Handle window blur to reset space state
      window.addEventListener("blur", () => {
        isSpacePressed = false;
        endPan();
        updateCanvasCursor();
      });

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey || e.metaKey) {
          if (e.key === "p") {
            e.preventDefault();
            exportPNG();
          } else if (e.key === "s") {
            e.preventDefault();
            exportSVG();
          } else if (e.key === "=" || e.key === "+") {
            e.preventDefault();
            zoomIn();
          } else if (e.key === "-") {
            e.preventDefault();
            zoomOut();
          } else if (e.key === "0") {
            e.preventDefault();
            resetZoom();
          }
        }
      });

      // Drag and drop for file upload
      const fileUploadLabel = document.querySelector(".file-upload-label");
      fileUploadLabel.addEventListener("dragover", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.add("dragover");
      });
      fileUploadLabel.addEventListener("dragleave", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.remove("dragover");
      });
      fileUploadLabel.addEventListener("drop", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.remove("dragover");
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          fileInput.files = e.dataTransfer.files;
          fileInput.dispatchEvent(new Event("input", { bubbles: true }));
        }
      });

      // ========== INITIALIZATION ==========
      function initializeApp() {
        preProcessShapes();
        populateShapeTypes();
        toggleViewSelector();
        updateSpecificShapeSelector();
        updateUploadPlaceholder();
        updateZoomDisplay();
        mainDraw();
      }

      initializeApp();
    </script>
  </body>
</html>