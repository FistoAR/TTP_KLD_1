<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Terra Tech Packs KLD</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.3.0/model-viewer.min.js"></script>
  <style>
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .spinner { animation: spin 0.8s linear infinite; }
    model-viewer { --poster-color: transparent; --progress-bar-color: #3b82f6; }
    
    .file-upload-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }
    
    .file-upload-wrapper input[type=file] {
      position: absolute;
      left: -9999px;
    }
    
    .file-upload-label {
      display: block;
      cursor: pointer;
    }
    
    .file-type-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      padding: 2px 6px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: bold;
      color: white;
      z-index: 10;
    }
    
    .svg-badge { background-color: #10b981; }
    .ai-badge { background-color: #f59e0b; }
    .png-badge { background-color: #3b82f6; }
    .jpg-badge { background-color: #8b5cf6; }
  </style>
</head>
<body class="bg-slate-100 flex flex-col h-screen overflow-hidden font-sans">
  
  <!-- Header -->
  <div class="bg-white shadow-md z-10 relative">
    <img src="./assets/terratechpacks.png" alt="Terra Tech Packs" 
         class="absolute left-4 top-1/2 -translate-y-1/2 h-8 object-contain z-50 hidden sm:block" />
    
    <div class="container mx-auto pt-4 pb-3 flex justify-center items-end flex-wrap gap-x-6 gap-y-4">
      <div class="flex flex-col">
        <label for="shapeTypeSelect" class="text-xs font-semibold text-slate-600 mb-1">Shape Type:</label>
        <select id="shapeTypeSelect" 
                class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm 
                       focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 
                       transition cursor-pointer"></select>
      </div>
      
      <div class="flex flex-col">
        <label for="shapeSelect" class="text-xs font-semibold text-slate-600 mb-1">Shape:</label>
        <select id="shapeSelect" 
                class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm 
                       focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 
                       transition cursor-pointer"></select>
      </div>
      
      <div id="viewSelector" class="hidden self-end pb-1">
        <div class="flex flex-col gap-1">
          <div class="radio-container">
            <input type="radio" id="viewTopRadio" name="view_type" value="top" 
                   class="cursor-pointer accent-blue-600" />
            <label for="viewTopRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Top</label>
          </div>
          <div class="radio-container">
            <input type="radio" id="viewBottomRadio" name="view_type" value="bottom" checked 
                   class="cursor-pointer accent-blue-600" />
            <label for="viewBottomRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Bottom</label>
          </div>
        </div>
      </div>
      
      <div class="flex flex-col relative">
        <label for="imageUpload" class="text-xs font-semibold text-slate-600 mb-1">Upload Label:</label>
        <div class="file-upload-wrapper">
          <label id="uploadLabel" class="file-upload-label h-12 min-w-[180px] flex items-center justify-center px-5 bg-slate-50 
                        border-2 border-dashed border-slate-400 rounded-lg cursor-pointer 
                        hover:border-blue-500 transition relative" for="imageUpload">
            <input type="file" id="imageUpload" class="hidden" accept=".svg,.ai,.png,.jpg,.jpeg" />
            <small id="uploadText" class="font-medium text-slate-700">
              Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>
            </small>
            <span id="fileTypeBadge" class="file-type-badge hidden"></span>
          </label>
        </div>
        <!-- <div class="text-xs text-slate-500 mt-1">SVG, AI, PNG, JPG supported</div> -->
      </div>
      
      <button id="exportPngBtn" 
              class="export h-12 px-6 bg-blue-600 text-white font-semibold rounded-lg 
                     hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed">
        Export PNG
      </button>
      <button id="exportSvgBtn" 
              class="export h-12 px-6 bg-purple-600 text-white font-semibold rounded-lg 
                     hover:bg-purple-700 transition disabled:opacity-50 disabled:cursor-not-allowed">
        Export SVG
      </button>
      <button id="exportPdfBtn" 
              class="export h-12 px-6 bg-red-700 text-white font-semibold rounded-lg 
                     hover:bg-red-800 transition disabled:opacity-50 disabled:cursor-not-allowed">
        Export PDF
      </button>
    </div>
  </div>

  <!-- Main Content Area -->
  <div class="flex-grow p-4 md:p-6 flex items-center justify-center relative overflow-hidden">
    
    <div id="svgContainer" class="w-full h-full bg-white rounded-lg shadow-sm flex items-center justify-center relative overflow-auto">
      <svg id="mainSvg" class="max-w-full max-h-full" preserveAspectRatio="xMidYMid meet">
        <defs id="svgDefs"></defs>
        <g id="backgroundLayer" class="layer"></g>
        <g id="imageLayer" class="layer"></g>
        <g id="outlineLayer" class="layer"></g>
      </svg>
    </div>
    
    <!-- Zoom Controls -->
    <div class="absolute bottom-4 left-4 flex flex-col gap-2 z-40">
      <div class="flex bg-white rounded-lg shadow-md border border-slate-200 overflow-hidden">
        <button id="zoomInBtn" class="w-9 h-9 flex items-center justify-center hover:bg-slate-100 transition" title="Zoom In">
          <svg class="w-5 h-5 fill-slate-600" viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
        </button>
        <div class="w-px bg-slate-200"></div>
        <button id="zoomOutBtn" class="w-9 h-9 flex items-center justify-center hover:bg-slate-100 transition" title="Zoom Out">
          <svg class="w-5 h-5 fill-slate-600" viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
        </button>
      </div>
      <button id="zoomDisplay" class="bg-white rounded-lg shadow-md border border-slate-200 px-3 py-1.5 
                                       text-xs font-semibold text-slate-600 hover:bg-slate-100 transition" 
              title="Reset zoom">100%</button>
      <button id="resetViewBtn" class="hidden bg-white rounded-lg shadow-md border border-slate-200 px-3 py-1.5 
                                        text-xs font-medium text-slate-600 hover:bg-slate-100 transition 
                                        items-center gap-1" title="Reset view">
        <svg class="w-3.5 h-3.5 fill-current" viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
        Reset
      </button>
    </div>
    
    <!-- 3D Viewer -->
    <div id="viewer3DContainer" class="absolute top-3 right-3 w-48 h-48 bg-gradient-to-br from-slate-800 to-slate-900 
                                        rounded-xl shadow-lg overflow-hidden z-50 border border-white/10 
                                        transition-all duration-300 hover:shadow-xl">
      <div class="absolute top-1.5 right-1.5 flex gap-1 z-10 opacity-0 hover:opacity-100 transition-opacity"
           id="viewer3DControls">
        <button id="viewer3DExpand" class="w-6 h-6 bg-black/60 rounded flex items-center justify-center 
                                           hover:bg-blue-600/80 transition" title="Expand">
          <svg class="w-3.5 h-3.5 fill-white" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
        </button>
        <button id="viewer3DToggle" class="w-6 h-6 bg-black/60 rounded flex items-center justify-center 
                                           hover:bg-blue-600/80 transition" title="Minimize">
          <svg class="w-3.5 h-3.5 fill-white" viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
        </button>
      </div>
      
      <div id="viewer3DLoading" class="absolute inset-0 flex flex-col items-center justify-center z-5">
        <div class="w-5 h-5 border-2 border-slate-600/30 border-t-blue-500 rounded-full spinner"></div>
        <span class="text-slate-500 text-[11px] mt-1.5">Loading...</span>
      </div>
      
      <div id="viewer3DStatus" class="hidden absolute inset-0 flex items-center justify-center 
                                       text-slate-500 text-[11px] text-center p-2"></div>
      
      <model-viewer id="modelViewer" alt="3D preview" camera-controls auto-rotate 
                    rotation-per-second="30deg" exposure="1.0" shadow-intensity="1" 
                    environment-image="neutral" interaction-prompt="none"
                    class="w-full h-full"></model-viewer>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="fixed inset-0 bg-black/60 backdrop-blur-sm hidden items-center 
                                   justify-center z-[1000] flex-col">
    <div class="bg-white px-12 py-8 rounded-2xl shadow-2xl flex flex-col items-center gap-4">
      <div class="w-12 h-12 border-4 border-slate-200 border-t-blue-500 rounded-full spinner"></div>
      <div id="loadingText" class="text-slate-700 text-base font-medium">Processing...</div>
      <div id="loadingSubtext" class="text-slate-400 text-sm">Please wait</div>
    </div>
  </div>

  <!-- Error Modal -->
  <div id="errorOverlay" class="fixed inset-0 bg-black/50 backdrop-blur-sm hidden items-center 
                                 justify-center z-[1001]">
    <div class="bg-white px-8 py-6 rounded-2xl shadow-2xl max-w-sm w-11/12 text-center animate-[popIn_0.2s_ease-out]">
      <div class="w-14 h-14 bg-red-50 rounded-full flex items-center justify-center mx-auto mb-4">
        <svg class="w-7 h-7 fill-red-500" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
      </div>
      <h3 id="errorTitle" class="text-slate-800 text-lg font-semibold mb-2">Error</h3>
      <p id="errorMessage" class="text-slate-500 text-sm leading-relaxed mb-5 whitespace-pre-line">Something went wrong.</p>
      <button id="errorCloseBtn" class="bg-blue-500 text-white px-8 py-2.5 rounded-lg text-sm font-medium 
                                        hover:bg-blue-600 transition">OK</button>
    </div>
  </div>

  <!-- SCRIPT PART 1: Core Classes and Utilities -->
  <script type="module">
// ========== CACHE MANAGER ==========
class CacheManager {
  constructor() {
    this.cache = new Map();
    this.maxSize = 100;
  }

  generateKey(prefix, ...args) {
    return `${prefix}:${JSON.stringify(args)}`;
  }

  get(key) {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return null;
  }

  set(key, value) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }

  clear() {
    this.cache.clear();
  }
}

const debounce = (fn, wait = 150) => {
  let t;
  return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
};

const cache = new CacheManager();

// ========== PATH SAMPLER CLASS ==========
class PathSampler {
  constructor(pathData) {
    this.path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    this.path.setAttribute("d", pathData);
    this.length = this.path.getTotalLength();
  }
  getPointAt(t) {
    return this.path.getPointAtLength(this.length * Math.max(0, Math.min(1, t)));
  }
}

// ========== MESH WARPER CLASS ==========
class MeshWarper {
  constructor(topPath, bottomPath, srcWidth, srcHeight, options = {}) {
    this.topSampler = new PathSampler(topPath);
    this.bottomSampler = new PathSampler(bottomPath);
    this.srcWidth = srcWidth;
    this.srcHeight = srcHeight;
    this.cols = options.gridCols || 50;
    this.rows = options.gridRows || 20;
    this.topReversed = options.topIsReversed || false;
    this.bottomReversed = options.bottomIsReversed || false;
    this.mesh = this.buildMesh();
  }

  buildMesh() {
    const mesh = [];
    for (let row = 0; row <= this.rows; row++) {
      const rowPts = [];
      const v = row / this.rows;
      for (let col = 0; col <= this.cols; col++) {
        const u = col / this.cols;
        const tTop = this.topReversed ? 1 - u : u;
        const tBot = this.bottomReversed ? 1 - u : u;
        const top = this.topSampler.getPointAt(tTop);
        const bot = this.bottomSampler.getPointAt(tBot);
        rowPts.push({
          x: top.x + (bot.x - top.x) * v,
          y: top.y + (bot.y - top.y) * v,
          u, v
        });
      }
      mesh.push(rowPts);
    }
    return mesh;
  }

  transformPoint(srcX, srcY) {
    const u = Math.max(0, Math.min(1, srcX / this.srcWidth));
    const v = Math.max(0, Math.min(1, srcY / this.srcHeight));
    
    const colF = u * this.cols;
    const rowF = v * this.rows;
    const col = Math.min(Math.floor(colF), this.cols - 1);
    const row = Math.min(Math.floor(rowF), this.rows - 1);
    const cFrac = colF - col;
    const rFrac = rowF - row;
    
    const p00 = this.mesh[row][col];
    const p01 = this.mesh[row][col + 1];
    const p10 = this.mesh[row + 1][col];
    const p11 = this.mesh[row + 1][col + 1];
    
    return {
      x: (1 - cFrac) * (1 - rFrac) * p00.x + cFrac * (1 - rFrac) * p01.x +
         (1 - cFrac) * rFrac * p10.x + cFrac * rFrac * p11.x,
      y: (1 - cFrac) * (1 - rFrac) * p00.y + cFrac * (1 - rFrac) * p01.y +
         (1 - cFrac) * rFrac * p10.y + cFrac * rFrac * p11.y
    };
  }
}

// ========== SVG PATH UTILITIES ==========
const SVGPathUtils = {
  parse(d) {
    const cmds = [];
    const regex = /([MmLlHhVvCcSsQqTtAaZz])([^MmLlHhVvCcSsQqTtAaZz]*)/g;
    let m;
    while ((m = regex.exec(d))) {
      const type = m[1];
      const args = m[2].trim().match(/-?(?:\d+\.?\d*|\.\d+)(?:[eE][-+]?\d+)?/g)?.map(Number) || [];
      cmds.push({ type, args });
    }
    return cmds;
  },

  toAbsolute(cmds) {
    const result = [];
    let cx = 0, cy = 0, sx = 0, sy = 0;
    
    for (const { type, args } of cmds) {
      const newArgs = [...args];
      let newType = type.toUpperCase();
      const isRel = type !== newType;
      
      switch (type.toUpperCase()) {
        case 'M':
          if (isRel) { newArgs[0] += cx; newArgs[1] += cy; }
          cx = newArgs[0]; cy = newArgs[1]; sx = cx; sy = cy;
          break;
        case 'L': case 'T':
          if (isRel) { newArgs[0] += cx; newArgs[1] += cy; }
          cx = newArgs[0]; cy = newArgs[1];
          break;
        case 'H':
          if (isRel) newArgs[0] += cx;
          newArgs[1] = cy; cx = newArgs[0]; newType = 'L';
          break;
        case 'V':
          if (isRel) newArgs[0] += cy;
          newArgs.unshift(cx); cy = newArgs[1]; newType = 'L';
          break;
        case 'C':
          if (isRel) for (let i = 0; i < 6; i += 2) { newArgs[i] += cx; newArgs[i+1] += cy; }
          cx = newArgs[4]; cy = newArgs[5];
          break;
        case 'S': case 'Q':
          if (isRel) for (let i = 0; i < 4; i += 2) { newArgs[i] += cx; newArgs[i+1] += cy; }
          cx = newArgs[type.toUpperCase() === 'S' ? 2 : 2]; 
          cy = newArgs[type.toUpperCase() === 'S' ? 3 : 3];
          break;
        case 'A':
          if (isRel) { newArgs[5] += cx; newArgs[6] += cy; }
          cx = newArgs[5]; cy = newArgs[6];
          break;
        case 'Z':
          cx = sx; cy = sy;
          break;
      }
      result.push({ type: newType, args: newArgs });
    }
    return result;
  },

  toString(cmds, precision = 3) {
    return cmds.map(c => c.type + c.args.map(n => 
      Number.isInteger(n) ? n : parseFloat(n.toFixed(precision))
    ).join(' ')).join(' ');
  },

  subdivideLine(x0, y0, x1, y1, segs) {
    const pts = [];
    for (let i = 0; i <= segs; i++) {
      const t = i / segs;
      pts.push({ x: x0 + (x1 - x0) * t, y: y0 + (y1 - y0) * t });
    }
    return pts;
  },

  subdivideCubic(x0, y0, x1, y1, x2, y2, x3, y3, segs) {
    const pts = [];
    for (let i = 0; i <= segs; i++) {
      const t = i / segs, mt = 1 - t;
      pts.push({
        x: mt*mt*mt*x0 + 3*mt*mt*t*x1 + 3*mt*t*t*x2 + t*t*t*x3,
        y: mt*mt*mt*y0 + 3*mt*mt*t*y1 + 3*mt*t*t*y2 + t*t*t*y3
      });
    }
    return pts;
  },

  subdivideQuad(x0, y0, x1, y1, x2, y2, segs) {
    const pts = [];
    for (let i = 0; i <= segs; i++) {
      const t = i / segs, mt = 1 - t;
      pts.push({
        x: mt*mt*x0 + 2*mt*t*x1 + t*t*x2,
        y: mt*mt*y0 + 2*mt*t*y1 + t*t*y2
      });
    }
    return pts;
  }
};

// ========== SVG PATH WARPER ==========
class SVGPathWarper {
  constructor(warper) { this.warper = warper; }

  warp(pathData, subdivisions = 12) {
    const cmds = SVGPathUtils.toAbsolute(SVGPathUtils.parse(pathData));
    const result = [];
    let cx = 0, cy = 0, sx = 0, sy = 0, lcx = 0, lcy = 0;

    for (const { type, args } of cmds) {
      switch (type) {
        case 'M': {
          const w = this.warper.transformPoint(args[0], args[1]);
          result.push({ type: 'M', args: [w.x, w.y] });
          cx = args[0]; cy = args[1]; sx = cx; sy = cy; lcx = cx; lcy = cy;
          break;
        }
        case 'L': {
          const pts = SVGPathUtils.subdivideLine(cx, cy, args[0], args[1], subdivisions);
          for (let i = 1; i < pts.length; i++) {
            const w = this.warper.transformPoint(pts[i].x, pts[i].y);
            result.push({ type: 'L', args: [w.x, w.y] });
          }
          cx = args[0]; cy = args[1]; lcx = cx; lcy = cy;
          break;
        }
        case 'C': {
          const pts = SVGPathUtils.subdivideCubic(cx, cy, args[0], args[1], args[2], args[3], args[4], args[5], subdivisions * 2);
          for (let i = 1; i < pts.length; i++) {
            const w = this.warper.transformPoint(pts[i].x, pts[i].y);
            result.push({ type: 'L', args: [w.x, w.y] });
          }
          lcx = args[2]; lcy = args[3]; cx = args[4]; cy = args[5];
          break;
        }
        case 'S': {
          const c1x = 2 * cx - lcx, c1y = 2 * cy - lcy;
          const pts = SVGPathUtils.subdivideCubic(cx, cy, c1x, c1y, args[0], args[1], args[2], args[3], subdivisions * 2);
          for (let i = 1; i < pts.length; i++) {
            const w = this.warper.transformPoint(pts[i].x, pts[i].y);
            result.push({ type: 'L', args: [w.x, w.y] });
          }
          lcx = args[0]; lcy = args[1]; cx = args[2]; cy = args[3];
          break;
        }
        case 'Q': {
          const pts = SVGPathUtils.subdivideQuad(cx, cy, args[0], args[1], args[2], args[3], subdivisions * 2);
          for (let i = 1; i < pts.length; i++) {
            const w = this.warper.transformPoint(pts[i].x, pts[i].y);
            result.push({ type: 'L', args: [w.x, w.y] });
          }
          lcx = args[0]; lcy = args[1]; cx = args[2]; cy = args[3];
          break;
        }
        case 'T': {
          const c1x = 2 * cx - lcx, c1y = 2 * cy - lcy;
          const pts = SVGPathUtils.subdivideQuad(cx, cy, c1x, c1y, args[0], args[1], subdivisions * 2);
          for (let i = 1; i < pts.length; i++) {
            const w = this.warper.transformPoint(pts[i].x, pts[i].y);
            result.push({ type: 'L', args: [w.x, w.y] });
          }
          lcx = c1x; lcy = c1y; cx = args[0]; cy = args[1];
          break;
        }
        case 'Z': {
          if (cx !== sx || cy !== sy) {
            const pts = SVGPathUtils.subdivideLine(cx, cy, sx, sy, subdivisions);
            for (let i = 1; i < pts.length; i++) {
              const w = this.warper.transformPoint(pts[i].x, pts[i].y);
              result.push({ type: 'L', args: [w.x, w.y] });
            }
          }
          result.push({ type: 'Z', args: [] });
          cx = sx; cy = sy;
          break;
        }
      }
    }
    
    return SVGPathUtils.toString(result);
  }
}

// ========== IMPROVED LAYER EXTRACTOR ==========
class LayerExtractor {
  static extractLayers(svgString) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgString, 'image/svg+xml');
    const svg = doc.querySelector('svg');
    if (!svg) return { layers: [], defs: '', viewBox: null, width: null, height: null };

    const layers = [];
    const defs = svg.querySelector('defs');
    const defsStr = defs ? new XMLSerializer().serializeToString(defs) : '';
    
    // Get SVG dimensions
    let width = parseFloat(svg.getAttribute('width'));
    let height = parseFloat(svg.getAttribute('height'));
    const vb = svg.getAttribute('viewBox');
    
    if ((!width || !height) && vb) {
      const parts = vb.split(/[\s,]+/).map(Number);
      if (parts.length === 4) {
        width = width || parts[2];
        height = height || parts[3];
      }
    }

    // Find all layer-like groups
    const findLayers = (parent, depth = 0) => {
      const children = Array.from(parent.children);
      
      for (const child of children) {
        if (child.tagName.toLowerCase() === 'defs') continue;
        
        const id = child.getAttribute('id') || '';
        const dataName = child.getAttribute('data-name') || '';
        const inkscapeLabel = child.getAttribute('inkscape:label') || '';
        
        // Check if this is a layer
        const isLayer = child.tagName.toLowerCase() === 'g' && (
          id.toLowerCase().includes('layer') ||
          dataName.toLowerCase().includes('layer') ||
          inkscapeLabel ||
          child.hasAttribute('data-type') ||
          (depth === 0 && child.tagName.toLowerCase() === 'g')
        );

        if (isLayer || (depth === 0 && child.tagName.toLowerCase() !== 'g')) {
          const layerId = id || dataName || inkscapeLabel || `layer_${layers.length}`;
          const layerName = (inkscapeLabel || dataName || id || `Layer ${layers.length + 1}`)
            .replace(/[_-]/g, ' ')
            .replace(/layer\s*/i, '')
            .trim() || `Layer ${layers.length + 1}`;
          
          // Clone the element to preserve it
          const clonedElement = child.cloneNode(true);
          
          layers.push({
            id: layerId,
            name: layerName,
            element: clonedElement,
            content: new XMLSerializer().serializeToString(clonedElement),
            zIndex: layers.length
          });
        } else if (child.tagName.toLowerCase() === 'g') {
          // Recurse into non-layer groups
          findLayers(child, depth + 1);
        }
      }
    };

    findLayers(svg);

    // If no layers found, treat all content as single layer
    if (layers.length === 0) {
      let content = '';
      for (const child of svg.children) {
        if (child.tagName.toLowerCase() !== 'defs') {
          content += new XMLSerializer().serializeToString(child);
        }
      }
      layers.push({
        id: 'content',
        name: 'Content',
        element: null,
        content: content,
        zIndex: 0
      });
    }

    return { 
      layers, 
      defs: defsStr, 
      viewBox: vb,
      width: width || 1000,
      height: height || 1000
    };
  }

  // Extract individual layer as standalone SVG
  static layerToSVG(layer, width, height, defs = '') {
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">
      ${defs}
      ${layer.content}
    </svg>`;
  }
}

// ========== IMPROVED SVG DOCUMENT TRANSFORMER ==========
class SVGDocTransformer {
  constructor(warper, srcW, srcH) {
    this.pathWarper = new SVGPathWarper(warper);
    this.warper = warper;
    this.srcW = srcW;
    this.srcH = srcH;
  }

  // Transform a single layer
  transformLayer(layerContent, targetW, targetH, defs = '') {
    const svgWrapper = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${this.srcW} ${this.srcH}" width="${this.srcW}" height="${this.srcH}">${defs}${layerContent}</svg>`;
    return this.transform(svgWrapper, targetW, targetH);
  }

  transform(svgString, targetW, targetH) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgString, 'image/svg+xml');
    const svg = doc.querySelector('svg');
    if (!svg) throw new Error('Invalid SVG');

    let vbW = this.srcW, vbH = this.srcH, vbX = 0, vbY = 0;
    const vb = svg.getAttribute('viewBox');
    if (vb) {
      const parts = vb.split(/[\s,]+/).map(Number);
      if (parts.length === 4) [vbX, vbY, vbW, vbH] = parts;
    } else {
      const w = parseFloat(svg.getAttribute('width'));
      const h = parseFloat(svg.getAttribute('height'));
      if (w && h) { vbW = w; vbH = h; }
    }

    const scaleX = this.srcW / vbW;
    const scaleY = this.srcH / vbH;
    
    this.transformElement(svg, scaleX, scaleY, vbX, vbY);
    
    svg.setAttribute('viewBox', `0 0 ${targetW} ${targetH}`);
    svg.setAttribute('width', targetW);
    svg.setAttribute('height', targetH);
    
    return new XMLSerializer().serializeToString(doc);
  }

  transformElement(el, scX, scY, offX = 0, offY = 0) {
    if (el.nodeType !== 1) return;
    const tag = el.tagName?.toLowerCase();

    // Skip defs
    if (tag === 'defs') return;

    if (tag === 'path') {
      const d = el.getAttribute('d');
      if (d) {
        const scaled = this.scalePath(d, scX, scY, offX, offY);
        el.setAttribute('d', this.pathWarper.warp(scaled, 16));
      }
    } else if (tag === 'circle' || tag === 'ellipse' || tag === 'rect' || 
               tag === 'line' || tag === 'polygon' || tag === 'polyline') {
      const pathData = this.shapeToPath(el, scX, scY, offX, offY);
      if (pathData) {
        const warpedPath = this.pathWarper.warp(pathData, 16);
        const newPath = el.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
        newPath.setAttribute('d', warpedPath);
        this.copyAttrs(el, newPath);
        el.parentNode?.replaceChild(newPath, el);
        return;
      }
    } else if (tag === 'text' || tag === 'tspan') {
      const x = (parseFloat(el.getAttribute('x') || 0) - offX) * scX;
      const y = (parseFloat(el.getAttribute('y') || 0) - offY) * scY;
      const w = this.warper.transformPoint(x, y);
      el.setAttribute('x', w.x.toFixed(3));
      el.setAttribute('y', w.y.toFixed(3));
      
      const dx = 1;
      const p1 = this.warper.transformPoint(x + dx, y);
      const angle = Math.atan2(p1.y - w.y, p1.x - w.x) * 180 / Math.PI;
      if (Math.abs(angle) > 0.1) {
        el.setAttribute('transform', `rotate(${angle.toFixed(2)} ${w.x.toFixed(3)} ${w.y.toFixed(3)})`);
      }
    } else if (tag === 'image') {
      // Handle embedded images
      const x = (parseFloat(el.getAttribute('x') || 0) - offX) * scX;
      const y = (parseFloat(el.getAttribute('y') || 0) - offY) * scY;
      const imgW = parseFloat(el.getAttribute('width') || 0) * scX;
      const imgH = parseFloat(el.getAttribute('height') || 0) * scY;
      
      // Transform corners to get new position
      const tl = this.warper.transformPoint(x, y);
      const tr = this.warper.transformPoint(x + imgW, y);
      const bl = this.warper.transformPoint(x, y + imgH);
      
      el.setAttribute('x', tl.x.toFixed(3));
      el.setAttribute('y', tl.y.toFixed(3));
      
      // Calculate new dimensions based on warped corners
      const newW = Math.sqrt((tr.x - tl.x) ** 2 + (tr.y - tl.y) ** 2);
      const newH = Math.sqrt((bl.x - tl.x) ** 2 + (bl.y - tl.y) ** 2);
      el.setAttribute('width', newW.toFixed(3));
      el.setAttribute('height', newH.toFixed(3));
      
      // Add rotation transform
      const angle = Math.atan2(tr.y - tl.y, tr.x - tl.x) * 180 / Math.PI;
      if (Math.abs(angle) > 0.1) {
        el.setAttribute('transform', `rotate(${angle.toFixed(2)} ${tl.x.toFixed(3)} ${tl.y.toFixed(3)})`);
      }
    }

    // Process children
    const children = Array.from(el.children);
    for (const child of children) {
      this.transformElement(child, scX, scY, offX, offY);
    }
  }

  scalePath(d, scX, scY, offX, offY) {
    const cmds = SVGPathUtils.parse(d);
    return SVGPathUtils.toString(cmds.map(({ type, args }) => {
      const newArgs = [...args];
      const isRel = type !== type.toUpperCase();
      const t = type.toUpperCase();
      
      if (['M', 'L', 'T'].includes(t)) {
        if (isRel) { newArgs[0] *= scX; newArgs[1] *= scY; }
        else { newArgs[0] = (newArgs[0] - offX) * scX; newArgs[1] = (newArgs[1] - offY) * scY; }
      } else if (t === 'C') {
        for (let i = 0; i < 6; i += 2) {
          if (isRel) { newArgs[i] *= scX; newArgs[i+1] *= scY; }
          else { newArgs[i] = (newArgs[i] - offX) * scX; newArgs[i+1] = (newArgs[i+1] - offY) * scY; }
        }
      } else if (['S', 'Q'].includes(t)) {
        for (let i = 0; i < 4; i += 2) {
          if (isRel) { newArgs[i] *= scX; newArgs[i+1] *= scY; }
          else { newArgs[i] = (newArgs[i] - offX) * scX; newArgs[i+1] = (newArgs[i+1] - offY) * scY; }
        }
      } else if (t === 'A') {
        newArgs[0] *= scX; newArgs[1] *= scY;
        if (isRel) { newArgs[5] *= scX; newArgs[6] *= scY; }
        else { newArgs[5] = (newArgs[5] - offX) * scX; newArgs[6] = (newArgs[6] - offY) * scY; }
      }
      return { type, args: newArgs };
    }));
  }

  shapeToPath(el, scX, scY, offX, offY) {
    const tag = el.tagName.toLowerCase();
    if (tag === 'circle') {
      const cx = (parseFloat(el.getAttribute('cx') || 0) - offX) * scX;
      const cy = (parseFloat(el.getAttribute('cy') || 0) - offY) * scY;
      const r = parseFloat(el.getAttribute('r') || 0) * Math.min(scX, scY);
      return `M${cx-r},${cy}A${r},${r} 0 1 0 ${cx+r},${cy}A${r},${r} 0 1 0 ${cx-r},${cy}Z`;
    }
    if (tag === 'ellipse') {
      const cx = (parseFloat(el.getAttribute('cx') || 0) - offX) * scX;
      const cy = (parseFloat(el.getAttribute('cy') || 0) - offY) * scY;
      const rx = parseFloat(el.getAttribute('rx') || 0) * scX;
      const ry = parseFloat(el.getAttribute('ry') || 0) * scY;
      return `M${cx-rx},${cy}A${rx},${ry} 0 1 0 ${cx+rx},${cy}A${rx},${ry} 0 1 0 ${cx-rx},${cy}Z`;
    }
    if (tag === 'rect') {
      const x = (parseFloat(el.getAttribute('x') || 0) - offX) * scX;
      const y = (parseFloat(el.getAttribute('y') || 0) - offY) * scY;
      const w = parseFloat(el.getAttribute('width') || 0) * scX;
      const h = parseFloat(el.getAttribute('height') || 0) * scY;
      const rx = parseFloat(el.getAttribute('rx') || 0) * scX;
      const ry = parseFloat(el.getAttribute('ry') || rx) * scY;
      
      if (rx > 0 || ry > 0) {
        // Rounded rectangle
        return `M${x+rx},${y} L${x+w-rx},${y} Q${x+w},${y} ${x+w},${y+ry} L${x+w},${y+h-ry} Q${x+w},${y+h} ${x+w-rx},${y+h} L${x+rx},${y+h} Q${x},${y+h} ${x},${y+h-ry} L${x},${y+ry} Q${x},${y} ${x+rx},${y}Z`;
      }
      return `M${x},${y}L${x+w},${y}L${x+w},${y+h}L${x},${y+h}Z`;
    }
    if (tag === 'line') {
      const x1 = (parseFloat(el.getAttribute('x1') || 0) - offX) * scX;
      const y1 = (parseFloat(el.getAttribute('y1') || 0) - offY) * scY;
      const x2 = (parseFloat(el.getAttribute('x2') || 0) - offX) * scX;
      const y2 = (parseFloat(el.getAttribute('y2') || 0) - offY) * scY;
      return `M${x1},${y1}L${x2},${y2}`;
    }
    if (tag === 'polygon' || tag === 'polyline') {
      const pts = el.getAttribute('points')?.trim().split(/[\s,]+/).map(Number) || [];
      let d = '';
      for (let i = 0; i < pts.length; i += 2) {
        const x = (pts[i] - offX) * scX, y = (pts[i+1] - offY) * scY;
        d += (i === 0 ? 'M' : 'L') + `${x},${y}`;
      }
      return tag === 'polygon' ? d + 'Z' : d;
    }
    return null;
  }

  copyAttrs(from, to) {
    const skip = ['cx', 'cy', 'r', 'rx', 'ry', 'x', 'y', 'width', 'height', 'x1', 'y1', 'x2', 'y2', 'points'];
    for (const attr of from.attributes) {
      if (!skip.includes(attr.name)) to.setAttribute(attr.name, attr.value);
    }
  }
}

// ========== AI TO SVG CONVERTER ==========
class AIToSVGConverter {
  static async convert(aiFile) {
    const fileName = aiFile.name;
    const fileSize = (aiFile.size / 1024 / 1024).toFixed(2);
    
    throw new Error(`AI files cannot be directly processed in browser.\n\n` +
                   `File: ${fileName} (${fileSize} MB)\n\n` +
                   `To use an AI file:\n` +
                   `1. Open the file in Adobe Illustrator\n` +
                   `2. Go to File > Export > Export As...\n` +
                   `3. Choose SVG format and click Export\n` +
                   `4. Upload the resulting SVG file`);
  }
}

// Export to window
window.cache = cache;
window.CacheManager = CacheManager;
window.PathSampler = PathSampler;
window.MeshWarper = MeshWarper;
window.SVGPathUtils = SVGPathUtils;
window.SVGPathWarper = SVGPathWarper;
window.LayerExtractor = LayerExtractor;
window.SVGDocTransformer = SVGDocTransformer;
window.AIToSVGConverter = AIToSVGConverter;
window.debounce = debounce;
</script>

<!-- SCRIPT PART 2: State and Shape Definitions -->
<script type="module">
// ========== STATE ==========
const state = {
  image: null,
  imageDataUrl: null,
  textureDataUrl: null,
  svgContent: null,
  svgDimensions: null,
  svgLayers: null,
  transformedLayers: [], // NEW: Store transformed layers
  currentView: "bottom",
  currentShapeType: "round",
  currentShape: "250ml_round",
  zoom: 1,
  panX: 0,
  panY: 0,
  isPanning: false,
  isSpacePressed: false,
  lastMouse: { x: 0, y: 0 },
  isExporting: false,
  isModelLoaded: false,
  isViewer3DMinimized: false,
  isViewer3DExpanded: false,
  fileType: null
};

const EXPORT_SCALE = 6;
const MIN_ZOOM = 0.25;
const MAX_ZOOM = 5;
const ZOOM_STEP = 0.25;

// ========== DOM ELEMENTS ==========
const $ = id => document.getElementById(id);
const el = {
  mainSvg: $('mainSvg'),
  svgDefs: $('svgDefs'),
  backgroundLayer: $('backgroundLayer'),
  imageLayer: $('imageLayer'),
  outlineLayer: $('outlineLayer'),
  svgContainer: $('svgContainer'),
  uploadText: $('uploadText'),
  fileTypeBadge: $('fileTypeBadge'),
  uploadLabel: $('uploadLabel'),
  fileInput: $('imageUpload'),
  exportPngBtn: $('exportPngBtn'),
  exportSvgBtn: $('exportSvgBtn'),
  exportPdfBtn: $('exportPdfBtn'),
  shapeTypeSelect: $('shapeTypeSelect'),
  shapeSelect: $('shapeSelect'),
  viewSelector: $('viewSelector'),
  loadingOverlay: $('loadingOverlay'),
  loadingText: $('loadingText'),
  loadingSubtext: $('loadingSubtext'),
  errorOverlay: $('errorOverlay'),
  errorTitle: $('errorTitle'),
  errorMessage: $('errorMessage'),
  errorCloseBtn: $('errorCloseBtn'),
  zoomInBtn: $('zoomInBtn'),
  zoomOutBtn: $('zoomOutBtn'),
  zoomDisplay: $('zoomDisplay'),
  resetViewBtn: $('resetViewBtn'),
  viewer3DContainer: $('viewer3DContainer'),
  modelViewer: $('modelViewer'),
  viewer3DLoading: $('viewer3DLoading'),
  viewer3DStatus: $('viewer3DStatus'),
  viewer3DToggle: $('viewer3DToggle'),
  viewer3DExpand: $('viewer3DExpand')
};

// ========== SHAPE DEFINITIONS ==========
const shapeTypes = {
  round: "Round",
  round_square: "Round Square",
  rectangle: "Rectangle",
  sweet_box: "Sweet Box",
  sweet_box_te: "Sweet Box TE"
};

const shapes = {
  "250ml_round": {
    type: "round",
    view: "bottom",
    name: "250ml Round",
    width: 837,
    height: 244,
    uploadDimensions: { width: 2908, height: 448 },
    path: "M1.37,162.42L73.32,242.27C283.84,56.41,576.84,75.5,764.01,242.27L835.96,162.42C597.61,-50.29,240.85,-53.15,1.37,162.42Z",
    topPath: "M 835.96,162.42 C 597.61,-50.29 240.85,-53.15 1.37,162.42",
    bottomPath: "M 73.32,242.27 C 283.84,56.41 576.84,75.5 764.01,242.27",
    topIsReversed: true,
    bottomIsReversed: false,
    modelPath: "./assets/models/250ml_round_t.glb",
    targetMaterials: ["Texture"],
    // Edge paths for covering gaps
    leftEdgePath: "M 1.37,162.42 C 37.345,106.205 73.32,242.27 73.32,242.27",
    rightEdgePath: "M 764.01,242.27 C 764.01,242.27 799.985,106.205 835.96,162.42"
  },
  "300ml_round": {
    type: "round",
    view: "bottom",
    name: "300ml Round",
    width: 986.98,
    height: 332.17,
    uploadDimensions: { width: 2906, height: 448 },
    path: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0l-5.32,1.98-45.71-122.15,6.01-2.21c286.86-105.52,601.92-105.52,888.78,0l6.04,2.15-45.75,122.2-5.3-1.98Z",
    topPath: "M49.08,172.19c286.86-105.52,601.92-105.52,888.78,0",
    bottomPath: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0",
    topIsReversed: false,
    bottomIsReversed: true,
    modelPath: "./assets/models/300ml_round_container.glb",
    targetMaterials: ["Texture"],
    // Edge paths for covering gaps
    leftEdgePath: "M 49.08,172.19 C 43.77,233.38 89.05,296.56 89.05,296.56",
    rightEdgePath: "M 898.78,296.56 C 898.78,296.56 944.06,233.38 938.75,172.19"
  },
  "500ml_round": {
    type: "round",
    view: "bottom",
    name: "500ml Round",
    width: 945.18,
    height: 430.84,
    uploadDimensions: { width: 2890, height: 886 },
    path: "M846.13,387.86c-120.06-43.77-245.71-65.96-373.55-65.96s-252.55,22.02-372.2,65.47l-.61-1.56L24.95,193.11l2.66-.97c143.01-52.15,292.69-78.58,444.97-78.58s301.97,26.44,444.98,78.59l2.65,1.01-74.09,194.71Z",
    topPath: "M27.61,192.14c143.01-52.15,292.69-78.58,444.97-78.58s301.97,26.44,444.98,78.59",
    bottomPath: "M846.13,387.86c-120.06-43.77-245.71-65.96-373.55-65.96s-252.55,22.02-372.2,65.47",
    topIsReversed: false,
    bottomIsReversed: true,
    modelPath: "./assets/models/500ml_round_container_t.glb",
    targetMaterials: ["Texture"],
    // Edge paths for covering gaps
    leftEdgePath: "M 27.61,192.14 C 20.5,290.0 100.38,387.37 100.38,387.37",
    rightEdgePath: "M 846.13,387.86 C 846.13,387.86 924.5,290.0 917.56,192.15"
  },
  "750ml_round": {
    type: "round",
    view: "bottom",
    name: "750ml Round",
    width: 1187.25,
    height: 279.7,
    uploadDimensions: { width: 4360, height: 701 },
    path: "M3.26,122.79c376.81-163.05,803.93-163.05,1180.74,0l2.6,1.21-1.14,2.55-67.28,150.03-1.21,2.45-2.49-1.01c-332.55-143.26-709.13-143.26-1041.68,0l-2.54,1.04-1.17-2.48L1.8,126.55l-1.14-2.63,2.6-1.13Z",
    topPath: "M3.26,122.79c376.81-163.05,803.93-163.05,1180.74,0",
    bottomPath: "M1114.48,278.02c-332.55-143.26-709.13-143.26-1041.68,0",
    topIsReversed: false,
    bottomIsReversed: true,
    modelPath: "./assets/models/750ml_round_container_t.glb",
    targetMaterials: [" Texture"],
    // Edge paths for covering gaps
    leftEdgePath: "M 3.26,122.79 C -5.0,200.4 72.8,278.02 72.8,278.02",
    rightEdgePath: "M 1114.48,278.02 C 1114.48,278.02 1192.0,200.4 1184.0,122.79"
  },
  "1000ml_round": {
    type: "round",
    view: "bottom",
    name: "1000ml Round",
    width: 1186.89,
    height: 332.33,
    uploadDimensions: { width: 4153, height: 929 },
    path: "M97.62,331.03L114.97,323.22L137.59,313.59L160.4,304.43L183.4,295.74L206.58,287.53L229.93,279.8L253.44,272.55L277.1,265.79L300.9,259.51L324.82,253.73L348.86,248.44L373.02,243.64L397.25,239.35L421.59,235.56L446,232.27L470.46,229.48L494.99,227.2L519.56,225.42L544.16,224.15L568.78,223.39L593.42,223.14L618.06,223.39L642.68,224.15L667.28,225.42L691.84,227.2L716.36,229.48L740.84,232.27L765.25,235.56L789.58,239.35L813.82,243.64L837.98,248.44L862.02,253.73L885.93,259.51L909.74,265.79L933.4,272.55L956.9,279.8L980.26,287.53L1003.43,295.74L1026.43,304.43L1049.25,313.59L1071.87,323.22L1089.23,331.04L1091.77,332.1L1092.96,329.66L1185.4,132.99L1186.65,130.47L1184,129.2L1161.31,118.99L1134.45,107.56L1107.36,96.68L1080.05,86.36L1052.53,76.61L1024.8,67.43L996.9,58.83L968.81,50.8L940.56,43.35L912.17,36.48L883.63,30.21L854.97,24.52L826.19,19.42L797.32,14.92L768.35,11.01L739.31,7.71L710.21,5L681.06,2.89L651.87,1.39L622.65,.48L593.42,.18L564.19,.48L534.97,1.39L505.78,2.89L476.63,5L447.52,7.71L418.48,11.01L389.52,14.92L360.64,19.42L331.87,24.52L303.21,30.21L274.67,36.48L246.27,43.35L218.03,50.8L189.94,58.83L162.03,67.43L134.31,76.61L106.79,86.36L79.47,96.68L52.38,107.56L25.53,118.99L2.83,129.21L.24,130.46L1.42,132.99L93.89,329.65L95.16,332.1L97.62,331.03Z",
    topPath: "M2.83,129.21L25.53,118.99L52.38,107.56L79.47,96.68L106.79,86.36L134.31,76.61L162.03,67.43L189.94,58.83L218.03,50.8L246.27,43.35L274.67,36.48L303.21,30.21L331.87,24.52L360.64,19.42L389.52,14.92L418.48,11.01L447.52,7.71L476.63,5L505.78,2.89L534.97,1.39L564.19,.48L593.42,.18L622.65,.48L651.87,1.39L681.06,2.89L710.21,5L739.31,7.71L768.35,11.01L797.32,14.92L826.19,19.42L854.97,24.52L883.63,30.21L912.17,36.48L940.56,43.35L968.81,50.8L996.9,58.83L1024.8,67.43L1052.53,76.61L1080.05,86.36L1107.36,96.68L1134.45,107.56L1161.31,118.99L1184,129.2",
    bottomPath: "M97.62,331.03L114.97,323.22L137.59,313.59L160.4,304.43L183.4,295.74L206.58,287.53L229.93,279.8L253.44,272.55L277.1,265.79L300.9,259.51L324.82,253.73L348.86,248.44L373.02,243.64L397.25,239.35L421.59,235.56L446,232.27L470.46,229.48L494.99,227.2L519.56,225.42L544.16,224.15L568.78,223.39L593.42,223.14L618.06,223.39L642.68,224.15L667.28,225.42L691.84,227.2L716.36,229.48L740.84,232.27L765.25,235.56L789.58,239.35L813.82,243.64L837.98,248.44L862.02,253.73L885.93,259.51L909.74,265.79L933.4,272.55L956.9,279.8L980.26,287.53L1003.43,295.74L1026.43,304.43L1049.25,313.59L1071.87,323.22L1089.23,331.04",
    topIsReversed: false,
    bottomIsReversed: false,
    modelPath: "./assets/models/1000mlcontainer_t.glb",
    targetMaterials: ["Texture"],
    // Edge paths for covering gaps
    leftEdgePath: "M 2.83,129.21 C -10.0,230.12 97.62,331.03 97.62,331.03",
    rightEdgePath: "M 1089.23,331.04 C 1089.23,331.04 1196.89,230.12 1184.0,129.2"
  },
  "450ml_round_square": {
    type: "round_square",
    view: "bottom",
    name: "450ml Round Square",
    width: 879.22,
    height: 276.16,
    uploadDimensions: { width: 2923, height: 748 },
    path: "M93.16,274.8l9.48-5.52c16.09-9.47,32.49-18.51,49.08-27.07l8.02-3.94c9.34-4.49,18.91-8.56,28.62-12.17,8.99-3.3,18.11-6.37,27.27-9.18,15.76-4.79,31.65-9.33,47.56-13.57,18.8-5.19,37.79-9.92,56.83-14.14l9.07-1.84,8.27-1.5c10.82-1.83,21.76-3.15,32.71-3.94,9.81-.7,19.67-1.17,29.5-1.4,21.39-.46,42.86-.55,64.25-.29,12.27.09,24.57.47,36.82,1.13,13.8.7,27.58,2.2,41.2,4.49,9.2,1.6,18.39,3.47,27.48,5.58,15.63,3.68,31.23,7.65,46.71,11.9,15.9,4.24,31.78,8.78,47.53,13.56,9.16,2.81,18.27,5.88,27.27,9.19,9.71,3.61,19.29,7.68,28.62,12.17,9.02,4.37,17.96,8.98,26.74,13.81,13.78,7.6,26.32,14.75,39.8,22.73l1.29.69.73-1.14,89.79-152.32.72-1.21-1.24-.73-13.45-7.78-11.35-6.29-11.74-6.21-12.33-6.23c-19.27-9.43-38.9-18.29-58.72-26.51l-16-6.53-15.31-5.99-14.52-5.41-13.83-4.89c-23.21-8.03-46.9-14.84-70.84-20.34-19.14-4.36-38.5-8.07-57.9-11.09-11.43-1.81-22.92-3.44-34.4-4.91l-19.63-2.35c-18.16-2.05-36.45-3.52-54.71-4.39-9.72-.44-19.47-.67-29.2-.68h-3.78s-3.78,0-3.78,0l-6.4.04-12.28.25-10.51.39-15.42.86c-13.11.89-26.23,2.07-39.29,3.53l-19.63,2.35c-24.07,3.03-48.1,6.91-71.9,11.61-30.91,6.14-61.46,14.42-91.24,24.74l-13.82,4.89-14.52,5.41-15.31,5.99-16,6.53c-19.82,8.21-39.45,17.07-58.72,26.51l-12.33,6.22-11.74,6.21-11.35,6.29-13.43,7.79-1.22.71.71,1.24,89.83,152.25.7,1.19,1.24-.69Z",
    topPath: "M1.22,123.55l13.43-7.79l11.35-6.29l11.74-6.21l12.33-6.22c19.27-9.44,38.9-18.3,58.72-26.51l16-6.53l15.31-5.99l14.52-5.41l13.82-4.89c30.78-10.32,60.33-18.60,91.24-24.74c24.07-4.7,47.83-8.58,71.9-11.61l19.63-2.35c13.06-1.46,26.18-2.64,39.29-3.53l15.42-.86l10.51-.39l12.28-.25l6.4-.04h3.78s3.78,0,3.78,0c9.73.01,19.48.24,29.2.68c18.26.87,36.55,2.34,54.71,4.39l19.63,2.35c11.48,1.47,22.97,3.10,34.40,4.91c19.40,3.02,38.76,6.73,57.90,11.09c23.94,5.50,47.63,12.31,70.84,20.34l13.83,4.89l14.52,5.41l15.31,5.99l16,6.53c19.82,8.22,39.45,17.08,58.72,26.51l12.33,6.23l11.74,6.21l11.35,6.29l13.45,7.78",
    bottomPath: "M93.16,274.8l9.48-5.52c16.09-9.47,32.49-18.51,49.08-27.07l8.02-3.94c9.34-4.49,18.91-8.56,28.62-12.17,8.99-3.30,18.11-6.37,27.27-9.18,15.76-4.79,31.65-9.33,47.56-13.57,18.80-5.19,37.79-9.92,56.83-14.14l9.07-1.84,8.27-1.50c10.82-1.83,21.76-3.15,32.71-3.94,9.81-.70,19.67-1.17,29.50-1.40,21.39-.46,42.86-.55,64.25-.29,12.27.09,24.57.47,36.82,1.13,13.80.70,27.58,2.20,41.20,4.49,9.20,1.60,18.39,3.47,27.48,5.58,15.63,3.68,31.23,7.65,46.71,11.90,15.90,4.24,31.78,8.78,47.53,13.56,9.16,2.81,18.27,5.88,27.27,9.19,9.71,3.61,19.29,7.68,28.62,12.17,9.02,4.37,17.96,8.98,26.74,13.81,13.78,7.60,26.32,14.75,39.80,22.73",
    topIsReversed: false,
    bottomIsReversed: false,
    modelPath: "./assets/models/500gms&450ml container_t.glb",
    targetMaterials: [" Texture"],
    // Edge paths for covering gaps
    leftEdgePath: "M 1.22,123.55 C -10.0,199.17 93.16,274.8 93.16,274.8",
    rightEdgePath: "M 786.07,274.8 C 786.07,274.8 889.22,199.17 878.0,123.55"
  },
  "500ml_round_square": {
    type: "round_square",
    view: "bottom",
    name: "500ml Round Square",
    width: 888.9,
    height: 297.78,
    uploadDimensions: { width: 2770, height: 886 },
    path: "M100.22,295.91c7.22-3.68,14.49-7.33,21.74-10.94,12.31-6.17,24.8-12.07,37.38-17.66l8.32-3.56c6.19-2.59,12.48-5.01,18.81-7.25,6.79-2.39,13.66-4.62,20.55-6.67,11.2-3.29,22.5-6.38,33.82-9.23,17.32-4.36,34.73-8.55,52.14-12.54,13.13-3.03,26.38-5.76,39.64-8.17,10.65-1.91,21.41-3.37,32.18-4.37,11.78-1.02,23.62-1.67,35.44-1.95,14.74-.34,29.53-.51,44.27-.49,14.74-.01,29.53.15,44.27.49,9.56.23,19.14.7,28.68,1.39,8.72.64,17.44,1.59,26.09,2.85,7.55,1.11,15.1,2.41,22.59,3.88,14.87,2.96,29.72,6.21,44.47,9.74,16.79,3.93,33.58,8.09,50.26,12.45l11.22,3.06,9.92,2.87,8.8,2.71c10.34,3.28,20.56,7.03,30.56,11.21,9.38,3.95,18.7,8.14,27.88,12.53,13.21,6.34,26.37,12.87,39.42,19.55l2.4,1.28,1.41-2.51,94.51-184.07,1.26-2.46-2.5-1.36-12.45-6.29-12.14-5.86-12.54-5.77-13.15-5.78-14.04-5.89-15.25-6.12-16.64-6.41c-16.62-6.28-33.41-12.25-50.26-17.87-14.15-4.7-28.45-9.06-42.81-13.06-17.59-4.88-35.41-9.14-53.32-12.73-26.55-5.22-53.37-9.42-80.24-12.58-18.01-2.19-36.11-4-54.19-5.45l-17.34-1.16-14.62-.7c-10.74-.42-21.52-.6-32.26-.54-10.72-.06-21.47.13-32.18.54l-14.58.7-17.36,1.16-4.33.34-14.71,1.29-18.35,1.87c-25.34,2.71-50.66,6.23-75.78,10.52-29.81,5.17-59.39,12.09-88.41,20.67l-14.1,4.3c-10.3,3.24-20.58,6.65-30.78,10.2l-16.94,6.02c-16.55,5.99-33.03,12.33-49.33,18.98l-14.02,5.88-13.15,5.78-12.54,5.77-12.14,5.86-12.59,6.36-2.54,1.32,1.3,2.52c31.81,61.1,63.35,122.59,94.42,184.07l1.32,2.45,2.5-1.2Z",
    topPath: "M 881.89,111.84 l-12.45-6.29 -12.14-5.86 -12.54-5.77 -13.15-5.78 -14.04-5.89 -15.25-6.12 -16.64-6.41 c-16.62-6.28 -33.41-12.25 -50.26-17.87 -14.15-4.7 -28.45-9.06 -42.81-13.06 -17.59-4.88 -35.41-9.14 -53.32-12.73 -26.55-5.22 -53.37-9.42 -80.24-12.58 -18.01-2.19 -36.11-4 -54.19-5.45 l-17.34-1.16 -14.62-0.7 c-10.74-.42 -21.52-.6 -32.26-.54 -10.72-.06 -21.47.13 -32.18.54 l-14.58.7 -17.36,1.16 -4.33.34 -14.71,1.29 -18.35,1.87 c-25.34,2.71 -50.66,6.23 -75.78,10.52 -29.81,5.17 -59.39,12.09 -88.41,20.67 l-14.1,4.3 c-10.3,3.24 -20.58,6.65 -30.78,10.2 l-16.94,6.02 c-16.55,5.99 -33.03,12.33 -49.33,18.98 l-14.02,5.88 -13.15,5.78 -12.54,5.77 -12.14,5.86 -12.59,6.36",
    bottomPath: "M100.22,295.91c7.22-3.68,14.49-7.33,21.74-10.94,12.31-6.17,24.8-12.07,37.38-17.66l8.32-3.56c6.19-2.59,12.48-5.01,18.81-7.25,6.79-2.39,13.66-4.62,20.55-6.67,11.2-3.29,22.5-6.38,33.82-9.23,17.32-4.36,34.73-8.55,52.14-12.54,13.13-3.03,26.38-5.76,39.64-8.17,10.65-1.91,21.41-3.37,32.18-4.37,11.78-1.02,23.62-1.67,35.44-1.95,14.74-.34,29.53-.51,44.27-.49,14.74-.01,29.53.15,44.27.49,9.56.23,19.14.7,28.68,1.39,8.72.64,17.44,1.59,26.09,2.85,7.55,1.11,15.1,2.41,22.59,3.88,14.87,2.96,29.72,6.21,44.47,9.74,16.79,3.93,33.58,8.09,50.26,12.45l11.22,3.06,9.92,2.87,8.8,2.71c10.34,3.28,20.56,7.03,30.56,11.21,9.38,3.95,18.7,8.14,27.88,12.53,13.21,6.34,26.37,12.87,39.42,19.55",
    topIsReversed: true,
    bottomIsReversed: false,
    modelPath: "./assets/models/500ml_container_t.glb",
    targetMaterials: [" Texture"],
    // Edge paths for covering gaps
    leftEdgePath: "M 7.01,111.84 C -5.0,203.87 100.22,295.91 100.22,295.91",
    rightEdgePath: "M 788.68,295.91 C 788.68,295.91 893.9,203.87 881.89,111.84"
  },
  "750ml_rectangle": {
    type: "rectangle",
    view: "bottom",
    name: "500ml / 750ml Rectangle",
    width: 462.62,
    height: 309.76,
    uploadDimensions: { width: 1926, height: 1289 },
    path: "M.99,47.31 C.99,21.73 21.73,.99 47.31,.99 H 415.31 C 440.89,.99 461.63,21.73 461.63,47.31 V 262.45 C 461.63,288.03 440.89,308.77 415.31,308.77 H 47.31 C 21.73,308.77 .99,288.03 .99,262.45 Z",
    topPath: "M.99,47.31 C.99,21.73 21.73,.99 47.31,.99 H 415.31 C 440.89,.99 461.63,21.73 461.63,47.31",
    bottomPath: "M.99,262.45 C.99,288.03 21.73,308.77 47.31,308.77 H 415.31 C 440.89,308.77 461.63,288.03 461.63,262.45",
    topIsReversed: false,
    bottomIsReversed: false,
    modelPath: "./assets/models/750ml rectangular_t.glb",
    targetMaterials: [" Texture"],
    // Edge paths for covering gaps (straight lines for rectangle)
    leftEdgePath: "M .99,47.31 L .99,262.45",
    rightEdgePath: "M 461.63,262.45 L 461.63,47.31"
  },
  "1kg_sweet_box_top": {
    type: "sweet_box",
    view: "top",
    name: "1kg Sweet Box",
    width: 636.39,
    height: 455.59,
    uploadDimensions: { width: 1926, height: 1289 },
    path: "M.5.5 h635.39 v454.59 h-635.39 Z",
    topPath: "M0,0 H636.39",
    bottomPath: "M0,455.59 H636.39",
    topIsReversed: false,
    bottomIsReversed: false,
    modelPath: "./assets/models/1000gms_sweet_t.glb",
    targetMaterials: [" Texture"],
    // Edge paths for covering gaps (straight lines for rectangle)
    leftEdgePath: "M 0,0 L 0,455.59",
    rightEdgePath: "M 636.39,455.59 L 636.39,0"
  },
  "250ml_sweet_box_top": {
    type: "sweet_box",
    view: "top",
    name: "250g Sweet Box",
    width: 361,
    height: 273.49,
    uploadDimensions: { width: 1461, height: 1100 },
    path: "M9.29.5h342.4c4.85,0,8.82,3.94,8.82,8.79v254.92c0,4.82-3.97,8.79-8.82,8.79H9.29c-4.85,0-8.79-3.97-8.79-8.79V9.29C.5,4.44,4.44.5,9.29.5Z",
    topPath: "M0,0 H361",
    bottomPath: "M0,273.49 H361",
    topIsReversed: false,
    bottomIsReversed: false,
    modelPath: "./assets/models/250gms_sweet_t.glb",
    targetMaterials: ["TopTexture"],
    // Edge paths for covering gaps
    leftEdgePath: "M 0,0 L 0,273.49",
    rightEdgePath: "M 361,273.49 L 361,0"
  },
  "500ml_sweet_box_top": {
    type: "sweet_box",
    view: "top",
    name: "500g Sweet Box",
    width: 495.82,
    height: 351.4,
    uploadDimensions: { width: 2064, height: 1463 },
    path: "M489.44,351.01H6.42c-3.32,0-6.04-2.72-6.04-6.04V6.38C.38,3.1,3.09.38,6.42.38h483.02c3.29,0,6.01,2.72,6.01,6.01v338.6c0,3.32-2.72,6.04-6.01,6.04h0Z",
    topPath: "M0,0 H495.82",
    bottomPath: "M0,351.4 H495.82",
    topIsReversed: false,
    bottomIsReversed: false,
    modelPath: "./assets/models/500gms_sweet_t.glb",
    targetMaterials: ["TopTexture"],
    // Edge paths for covering gaps
    leftEdgePath: "M 0,0 L 0,351.4",
    rightEdgePath: "M 495.82,351.4 L 495.82,0"
  },
  "250ml_sweet_box_bottom": {
    type: "sweet_box",
    view: "bottom",
    name: "250g Sweet Box",
    width: 1342.58,
    height: 189.54,
    uploadDimensions: { width: 5533, height: 404 },
    path: "M662.63.55l-278.9,13.66c-.26,0-.48.03-.74.09L8.88,81.16l-8.31,1.59,1.42,8.27,15.85,89.69,1.64,8.25,8.26-1.36,367.77-65.74c1.19-.23,2.41-.37,3.6-.43l259.43-12.7c1.3-.06,2.64-.03,3.94.09h.11l365.58,24.6c1.84.14,3.69.45,5.44.93.14.03.26.06.37.09l266.12,52.89,7.12,1.34,2.57-6.92,29.28-86.34,2.87-8.88-9.25-2.2-289.39-57.68c-2.38-.62-4.82-1.02-7.28-1.19L668.08.66c-1.16-.11-2.33-.16-3.49-.16-.65,0-1.3.02-1.95.05",
    topPath: "M8.88,81.16 L382.99,14.3 c.26-.06 .48-.09 .74-.09 L662.63,0.55 c.65-.03 1.3-.05 1.95-.05 c1.16,0 2.33.05 3.49.16 L1042.28,24.34 c2.46.17 4.9.57 7.28,1.19 l289.39,57.68",
    bottomPath: "M27.74,187.6 l367.77-65.74 c1.19-.23,2.41-.37,3.6-.43 l259.43-12.7 c1.3-.06,2.64-.03,3.94.09 h.11 l365.58,24.6 c1.84.14,3.69.45,5.44.93 .14.03 .26.06 .37.09 l266.12,52.89",
    topIsReversed: false,
    bottomIsReversed: false,
    modelPath: "./assets/models/250gms_sweet_t.glb",
    targetMaterials: ["Bottom1"],
    // Edge paths for covering gaps
    leftEdgePath: "M 8.88,81.16 C 0,81.16 0,134.38 27.74,187.6",
    rightEdgePath: "M 1300.12,187.73 C 1342.58,134.38 1342.58,81.16 1338.95,83.21"
  },
  "500ml_sweet_box_bottom": {
    type: "sweet_box",
    view: "bottom",
    name: "500g Sweet Box",
    width: 1798.7,
    height: 215.31,
    uploadDimensions: { width: 7446, height: 403 },
    path: "M1758.59,213.74l-356.09-70.07c-3.32-.65-6.69-1.11-10.09-1.33l-505.42-33.33c-2.98-.2-5.98-.23-8.96-.09l-341.4,15.99c-3.4.14-6.8.54-10.15,1.13L31.24,213.68l-4.25.74c-3.77.65-7.4-1.84-8.14-5.64L.63,115.74c-.37-1.87.06-3.83,1.13-5.41,1.1-1.59,2.78-2.64,4.68-2.92l4.14-.68L503.67,19.45c3.83-.68,7.68-1.1,11.57-1.3L890,.6c3.4-.17,6.83-.11,10.23.11l495.47,32.68c3.85.25,7.71.76,11.54,1.5l381.26,75.03,4.05.85c1.96.4,3.63,1.59,4.65,3.29,1.02,1.73,1.28,3.77.71,5.67l-26.79,90c-1.05,3.54-4.68,5.7-8.28,4.9l-4.25-.91Z",
    topPath: "M.63,115.74c-.37-1.87.06-3.83,1.13-5.41,1.1-1.59,2.78-2.64,4.68-2.92l4.14-.68L503.67,19.45c3.83-.68,7.68-1.1,11.57-1.3L890,.6c3.4-.17,6.83-.11,10.23.11l495.47,32.68c3.85.25,7.71.76,11.54,1.5l381.26,75.03,4.05.85c1.96.4,3.63,1.59,4.65,3.29,1.02,1.73,1.28,3.77.71,5.67",
    bottomPath: "M1758.59,213.74l-356.09-70.07c-3.32-.65-6.69-1.11-10.09-1.33l-505.42-33.33c-2.98-.2-5.98-.23-8.96-.09l-341.4,15.99c-3.4.14-6.8.54-10.15,1.13L31.24,213.68",
    topIsReversed: false,
    bottomIsReversed: true,
    modelPath: "./assets/models/500gms_sweet_t.glb",
    targetMaterials: ["Bottom1"],
    // Edge paths for covering gaps
    leftEdgePath: "M 0.63,115.74 C -5.0,164.74 31.24,213.68 31.24,213.68",
    rightEdgePath: "M 1758.59,213.74 C 1758.59,213.74 1803.7,164.74 1797.91,115.67"
  },
  "250ml_sweet_box_te_top": {
    type: "sweet_box_te",
    view: "top",
    name: "250g Sweet Box TE",
    width: 378.23,
    height: 296.16,
    uploadDimensions: { width: 503, height: 394 },
    path: "M 344.73 .5 346.35 .54 347.96 .65 349.57 .85 351.17 1.12 354.31 1.92 357.36 3.01 360.29 4.39 363.07 6.05 365.67 7.98 368.07 10.17 370.24 12.57 372.18 15.16 373.84 17.94 375.23 20.88 376.32 23.93 377.11 27.07 377.38 28.66 377.58 30.27 377.7 31.89 377.73 33.51 377.73 262.66 377.7 264.28 377.58 265.89 377.38 267.5 377.11 269.1 376.32 272.24 375.23 275.29 373.84 278.22 372.18 281 370.24 283.6 368.07 286 365.67 288.17 363.07 290.11 360.29 291.77 357.36 293.15 354.31 294.24 351.17 295.03 349.57 295.31 347.96 295.51 346.35 295.62 344.73 295.66 33.51 295.66 31.89 295.62 30.27 295.51 28.66 295.31 27.07 295.03 23.92 294.24 20.88 293.15 17.94 291.77 15.16 290.11 12.56 288.17 10.17 286 7.99 283.6 6.06 281 4.39 278.22 3.01 275.29 1.92 272.24 1.13 269.1 .85 267.5 .66 265.89 .54 264.28 .5 262.66 .5 33.51 .54 31.89 .66 30.27 .85 28.66 1.13 27.07 1.92 23.93 3.01 20.88 4.39 17.94 6.06 15.16 7.99 12.57 10.17 10.17 12.56 7.98 15.16 6.05 17.94 4.39 20.88 3.01 23.92 1.92 27.07 1.12 28.66 .85 30.27 .65 31.89 .54 33.51 .5 344.73 .5 Z",
    topPath: "M0,0 H378.23",
    bottomPath: "M0,296.16 H378.23",
    topIsReversed: false,
    bottomIsReversed: false,
    modelPath: "./assets/models/texture_250_gms_te_sb.glb",
    targetMaterials: ["TopTexture"],
    // Edge paths for covering gaps
    leftEdgePath: "M 0,0 L 0,296.16",
    rightEdgePath: "M 378.23,296.16 L 378.23,0"
  },
  "250ml_sweet_box_te_bottom": {
    type: "sweet_box_te",
    view: "bottom",
    name: "250g Sweet Box TE",
    width: 557.78,
    height: 475.73,
    uploadDimensions: { width: 742, height: 633 },
    path: "M437.53,98.37c12.09,0,21.88,9.8,21.88,21.88h97.87v235.23h-97.87c0,12.08-9.79,21.88-21.88,21.88h0v97.87H120.25v-97.86h0c-12.09-.01-21.88-9.81-21.88-21.89H.5V120.25h97.87c0-12.08,9.79-21.88,21.88-21.88h0V.5h317.28v97.86h0Z",
    topPath: "M0,0 H557.78",
    bottomPath: "M0,475.73 H557.78",
    topIsReversed: false,
    bottomIsReversed: false,
    modelPath: "./assets/models/texture_250_gms_te_sb.glb",
    targetMaterials: ["Bottom1"],
    // Edge paths for covering gaps
    leftEdgePath: "M 0,0 L 0,475.73",
    rightEdgePath: "M 557.78,475.73 L 557.78,0"
  },
  "500ml_sweet_box_te_bottom": {
    type: "sweet_box_te",
    view: "bottom",
    name: "500g Sweet Box TE",
    width: 695.7,
    height: 560.63,
    uploadDimensions: { width: 7446, height: 403 },
    path: "M 122.64 3.76 122.39 .92 572.87 .5 572.62 3.34 563.84 104.14 564.26 104.14 566.94 104.29 569.58 104.7 572.17 105.36 574.68 106.27 577.09 107.42 579.38 108.8 581.52 110.39 583.5 112.18 585.29 114.16 586.88 116.3 588.26 118.59 589.41 121 590.32 123.51 590.98 126.1 591.39 128.74 591.54 131.41 591.54 131.84 692.37 123.05 695.2 122.78 695.2 437.82 692.37 437.58 591.54 428.8 591.54 429.22 591.28 432.82 590.5 436.5 589.18 440.16 587.3 443.69 584.89 446.96 582 449.84 578.74 452.26 575.21 454.14 571.54 455.46 567.86 456.23 564.26 456.5 563.84 456.5 572.62 557.30 572.88 560.13 122.39 559.70 122.64 556.87 131.39 456.5 130.96 456.5 127.37 456.23 123.69 455.46 120.02 454.14 116.49 452.26 113.23 449.84 110.34 446.96 107.93 443.69 106.05 440.16 104.72 436.5 103.95 432.82 103.69 429.22 103.69 428.99 103.69 428.8 3.34 437.54 .5 437.78 .5 122.84 3.34 123.09 103.69 131.84 103.69 131.64 103.69 131.41 103.95 127.82 104.72 124.14 106.05 120.47 107.93 116.94 110.34 113.68 113.23 110.79 116.49 108.38 120.02 106.5 123.69 105.17 127.37 104.4 130.96 104.14 131.39 104.14 122.64 3.76 Z",
    topPath: "M 131.39 104.14 H 563.84",
    bottomPath: "M 131.39 456.5 H 563.84",
    topIsReversed: false,
    bottomIsReversed: false,
    modelPath: "./assets/models/texture_500_gms_te_sb.glb",
    targetMaterials: ["Bottom1"],
    // Edge paths for covering gaps
    leftEdgePath: "M 131.39,104.14 C 103.69,104.14 103.69,280.32 131.39,456.5",
    rightEdgePath: "M 563.84,456.5 C 591.54,456.5 591.54,280.32 563.84,104.14"
  },
  "500ml_sweet_box_te_top": {
    type: "sweet_box_te",
    view: "top",
    name: "500g Sweet Box TE",
    width: 509.61,
    height: 374.16,
    uploadDimensions: { width: 2064, height: 1436 },
    path: "M3.86,28.85C4.36,15.15,15.42,4.2,29.12,3.86,179.56.04,330.06.04,480.5,3.86c13.70.34,24.76,11.29,25.26,24.99,3.82,105.45,3.82,211.01,0,316.46-.5,13.70-11.56,24.65-25.26,25-150.44,3.81-300.94,3.81-451.38,0-13.70-.35-24.76-11.30-25.26-25C.04,239.86.04,134.30,3.86,28.85Z",
    topPath: "M0,0 H509.61",
    bottomPath: "M0,374.16 H509.61",
    topIsReversed: false,
    bottomIsReversed: false,
    modelPath: "./assets/models/texture_500_gms_te_sb.glb",
    targetMaterials: ["TopTexture"],
    // Edge paths for covering gaps
    leftEdgePath: "M 0,0 L 0,374.16",
    rightEdgePath: "M 509.61,374.16 L 509.61,0"
  }
};

const shapeGroups = {};
const keyToGroupName = {};

// ========== LOADING & ERROR FUNCTIONS ==========
function showLoading(msg = "Processing...", sub = "Please wait") {
  el.loadingText.textContent = msg;
  el.loadingSubtext.textContent = sub;
  el.loadingOverlay.classList.remove('hidden');
  el.loadingOverlay.classList.add('flex');
  [el.exportPngBtn, el.exportSvgBtn, el.exportPdfBtn].forEach(b => b.disabled = true);
}

function updateLoading(msg, sub) {
  el.loadingText.textContent = msg;
  if (sub) el.loadingSubtext.textContent = sub;
}

function hideLoading() {
  el.loadingOverlay.classList.add('hidden');
  el.loadingOverlay.classList.remove('flex');
  [el.exportPngBtn, el.exportSvgBtn, el.exportPdfBtn].forEach(b => b.disabled = false);
  state.isExporting = false;
}

function showError(title, msg) {
  el.errorTitle.textContent = title;
  el.errorMessage.textContent = msg;
  el.errorOverlay.classList.remove('hidden');
  el.errorOverlay.classList.add('flex');
}

function hideError() {
  el.errorOverlay.classList.add('hidden');
  el.errorOverlay.classList.remove('flex');
}

// ========== ZOOM FUNCTIONS ==========
function updateZoomUI() {
  el.zoomDisplay.textContent = `${Math.round(state.zoom * 100)}%`;
  el.zoomInBtn.disabled = state.zoom >= MAX_ZOOM;
  el.zoomOutBtn.disabled = state.zoom <= MIN_ZOOM;
  el.resetViewBtn.classList.toggle('hidden', state.panX === 0 && state.panY === 0 && state.zoom === 1);
  el.resetViewBtn.classList.toggle('flex', state.panX !== 0 || state.panY !== 0 || state.zoom !== 1);
}

function zoomIn() {
  if (state.zoom < MAX_ZOOM) {
    state.zoom = Math.min(MAX_ZOOM, state.zoom + ZOOM_STEP);
    render();
    updateZoomUI();
  }
}

function zoomOut() {
  if (state.zoom > MIN_ZOOM) {
    state.zoom = Math.max(MIN_ZOOM, state.zoom - ZOOM_STEP);
    if (state.zoom <= 1) { state.panX = 0; state.panY = 0; }
    render();
    updateZoomUI();
  }
}

function resetView() {
  state.zoom = 1;
  state.panX = 0;
  state.panY = 0;
  render();
  updateZoomUI();
}

// ========== SHAPE FUNCTIONS ==========
function preProcessShapes() {
  for (const [key, shape] of Object.entries(shapes)) {
    if (!shapeGroups[shape.name]) shapeGroups[shape.name] = {};
    shapeGroups[shape.name][shape.view] = key;
    keyToGroupName[key] = shape.name;
  }
}

function getCurrentShape() {
  return state.currentShape ? shapes[state.currentShape] : null;
}

function updateUploadPlaceholder() {
  const shape = getCurrentShape();
  if (shape?.uploadDimensions) {
    const { width, height } = shape.uploadDimensions;
    el.uploadText.innerHTML = `<span class="text-xs text-slate-500 block text-center">${width}  ${height}px</span>
      Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>`;
  } else {
    el.uploadText.innerHTML = 'Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>';
  }
  el.fileTypeBadge.classList.add('hidden');
}

function toggleViewSelector() {
  const show = state.currentShapeType === "sweet_box" || state.currentShapeType === "sweet_box_te";
  el.viewSelector.classList.toggle('hidden', !show);
}

function populateShapeTypes() {
  el.shapeTypeSelect.innerHTML = Object.entries(shapeTypes)
    .map(([k, v]) => `<option value="${k}">${v}</option>`).join('');
  el.shapeTypeSelect.value = state.currentShapeType;
}

function updateShapeSelector() {
  el.shapeSelect.innerHTML = '';
  let firstKey = null;

  if (state.currentShapeType === "sweet_box" || state.currentShapeType === "sweet_box_te") {
    const uniqueNames = new Set();
    for (const [key, shape] of Object.entries(shapes)) {
      if (shape.type === state.currentShapeType && !uniqueNames.has(shape.name)) {
        uniqueNames.add(shape.name);
        el.shapeSelect.innerHTML += `<option value="${shape.name}">${shape.name}</option>`;
      }
    }
    if (el.shapeSelect.options.length > 0) {
      const name = el.shapeSelect.options[0].value;
      el.shapeSelect.value = name;
      const group = shapeGroups[name];
      firstKey = group?.top || group?.bottom;
    }
  } else {
    for (const [key, shape] of Object.entries(shapes)) {
      if (shape.type === state.currentShapeType) {
        el.shapeSelect.innerHTML += `<option value="${key}">${shape.name}</option>`;
        if (!firstKey) firstKey = key;
      }
    }
    if (firstKey) el.shapeSelect.value = firstKey;
  }

  state.currentShape = firstKey;
  load3DModel(getCurrentShape());
}

// ========== 3D VIEWER FUNCTIONS ==========
function show3DStatus(msg) {
  el.viewer3DStatus.textContent = msg;
  el.viewer3DStatus.classList.remove('hidden');
}

function hide3DStatus() {
  el.viewer3DStatus.classList.add('hidden');
}

function show3DLoading() {
  el.viewer3DLoading.classList.remove('hidden');
  hide3DStatus();
}

function hide3DLoading() {
  el.viewer3DLoading.classList.add('hidden');
}

async function load3DModel(shape) {
  state.isModelLoaded = false;
  if (!shape?.modelPath) {
    show3DStatus("No 3D model");
    el.modelViewer.src = "";
    return;
  }
  show3DLoading();
  el.modelViewer.src = shape.modelPath + "?t=" + Date.now();
}

async function applyTextureToModel() {
  if (!el.modelViewer.model || !state.textureDataUrl) return;
  
  const shape = getCurrentShape();
  const materials = el.modelViewer.model.materials;
  if (!materials?.length) return;

  const names = shape?.targetMaterials || ["Texture", "Label", "Bottom"];
  let material = materials.find(m => names.some(n => 
    m.name === n || m.name.toLowerCase().includes(n.toLowerCase())
  )) || materials[0];

  try {
    const texture = await el.modelViewer.createTexture(state.textureDataUrl);
    if (texture && material.pbrMetallicRoughness?.baseColorTexture) {
      material.pbrMetallicRoughness.baseColorTexture.setTexture(texture);
    }
  } catch (e) {
    console.warn("Texture apply failed:", e);
  }
}

el.modelViewer.addEventListener("load", async () => {
  state.isModelLoaded = true;
  hide3DLoading();
  hide3DStatus();
  
  let attempts = 0;
  while (!el.modelViewer.model && attempts++ < 50) await new Promise(r => setTimeout(r, 50));
  
  if (state.textureDataUrl && el.modelViewer.model) {
    await applyTextureToModel();
  }
});

el.modelViewer.addEventListener("error", () => {
  hide3DLoading();
  show3DStatus("Load failed");
  state.isModelLoaded = false;
});

el.viewer3DToggle.addEventListener("click", e => {
  e.stopPropagation();
  state.isViewer3DMinimized = !state.isViewer3DMinimized;
  el.viewer3DContainer.classList.toggle('w-20', state.isViewer3DMinimized);
  el.viewer3DContainer.classList.toggle('h-7', state.isViewer3DMinimized);
  el.viewer3DContainer.classList.toggle('w-48', !state.isViewer3DMinimized);
  el.viewer3DContainer.classList.toggle('h-48', !state.isViewer3DMinimized);
});

el.viewer3DExpand.addEventListener("click", e => {
  e.stopPropagation();
  if (state.isViewer3DMinimized) return;
  state.isViewer3DExpanded = !state.isViewer3DExpanded;
  el.viewer3DContainer.classList.toggle('w-96', state.isViewer3DExpanded);
  el.viewer3DContainer.classList.toggle('h-80', state.isViewer3DExpanded);
  el.viewer3DContainer.classList.toggle('w-48', !state.isViewer3DExpanded);
  el.viewer3DContainer.classList.toggle('h-48', !state.isViewer3DExpanded);
});

// ========== DOWNLOAD HELPER ==========
function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}

// Export to window
window.state = state;
window.el = el;
window.shapes = shapes;
window.shapeGroups = shapeGroups;
window.keyToGroupName = keyToGroupName;
window.EXPORT_SCALE = EXPORT_SCALE;
window.showLoading = showLoading;
window.updateLoading = updateLoading;
window.hideLoading = hideLoading;
window.showError = showError;
window.hideError = hideError;
window.updateZoomUI = updateZoomUI;
window.zoomIn = zoomIn;
window.zoomOut = zoomOut;
window.resetView = resetView;
window.preProcessShapes = preProcessShapes;
window.getCurrentShape = getCurrentShape;
window.updateUploadPlaceholder = updateUploadPlaceholder;
window.toggleViewSelector = toggleViewSelector;
window.populateShapeTypes = populateShapeTypes;
window.updateShapeSelector = updateShapeSelector;
window.load3DModel = load3DModel;
window.applyTextureToModel = applyTextureToModel;
window.downloadBlob = downloadBlob;
</script>

<!-- END OF PART 1 -->
<!-- Part 2 continues with rendering, export functions, file upload, and event handlers -->
<!-- SCRIPT PART 3: Rendering with Proper Layer Handling -->
<script type="module">
// ========== IMPROVED SVG RENDERING WITH LAYERS ==========

// Transform all layers and store them
function transformAllLayers(shape) {
  if (!state.svgContent || !state.svgLayers || !shape.topPath || !shape.bottomPath) {
    state.transformedLayers = [];
    return;
  }

  const srcW = state.svgDimensions?.width || shape.uploadDimensions?.width || 1000;
  const srcH = state.svgDimensions?.height || shape.uploadDimensions?.height || 1000;

  const warper = new MeshWarper(shape.topPath, shape.bottomPath, srcW, srcH, {
    gridCols: 100,
    gridRows: 40,
    topIsReversed: shape.topIsReversed,
    bottomIsReversed: shape.bottomIsReversed
  });

  const transformer = new SVGDocTransformer(warper, srcW, srcH);
  const transformedLayers = [];

  // Transform each layer individually
  for (let i = 0; i < state.svgLayers.layers.length; i++) {
    const layer = state.svgLayers.layers[i];
    
    try {
      // Wrap layer content in SVG for transformation
      const layerSVG = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
                         viewBox="0 0 ${srcW} ${srcH}" width="${srcW}" height="${srcH}">
                         ${state.svgLayers.defs}
                         <g id="${layer.id}">${layer.content}</g>
                       </svg>`;
      
      const transformed = transformer.transform(layerSVG, shape.width, shape.height);
      
      // Parse transformed SVG to extract just the layer content
      const parser = new DOMParser();
      const doc = parser.parseFromString(transformed, 'image/svg+xml');
      const svg = doc.querySelector('svg');
      
      if (svg) {
        // Get all content except defs
        let layerContent = '';
        const defs = svg.querySelector('defs');
        const defsContent = defs ? new XMLSerializer().serializeToString(defs) : '';
        
        for (const child of svg.children) {
          if (child.tagName.toLowerCase() !== 'defs') {
            layerContent += new XMLSerializer().serializeToString(child);
          }
        }
        
        transformedLayers.push({
          id: layer.id,
          name: layer.name,
          content: layerContent,
          defs: defsContent,
          zIndex: layer.zIndex || i
        });
      }
    } catch (e) {
      console.warn(`Failed to transform layer ${layer.name}:`, e);
      // Keep original content as fallback
      transformedLayers.push({
        id: layer.id,
        name: layer.name,
        content: layer.content,
        defs: '',
        zIndex: layer.zIndex || i
      });
    }
  }

  // Sort by zIndex to maintain proper order
  transformedLayers.sort((a, b) => a.zIndex - b.zIndex);
  state.transformedLayers = transformedLayers;
}

function render() {
  const shape = getCurrentShape();
  
  // Clear all layers
  el.backgroundLayer.innerHTML = '';
  el.imageLayer.innerHTML = '';
  el.outlineLayer.innerHTML = '';
  el.svgDefs.innerHTML = '';

  if (!shape) {
    el.mainSvg.setAttribute('viewBox', '0 0 400 200');
    el.backgroundLayer.innerHTML = `<text x="200" y="100" text-anchor="middle" fill="#9ca3af" font-size="14">No shape selected</text>`;
    return;
  }

  const padding = 20;
  const vbW = shape.width + padding * 2;
  const vbH = shape.height + padding * 2;
  
  el.mainSvg.setAttribute('viewBox', `${-padding + state.panX / state.zoom} ${-padding + state.panY / state.zoom} ${vbW / state.zoom} ${vbH / state.zoom}`);
  el.mainSvg.setAttribute('width', '100%');
  el.mainSvg.setAttribute('height', '100%');

  // Create clip path in defs
  const clipId = `clip-${state.currentShape}-${Date.now()}`;
  el.svgDefs.innerHTML = `
    <clipPath id="${clipId}">
      <path d="${shape.path}" />
    </clipPath>
  `;

  // Background layer - white fill for shape area
  el.backgroundLayer.innerHTML = `
    <path d="${shape.path}" fill="#ffffff" />
  `;

  // Image layer - warped image content
  if (state.image) {
    if (state.svgContent && shape.topPath && shape.bottomPath) {
      // Vector SVG - transform and display layers
      renderVectorLayers(shape, clipId);
    } else {
      // Raster image - render as warped image
      renderRasterContent(shape, clipId);
    }
  } else {
    // Placeholder
    el.imageLayer.innerHTML = `
      <g clip-path="url(#${clipId})">
        <path d="${shape.path}" fill="#f3f4f6" />
        <text x="${shape.width / 2}" y="${shape.height / 2}" text-anchor="middle" fill="#9ca3af" font-size="12">
          Upload an image
        </text>
      </g>
    `;
  }

  // Outline layer - red stroke (always on top)
  el.outlineLayer.innerHTML = `
    <path d="${shape.path}" fill="none" stroke="#ed312c" stroke-width="2" vector-effect="non-scaling-stroke" />
  `;
}

function renderVectorLayers(shape, clipId) {
  // Transform layers if not already done or if shape changed
  if (state.transformedLayers.length === 0 || state.transformedLayers._shapeId !== state.currentShape) {
    transformAllLayers(shape);
    state.transformedLayers._shapeId = state.currentShape;
  }

  if (state.transformedLayers.length === 0) {
    // Fallback to raster if transformation failed
    renderRasterContent(shape, clipId);
    return;
  }

  // Collect all defs from transformed layers
  let allDefs = '';
  for (const layer of state.transformedLayers) {
    if (layer.defs) {
      // Extract content from defs tag
      const defsMatch = layer.defs.match(/<defs[^>]*>([\s\S]*?)<\/defs>/i);
      if (defsMatch) {
        allDefs += defsMatch[1];
      }
    }
  }
  
  // Add collected defs
  if (allDefs) {
    el.svgDefs.innerHTML += allDefs;
  }

  // Create clipped group for all layers
  const clipGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  clipGroup.setAttribute('clip-path', `url(#${clipId})`);

  // Render each layer in order
  for (const layer of state.transformedLayers) {
    const layerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    layerGroup.setAttribute('id', `render-${layer.id}`);
    layerGroup.setAttribute('data-name', layer.name);
    layerGroup.innerHTML = layer.content;
    clipGroup.appendChild(layerGroup);
  }

  el.imageLayer.appendChild(clipGroup);
}

function renderRasterContent(shape, clipId) {
  if (!state.imageDataUrl) return;
  
  // For curved shapes, we need to warp image
  if (shape.topPath && shape.bottomPath && shape.type !== 'rectangle') {
    // Create warped image using canvas
    const canvas = document.createElement('canvas');
    const scale = 2; // Higher quality
    canvas.width = shape.width * scale;
    canvas.height = shape.height * scale;
    const ctx = canvas.getContext('2d');
    
    ctx.scale(scale, scale);
    drawWarpedImage(ctx, state.image, shape);
    
    const dataUrl = canvas.toDataURL('image/png');
    el.imageLayer.innerHTML = `
      <g clip-path="url(#${clipId})">
        <image href="${dataUrl}" x="0" y="0" width="${shape.width}" height="${shape.height}" preserveAspectRatio="none" />
      </g>
    `;
  } else {
    // Simple image placement for rectangles
    el.imageLayer.innerHTML = `
      <g clip-path="url(#${clipId})">
        <image href="${state.imageDataUrl}" x="0" y="0" width="${shape.width}" height="${shape.height}" preserveAspectRatio="none" />
      </g>
    `;
  }
}

function drawWarpedImage(ctx, img, shape) {
  const cols = 80, rows = 35;
  const warper = new MeshWarper(shape.topPath, shape.bottomPath, img.width, img.height, {
    gridCols: cols,
    gridRows: rows,
    topIsReversed: shape.topIsReversed,
    bottomIsReversed: shape.bottomIsReversed
  });

  const mesh = warper.mesh;
  const cellW = img.width / cols;
  const cellH = img.height / rows;

  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const p00 = mesh[row][col];
      const p01 = mesh[row][col + 1];
      const p10 = mesh[row + 1][col];
      const p11 = mesh[row + 1][col + 1];

      const srcX = col * cellW;
      const srcY = row * cellH;

      // Draw two triangles per cell
      drawTriangle(ctx, img,
        srcX, srcY, srcX + cellW, srcY, srcX, srcY + cellH,
        p00.x, p00.y, p01.x, p01.y, p10.x, p10.y
      );
      drawTriangle(ctx, img,
        srcX + cellW, srcY, srcX + cellW, srcY + cellH, srcX, srcY + cellH,
        p01.x, p01.y, p11.x, p11.y, p10.x, p10.y
      );
    }
  }
}

function drawTriangle(ctx, img, sx0, sy0, sx1, sy1, sx2, sy2, dx0, dy0, dx1, dy1, dx2, dy2) {
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(dx0, dy0);
  ctx.lineTo(dx1, dy1);
  ctx.lineTo(dx2, dy2);
  ctx.closePath();
  ctx.clip();

  const denom = sx0 * (sy1 - sy2) + sx1 * (sy2 - sy0) + sx2 * (sy0 - sy1);
  if (Math.abs(denom) < 0.001) { ctx.restore(); return; }

  const a = (dx0 * (sy1 - sy2) + dx1 * (sy2 - sy0) + dx2 * (sy0 - sy1)) / denom;
  const b = (dx0 * (sx2 - sx1) + dx1 * (sx0 - sx2) + dx2 * (sx1 - sx0)) / denom;
  const c = (dx0 * (sx1*sy2 - sx2*sy1) + dx1 * (sx2*sy0 - sx0*sy2) + dx2 * (sx0*sy1 - sx1*sy0)) / denom;
  const d = (dy0 * (sy1 - sy2) + dy1 * (sy2 - sy0) + dy2 * (sy0 - sy1)) / denom;
  const e = (dy0 * (sx2 - sx1) + dy1 * (sx0 - sx2) + dy2 * (sx1 - sx0)) / denom;
  const f = (dy0 * (sx1*sy2 - sx2*sy1) + dy1 * (sx2*sy0 - sx0*sy2) + dy2 * (sx0*sy1 - sx1*sy0)) / denom;

  ctx.transform(a, d, b, e, c, f);
  ctx.drawImage(img, 0, 0);
  ctx.restore();
}

// Export to window
window.transformAllLayers = transformAllLayers;
window.render = render;
window.renderVectorLayers = renderVectorLayers;
window.renderRasterContent = renderRasterContent;
window.drawWarpedImage = drawWarpedImage;
window.drawTriangle = drawTriangle;
</script>

<!-- SCRIPT PART 4: Fixed Export Functions -->
<script type="module">
// ========== IMPROVED EXPORT FUNCTIONS ==========

function generateExportSVG(includeOutline = true) {
  const shape = getCurrentShape();
  if (!shape) return null;

  const clipId = 'export-clip';
  
  // Start building SVG
  let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
     viewBox="0 0 ${shape.width} ${shape.height}" width="${shape.width}" height="${shape.height}">
  <defs>
    <clipPath id="${clipId}">
      <path d="${shape.path}" />
    </clipPath>
`;

  // Add all defs from transformed layers
  if (state.transformedLayers && state.transformedLayers.length > 0) {
    const addedDefs = new Set();
    for (const layer of state.transformedLayers) {
      if (layer.defs) {
        const defsMatch = layer.defs.match(/<defs[^>]*>([\s\S]*?)<\/defs>/i);
        if (defsMatch && !addedDefs.has(defsMatch[1])) {
          svgContent += `    ${defsMatch[1]}\n`;
          addedDefs.add(defsMatch[1]);
        }
      }
    }
  }

  svgContent += `  </defs>

  <!-- Background Layer -->
  <g id="background-layer" data-name="Background">
    <path d="${shape.path}" fill="#ffffff" />
  </g>

  <!-- Content Layers -->
  <g id="content-layers" clip-path="url(#${clipId})">
`;

  // Add image content with proper layer structure
  if (state.image) {
    if (state.svgContent && shape.topPath && shape.bottomPath && state.transformedLayers.length > 0) {
      // Vector content - add each transformed layer
      for (let i = 0; i < state.transformedLayers.length; i++) {
        const layer = state.transformedLayers[i];
        svgContent += `
    <!-- Layer ${i + 1}: ${layer.name} -->
    <g id="layer-${layer.id}" data-name="${layer.name}" data-index="${i}">
${indentContent(layer.content, 6)}
    </g>
`;
      }
    } else {
      // Raster - create high-res warped version
      const canvas = document.createElement('canvas');
      canvas.width = shape.width * EXPORT_SCALE;
      canvas.height = shape.height * EXPORT_SCALE;
      const ctx = canvas.getContext('2d');
      ctx.scale(EXPORT_SCALE, EXPORT_SCALE);
      
      if (shape.topPath && shape.bottomPath && shape.type !== 'rectangle') {
        drawWarpedImage(ctx, state.image, shape);
      } else {
        ctx.drawImage(state.image, 0, 0, shape.width, shape.height);
      }
      
      svgContent += `
    <!-- Raster Image Layer -->
    <g id="raster-layer" data-name="Image">
      <image href="${canvas.toDataURL('image/png')}" x="0" y="0" width="${shape.width}" height="${shape.height}" />
    </g>
`;
    }
  }

  svgContent += `  </g>
`;

  // Add outline layer
  if (includeOutline) {
    svgContent += `
  <!-- Outline Layer -->
  <g id="outline-layer" data-name="Outline">
    <path d="${shape.path}" fill="none" stroke="#ed312c" stroke-width="2" />
  </g>
`;
  }

  svgContent += `</svg>`;

  return svgContent;
}

// Helper function to indent content for cleaner SVG output
function indentContent(content, spaces) {
  const indent = ' '.repeat(spaces);
  return content.split('\n').map(line => indent + line).join('\n');
}

async function exportPNG() {
  if (state.isExporting || !state.image) {
    if (!state.image) showError("No Image", "Please upload an image first.");
    return;
  }

  state.isExporting = true;
  showLoading("Exporting PNG...", "Rendering high-resolution image");

  await new Promise(r => setTimeout(r, 50));

  try {
    const shape = getCurrentShape();
    const canvas = document.createElement('canvas');
    canvas.width = shape.width * EXPORT_SCALE;
    canvas.height = shape.height * EXPORT_SCALE;
    const ctx = canvas.getContext('2d');
    
    ctx.scale(EXPORT_SCALE, EXPORT_SCALE);
    
    // Fill background white
    ctx.fillStyle = '#ffffff';
    ctx.fill(new Path2D(shape.path));
    
    // Draw clipped content
    ctx.save();
    const clipPath = new Path2D(shape.path);
    ctx.clip(clipPath);
    
    if (state.svgContent && state.transformedLayers.length > 0) {
      // Render SVG layers to canvas
      await renderSVGToCanvas(ctx, shape);
    } else if (shape.topPath && shape.bottomPath && shape.type !== 'rectangle') {
      drawWarpedImage(ctx, state.image, shape);
    } else {
      ctx.drawImage(state.image, 0, 0, shape.width, shape.height);
    }
    ctx.restore();

    // Draw outline
    ctx.strokeStyle = '#ed312c';
    ctx.lineWidth = 2 / EXPORT_SCALE;
    ctx.stroke(new Path2D(shape.path));

    updateLoading("Exporting PNG...", "Creating file");
    
    canvas.toBlob(blob => {
      downloadBlob(blob, `${state.currentShape}_Wrap.png`);
      hideLoading();
    }, 'image/png', 1.0);
    
  } catch (e) {
    console.error("PNG export error:", e);
    hideLoading();
    showError("Export Failed", "Failed to generate PNG file.");
  }
}

// Helper to render SVG to canvas with proper layer order
async function renderSVGToCanvas(ctx, shape) {
  // Create temporary SVG
  const svgContent = generateExportSVG(false);
  if (!svgContent) {
    drawWarpedImage(ctx, state.image, shape);
    return;
  }

  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      ctx.drawImage(img, 0, 0, shape.width, shape.height);
      URL.revokeObjectURL(img.src);
      resolve();
    };
    img.onerror = () => {
      console.warn("SVG to canvas failed, falling back to raster");
      drawWarpedImage(ctx, state.image, shape);
      resolve();
    };
    
    const blob = new Blob([svgContent], { type: 'image/svg+xml' });
    img.src = URL.createObjectURL(blob);
  });
}

async function exportSVG() {
  if (state.isExporting || !state.image) {
    if (!state.image) showError("No Image", "Please upload an image first.");
    return;
  }

  state.isExporting = true;
  showLoading("Exporting SVG...", "Generating layered SVG");

  await new Promise(r => setTimeout(r, 50));

  try {
    // Ensure layers are transformed
    const shape = getCurrentShape();
    if (state.svgContent && (!state.transformedLayers || state.transformedLayers.length === 0)) {
      updateLoading("Exporting SVG...", "Transforming layers");
      transformAllLayers(shape);
    }

    updateLoading("Exporting SVG...", "Building SVG structure");
    const svgContent = generateExportSVG(true);
    if (!svgContent) throw new Error("Failed to generate SVG");

    // Validate SVG
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgContent, 'image/svg+xml');
    const parseError = doc.querySelector('parsererror');
    if (parseError) {
      throw new Error("Generated invalid SVG: " + parseError.textContent);
    }

    const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
    downloadBlob(blob, `${state.currentShape}_Wrap.svg`);
    hideLoading();
  } catch (e) {
    console.error("SVG export error:", e);
    hideLoading();
    showError("Export Failed", "Failed to generate SVG file: " + e.message);
  }
}

async function exportPDF() {
  if (state.isExporting || !state.image) {
    if (!state.image) showError("No Image", "Please upload an image first.");
    return;
  }

  if (typeof window.jspdf === 'undefined') {
    showError("Library Error", "PDF library not loaded. Please refresh.");
    return;
  }

  state.isExporting = true;
  showLoading("Exporting PDF...", "Creating document");

  await new Promise(r => setTimeout(r, 50));

  try {
    const { jsPDF } = window.jspdf;
    const shape = getCurrentShape();
    
    // Ensure layers are transformed
    if (state.svgContent && (!state.transformedLayers || state.transformedLayers.length === 0)) {
      updateLoading("Exporting PDF...", "Transforming layers");
      transformAllLayers(shape);
    }

    // Create PDF with exact dimensions
    const pdf = new jsPDF({
      orientation: shape.width > shape.height ? 'landscape' : 'portrait',
      unit: 'pt',
      format: [shape.width, shape.height]
    });

    // Render content to canvas first
    updateLoading("Exporting PDF...", "Rendering content");
    
    const canvas = document.createElement('canvas');
    const scale = 3; // Good balance between quality and file size
    canvas.width = shape.width * scale;
    canvas.height = shape.height * scale;
    const ctx = canvas.getContext('2d');
    ctx.scale(scale, scale);

    // Fill background white
    ctx.fillStyle = '#ffffff';
    ctx.fill(new Path2D(shape.path));

    // Clip to shape
    ctx.save();
    ctx.clip(new Path2D(shape.path));

    // Render layers
    if (state.svgContent && state.transformedLayers.length > 0) {
      await renderSVGToCanvas(ctx, shape);
    } else if (shape.topPath && shape.bottomPath && shape.type !== 'rectangle') {
      drawWarpedImage(ctx, state.image, shape);
    } else {
      ctx.drawImage(state.image, 0, 0, shape.width, shape.height);
    }
    ctx.restore();

    // Add image to PDF
    updateLoading("Exporting PDF...", "Adding to PDF");
    const imgData = canvas.toDataURL('image/png');
    pdf.addImage(imgData, 'PNG', 0, 0, shape.width, shape.height);

    // Draw outline
    pdf.setDrawColor(237, 49, 44); // #ed312c
    pdf.setLineWidth(2);
    
    // Sample path for outline
    const pathSampler = new PathSampler(shape.path);
    const points = [];
    const numPoints = 200;
    for (let i = 0; i <= numPoints; i++) {
      const pt = pathSampler.getPointAt(i / numPoints);
      points.push([pt.x, pt.y]);
    }
    
    if (points.length > 0) {
      // Draw path as lines
      for (let i = 1; i < points.length; i++) {
        pdf.line(points[i-1][0], points[i-1][1], points[i][0], points[i][1]);
      }
      // Close path
      pdf.line(points[points.length-1][0], points[points.length-1][1], points[0][0], points[0][1]);
    }

    // Add metadata
    pdf.setProperties({
      title: `${shape.name} Wrap`,
      subject: 'Container wrap design',
      creator: 'Terra Tech Packs',
      keywords: 'wrap, packaging, label'
    });

    updateLoading("Exporting PDF...", "Saving file");
    pdf.save(`${state.currentShape}_Wrap.pdf`);
    hideLoading();
  } catch (e) {
    console.error("PDF export error:", e);
    hideLoading();
    showError("Export Failed", "Failed to generate PDF file: " + e.message);
  }
}

// Export to window
window.generateExportSVG = generateExportSVG;
window.exportPNG = exportPNG;
window.exportSVG = exportSVG;
window.exportPDF = exportPDF;
window.renderSVGToCanvas = renderSVGToCanvas;
</script>

<!-- SCRIPT PART 5: Enhanced File Upload Handler -->
<script type="module">
// ========== ENHANCED FILE UPLOAD HANDLER ==========
async function handleUpload(e) {
  const file = e.target.files?.[0];
  
  if (!file) {
    resetUploadState();
    return;
  }

  // Check file type and set appropriate badge
  const fileName = file.name.toLowerCase();
  let fileType = null;
  
  if (fileName.endsWith('.svg')) {
    fileType = 'svg';
  } else if (fileName.endsWith('.ai')) {
    fileType = 'ai';
  } else if (fileName.endsWith('.png')) {
    fileType = 'png';
  } else if (fileName.endsWith('.jpg') || fileName.endsWith('.jpeg')) {
    fileType = 'jpg';
  } else {
    showError("Unsupported File Type", "Please upload an SVG, AI, PNG, or JPG file.");
    resetUploadState();
    return;
  }

  // Update file type badge
  el.fileTypeBadge.textContent = fileType.toUpperCase();
  el.fileTypeBadge.className = `file-type-badge ${fileType}-badge`;
  el.fileTypeBadge.classList.remove('hidden');
  
  state.fileType = fileType;

  // Handle AI files
  if (fileType === 'ai') {
    try {
      showLoading("Processing AI file...", "Converting to SVG");
      await AIToSVGConverter.convert(file);
    } catch (error) {
      hideLoading();
      showError("AI File Processing", error.message);
      resetUploadState();
      return;
    }
  }

  // Process SVG files
  if (fileType === 'svg') {
    try {
      showLoading("Loading SVG...", "Parsing file content");
      
      const text = await file.text();
      
      // Parse and normalize SVG
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, 'image/svg+xml');
      const svg = doc.querySelector('svg');
      
      if (!svg) throw new Error('Invalid SVG file');
      
      // Check for parse errors
      const parseError = doc.querySelector('parsererror');
      if (parseError) {
        throw new Error('SVG parsing error: ' + parseError.textContent.substring(0, 100));
      }
      
      // Get dimensions
      let w = parseFloat(svg.getAttribute('width'));
      let h = parseFloat(svg.getAttribute('height'));
      const vb = svg.getAttribute('viewBox');
      
      if ((!w || !h) && vb) {
        const parts = vb.split(/[\s,]+/).map(Number);
        if (parts.length === 4) { 
          w = w || parts[2]; 
          h = h || parts[3]; 
        }
      }
      
      w = w || 1000;
      h = h || 1000;
      
      state.svgDimensions = { width: w, height: h };
      
      // Normalize SVG
      svg.setAttribute('width', w);
      svg.setAttribute('height', h);
      if (!vb) svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
      
      // Add xmlns:xlink if missing
      if (!svg.getAttribute('xmlns:xlink')) {
        svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
      }
      
      const normalizedSvg = new XMLSerializer().serializeToString(doc);
      state.svgContent = normalizedSvg;
      
      // Extract layers
      updateLoading("Loading SVG...", "Extracting layers");
      const layerInfo = LayerExtractor.extractLayers(normalizedSvg);
      state.svgLayers = layerInfo;
      
      console.log(`Found ${layerInfo.layers.length} layers:`, layerInfo.layers.map(l => l.name));
      
      // Clear transformed layers to force re-transformation
      state.transformedLayers = [];
      
      // Create image for preview
      updateLoading("Loading SVG...", "Creating preview");
      const blob = new Blob([normalizedSvg], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      
      const img = new Image();
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = () => reject(new Error('Failed to load SVG as image'));
        img.src = url;
      });
      
      URL.revokeObjectURL(url);
      state.image = img;
      
      // Create texture for 3D
      const texCanvas = document.createElement('canvas');
      texCanvas.width = w;
      texCanvas.height = h;
      const texCtx = texCanvas.getContext('2d');
      texCtx.drawImage(img, 0, 0);
      state.textureDataUrl = texCanvas.toDataURL('image/png');
      state.imageDataUrl = state.textureDataUrl;
      
      // Update filename display
      let name = file.name;
      const dotIdx = name.lastIndexOf('.');
      if (dotIdx > 12) name = name.substring(0, 12) + '...' + name.substring(dotIdx);
      el.uploadText.textContent = name;
      
      // Transform layers for current shape
      updateLoading("Loading SVG...", "Transforming layers");
      const shape = getCurrentShape();
      if (shape && shape.topPath && shape.bottomPath) {
        transformAllLayers(shape);
      }
      
      // Apply to 3D model
      if (state.isModelLoaded && el.modelViewer.model) {
        await applyTextureToModel();
      }
      
      render();
      hideLoading();
      
    } catch (e) {
      console.error("SVG upload error:", e);
      hideLoading();
      showError("SVG Upload Failed", e.message || "Could not load the SVG file. Please check the file format.");
      resetUploadState();
    }
  } 
  // Process raster files (PNG, JPG)
  else if (fileType === 'png' || fileType === 'jpg') {
    try {
      showLoading("Loading image...", "Reading file");
      
      const dataUrl = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(file);
      });
      
      const img = new Image();
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = () => reject(new Error('Failed to load image'));
        img.src = dataUrl;
      });
      
      state.image = img;
      state.imageDataUrl = dataUrl;
      state.svgContent = null;
      state.svgDimensions = null;
      state.svgLayers = null;
      state.transformedLayers = [];
      
      // Create texture for 3D
      const texCanvas = document.createElement('canvas');
      texCanvas.width = img.width;
      texCanvas.height = img.height;
      const texCtx = texCanvas.getContext('2d');
      texCtx.drawImage(img, 0, 0);
      state.textureDataUrl = texCanvas.toDataURL('image/png');
      
      // Update filename display
      let name = file.name;
      const dotIdx = name.lastIndexOf('.');
      if (dotIdx > 12) name = name.substring(0, 12) + '...' + name.substring(dotIdx);
      el.uploadText.textContent = name;
      
      // Apply to 3D model
      if (state.isModelLoaded && el.modelViewer.model) {
        await applyTextureToModel();
      }
      
      render();
      hideLoading();
      
    } catch (e) {
      console.error("Image upload error:", e);
      hideLoading();
      showError("Image Upload Failed", e.message || "Could not load the image file. Please try a different file.");
      resetUploadState();
    }
  }
}

function resetUploadState() {
  state.image = null;
  state.imageDataUrl = null;
  state.textureDataUrl = null;
  state.svgContent = null;
  state.svgDimensions = null;
  state.svgLayers = null;
  state.transformedLayers = [];
  state.fileType = null;
  el.fileInput.value = '';
  el.fileTypeBadge.classList.add('hidden');
  updateUploadPlaceholder();
  render();
}

// Export to window
window.handleUpload = handleUpload;
window.resetUploadState = resetUploadState;
</script>

<!-- SCRIPT PART 6: Event Listeners and Initialization -->
<script type="module">
// ========== EVENT LISTENERS ==========
el.errorCloseBtn.addEventListener('click', hideError);
el.fileInput.addEventListener('input', handleUpload);
el.exportPngBtn.addEventListener('click', exportPNG);
el.exportSvgBtn.addEventListener('click', exportSVG);
el.exportPdfBtn.addEventListener('click', exportPDF);
el.zoomInBtn.addEventListener('click', zoomIn);
el.zoomOutBtn.addEventListener('click', zoomOut);
el.zoomDisplay.addEventListener('click', resetView);
el.resetViewBtn.addEventListener('click', resetView);

el.shapeTypeSelect.addEventListener('change', e => {
  state.currentShapeType = e.target.value;
  toggleViewSelector();
  updateShapeSelector();
  updateUploadPlaceholder();
  
  // Re-transform layers for new shape
  if (state.svgContent) {
    state.transformedLayers = [];
    const shape = getCurrentShape();
    if (shape && shape.topPath && shape.bottomPath) {
      transformAllLayers(shape);
    }
  }
  
  render();
});

el.shapeSelect.addEventListener('change', e => {
  const val = e.target.value;
  if (state.currentShapeType === "sweet_box" || state.currentShapeType === "sweet_box_te") {
    const group = shapeGroups[val];
    state.currentShape = group?.top || group?.bottom;
  } else {
    state.currentShape = val;
  }
  updateUploadPlaceholder();
  
  // Re-transform layers for new shape
  if (state.svgContent) {
    state.transformedLayers = [];
    const shape = getCurrentShape();
    if (shape && shape.topPath && shape.bottomPath) {
      transformAllLayers(shape);
    }
  }
  
  load3DModel(getCurrentShape());
  render();
});

document.querySelectorAll('input[name="view_type"]').forEach(radio => {
  radio.addEventListener('change', e => {
    state.currentView = e.target.value;
    const groupName = el.shapeSelect.value;
    const group = shapeGroups[groupName];
    const newKey = group?.[state.currentView];
    if (newKey) {
      state.currentShape = newKey;
      updateUploadPlaceholder();
      
      // Re-transform layers for new shape
      if (state.svgContent) {
        state.transformedLayers = [];
        const shape = getCurrentShape();
        if (shape && shape.topPath && shape.bottomPath) {
          transformAllLayers(shape);
        }
      }
      
      load3DModel(getCurrentShape());
      render();
    }
  });
});

// Zoom with wheel
el.svgContainer.addEventListener('wheel', e => {
  if (e.ctrlKey || e.metaKey) {
    e.preventDefault();
    e.deltaY < 0 ? zoomIn() : zoomOut();
  }
}, { passive: false });

// Pan with space + drag
window.addEventListener('keydown', e => {
  if (e.code === 'Space' && !e.repeat && state.zoom > 1) {
    e.preventDefault();
    state.isSpacePressed = true;
    el.svgContainer.style.cursor = 'grab';
  }
});

window.addEventListener('keyup', e => {
  if (e.code === 'Space') {
    state.isSpacePressed = false;
    state.isPanning = false;
    el.svgContainer.style.cursor = '';
  }
});

el.svgContainer.addEventListener('mousedown', e => {
  if (state.isSpacePressed && state.zoom > 1) {
    state.isPanning = true;
    state.lastMouse = { x: e.clientX, y: e.clientY };
    el.svgContainer.style.cursor = 'grabbing';
  }
});

window.addEventListener('mousemove', e => {
  if (state.isPanning) {
    const dx = e.clientX - state.lastMouse.x;
    const dy = e.clientY - state.lastMouse.y;
    state.panX += dx;
    state.panY += dy;
    state.lastMouse = { x: e.clientX, y: e.clientY };
    render();
    updateZoomUI();
  }
});

window.addEventListener('mouseup', () => {
  state.isPanning = false;
  el.svgContainer.style.cursor = state.isSpacePressed ? 'grab' : '';
});

// Enhanced drag & drop with visual feedback
const uploadLabel = el.uploadLabel;

uploadLabel.addEventListener('dragover', e => {
  e.preventDefault();
  uploadLabel.classList.add('border-blue-500', 'bg-blue-50');
});

uploadLabel.addEventListener('dragleave', () => {
  uploadLabel.classList.remove('border-blue-500', 'bg-blue-50');
});

uploadLabel.addEventListener('drop', e => {
  e.preventDefault();
  uploadLabel.classList.remove('border-blue-500', 'bg-blue-50');
  
  if (e.dataTransfer.files?.length) {
    el.fileInput.files = e.dataTransfer.files;
    el.fileInput.dispatchEvent(new Event('input', { bubbles: true }));
  }
});

// Keyboard shortcuts
document.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && !e.shiftKey) {
    if (e.key === 'p') { e.preventDefault(); exportPNG(); }
    else if (e.key === 's') { e.preventDefault(); exportSVG(); }
    else if (e.key === '=' || e.key === '+') { e.preventDefault(); zoomIn(); }
    else if (e.key === '-') { e.preventDefault(); zoomOut(); }
    else if (e.key === '0') { e.preventDefault(); resetView(); }
  }
});

// Window resize
window.addEventListener('resize', debounce(() => {
  render();
}, 150));

// ========== INITIALIZATION ==========
function init() {
  console.log('Initializing Terra Tech Packs KLD...');
  
  preProcessShapes();
  populateShapeTypes();
  toggleViewSelector();
  updateShapeSelector();
  updateUploadPlaceholder();
  updateZoomUI();
  render();
  
  console.log('Initialization complete.');
  console.log('Available shapes:', Object.keys(shapes));
}

// Start the application
init();

// Export to window
window.init = init;
</script>
</body>
</html>