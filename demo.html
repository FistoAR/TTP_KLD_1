<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Terra Tech Packs KLD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script
      type="module"
      src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.3.0/model-viewer.min.js"
    ></script>
    <style>
      .dragover { border-color: #3b82f6; }
      .radio-container.hidden { display: none; }
      
      /* Loading Overlay */
      .loading-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        flex-direction: column;
        backdrop-filter: blur(4px);
      }
      .loading-overlay.show { display: flex; }
      .loading-box {
        background: white;
        padding: 30px 50px;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
      }
      .spinner {
        border: 4px solid #e5e7eb;
        border-top: 4px solid #3b82f6;
        border-radius: 50%;
        width: 50px; height: 50px;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      .loading-text {
        color: #374151;
        font-size: 16px;
        font-weight: 500;
      }
      .loading-subtext {
        color: #9ca3af;
        font-size: 13px;
      }
      
      /* Error Popup Modal */
      .error-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1001;
        backdrop-filter: blur(2px);
      }
      .error-overlay.show { display: flex; }
      .error-popup {
        background: white;
        padding: 24px 32px;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 400px;
        width: 90%;
        text-align: center;
        animation: popIn 0.2s ease-out;
      }
      @keyframes popIn {
        0% { transform: scale(0.9); opacity: 0; }
        100% { transform: scale(1); opacity: 1; }
      }
      .error-icon {
        width: 56px;
        height: 56px;
        background: #fef2f2;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
      }
      .error-icon svg {
        width: 28px;
        height: 28px;
        fill: #ef4444;
      }
      .error-title {
        color: #1f2937;
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 8px;
      }
      .error-message {
        color: #6b7280;
        font-size: 14px;
        line-height: 1.5;
        margin-bottom: 20px;
        white-space: pre-line;
      }
      .error-close-btn {
        background: #3b82f6;
        color: white;
        border: none;
        padding: 10px 32px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
      }
      .error-close-btn:hover {
        background: #2563eb;
      }
      
      .site-logo {
        position: absolute;
        left: 2vw;
        top: 50%;
        transform: translateY(-50%);
        height: 2vw;
        object-fit: contain;
        z-index: 60;
      }
      @media (max-width: 420px) { .site-logo { display: none; } }
      @media (max-width: 640px) { .site-logo { height: 36px; left: 8px; } }
      
      /* 3D Viewer Container */
      #viewer3DContainer {
        position: absolute;
        top: 12px; right: 12px;
        width: 200px; height: 200px;
        background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
        border-radius: 12px;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
        overflow: hidden;
        z-index: 50;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
      }
      #viewer3DContainer:hover { box-shadow: 0 10px 35px rgba(0, 0, 0, 0.4); }
      #viewer3DContainer.expanded {
        width: 400px;
        height: 350px;
      }
      #modelViewer {
        width: 100%; height: 100%;
        display: block;
        --poster-color: transparent;
        --progress-bar-color: #3b82f6;
        --progress-bar-height: 2px;
      }
      .viewer3D-loading {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #64748b;
        font-size: 11px;
        text-align: center;
        z-index: 5;
        pointer-events: none;
      }
      .viewer3D-loading.hidden { display: none; }
      .viewer3D-loading .mini-spinner {
        width: 20px; height: 20px;
        border: 2px solid rgba(100, 116, 139, 0.3);
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 6px;
      }
      .viewer3D-status {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #64748b;
        font-size: 11px;
        text-align: center;
        z-index: 5;
        padding: 8px;
      }
      .viewer3D-status.hidden { display: none; }
      
      /* Viewer Controls */
      .viewer3D-controls {
        position: absolute;
        top: 6px; right: 6px;
        display: flex;
        gap: 4px;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.2s;
      }
      #viewer3DContainer:hover .viewer3D-controls { opacity: 1; }
      .viewer3D-btn {
        width: 24px; height: 24px;
        background: rgba(0, 0, 0, 0.6);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }
      .viewer3D-btn:hover { background: rgba(59, 130, 246, 0.8); }
      .viewer3D-btn svg { width: 14px; height: 14px; fill: #fff; }
      
      /* Minimized State */
      #viewer3DContainer.minimized { 
        width: 80px; 
        height: 28px; 
        cursor: pointer; 
      }
      #viewer3DContainer.minimized #modelViewer,
      #viewer3DContainer.minimized .viewer3D-loading,
      #viewer3DContainer.minimized .viewer3D-status { display: none !important; }
      #viewer3DContainer.minimized::after {
        content: "3D View";
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: #94a3b8;
        font-size: 11px;
        font-weight: 600;
      }
      #viewer3DContainer.minimized #viewer3DExpand { display: none !important; }
      #viewer3DContainer.minimized .viewer3D-controls {
        opacity: 1;
        top: 50%;
        right: 6px;
        transform: translateY(-50%);
      }
      
      @media (max-width: 768px) {
        #viewer3DContainer { width: 160px; height: 160px; top: 8px; right: 8px; }
        #viewer3DContainer.expanded { width: 300px; height: 260px; }
      }
      @media (max-width: 480px) {
        #viewer3DContainer { width: 130px; height: 130px; }
        #viewer3DContainer.expanded { width: 240px; height: 210px; }
        #viewer3DContainer.minimized { width: 70px; height: 24px; }
      }
      
      /* Disable buttons during loading */
      .export:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      /* Zoom Controls */
      .zoom-controls {
        position: absolute;
        bottom: 16px;
        left: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 40;
      }
      .zoom-btn-group {
        display: flex;
        justify-content: space-between;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        overflow: hidden;
        border: 1px solid #e2e8f0;
      }
      .zoom-btn {
        width: 100%;
        height: 36px;
        border: none;
        background: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        color: #475569;
        margin: 0 auto;
      }
      .zoom-btn:hover {
        background: #f1f5f9;
        color: #3b82f6;
      }
      .zoom-btn:active {
        background: #e2e8f0;
      }
      .zoom-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .zoom-btn:disabled:hover {
        background: white;
        color: #475569;
      }
      .zoom-btn svg {
        width: 18px;
        height: 18px;
        fill: currentColor;
      }
      .zoom-divider {
        width: 1px;
        background: #e2e8f0;
      }
      .zoom-display {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        padding: 6px 12px;
        font-size: 12px;
        font-weight: 600;
        color: #475569;
        text-align: center;
        min-width: 60px;
        border: 1px solid #e2e8f0;
        cursor: pointer;
        transition: all 0.2s;
      }
      .zoom-display:hover {
        background: #f1f5f9;
        color: #3b82f6;
      }
      
      /* Pan indicator */
      .pan-indicator {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 500;
        color: #64748b;
        text-align: center;
        border: 1px solid #e2e8f0;
        display: flex;
        align-items: center;
        gap: 6px;
        opacity: 0;
        transition: opacity 0.2s;
      }
      .pan-indicator.visible {
        opacity: 1;
      }
      .pan-indicator.active {
        background: #3b82f6;
        color: white;
        border-color: #3b82f6;
      }
      .pan-indicator svg {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }
      
      /* Reset pan button */
      .reset-pan-btn {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 500;
        color: #475569;
        text-align: center;
        border: 1px solid #e2e8f0;
        cursor: pointer;
        display: none;
        align-items: center;
        gap: 6px;
        transition: all 0.2s;
      }
      .reset-pan-btn:hover {
        background: #f1f5f9;
        color: #3b82f6;
      }
      .reset-pan-btn.visible {
        display: flex;
      }
      .reset-pan-btn svg {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }
      
      @media (max-width: 480px) {
        .zoom-controls {
          bottom: 12px;
          left: 12px;
        }
        .zoom-btn {
          width: 32px;
          height: 32px;
        }
        .zoom-btn svg {
          width: 16px;
          height: 16px;
        }
        .zoom-display {
          padding: 5px 10px;
          font-size: 11px;
          min-width: 50px;
        }
        .pan-indicator, .reset-pan-btn {
          font-size: 10px;
          padding: 5px 8px;
        }
      }

      /* Canvas container for panning */
      .canvas-container {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      
      /* Canvas cursor states */
      #warpCanvas {
        cursor: default;
      }
      #warpCanvas.can-pan {
        cursor: grab;
      }
      #warpCanvas.space-held {
        cursor: grab;
      }
      #warpCanvas.panning {
        cursor: grabbing !important;
      }
    </style>
  </head>
  <body class="bg-slate-100 flex flex-col h-screen overflow-hidden font-sans">
    <div class="bg-white shadow-md z-10 relative">
      <img src="./assets/terratechpacks.png" alt="Terra Tech Packs" class="site-logo" />
      <div class="container mx-auto pt-4 pb-3 flex justify-center items-end flex-wrap gap-x-6 gap-y-4">
        <div class="flex flex-col">
          <label for="shapeTypeSelect" class="text-xs font-semibold text-slate-600 mb-1">Select Shape Type:</label>
          <select id="shapeTypeSelect" class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 transition cursor-pointer"></select>
        </div>
        <div class="flex flex-col">
          <label for="shapeSelect" class="text-xs font-semibold text-slate-600 mb-1">Select Specific Shape:</label>
          <select id="shapeSelect" class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 transition cursor-pointer"></select>
        </div>
        <div id="viewSelector" class="hidden self-end pb-1">
          <div class="radio-group flex flex-col gap-1">
            <div class="radio-container">
              <input type="radio" id="viewTopRadio" name="view_type" value="top" class="cursor-pointer accent-blue-600" />
              <label for="viewTopRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Top</label>
            </div>
            <div class="radio-container">
              <input type="radio" id="viewBottomRadio" name="view_type" value="bottom" checked class="cursor-pointer accent-blue-600" />
              <label for="viewBottomRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Bottom</label>
            </div>
          </div>
        </div>
        <div id="dropArea" class="flex flex-col">
          <label for="imageUpload" class="text-xs font-semibold text-slate-600 mb-1">Upload Label:</label>
          <label class="file-upload-label h-12 min-w-[180px] flex items-center justify-center px-5 bg-slate-50 border-2 border-dashed border-slate-400 rounded-lg cursor-pointer hover:border-blue-500 transition" for="imageUpload">
            <input type="file" id="imageUpload" class="hidden" accept="image/*,.svg" />
            <small id="uploadText" class="font-medium text-slate-700">Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span></small>
          </label>
        </div>
        <button class="export h-12 px-6 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition" id="exportPngBtn">Export PNG</button>
        <button class="export h-12 px-6 bg-orange-500 text-white font-semibold rounded-lg hover:bg-orange-600 transition" id="exportSvgBtn">Export SVG</button>
        <button class="export h-12 px-6 bg-red-700 text-white font-semibold rounded-lg hover:bg-red-800 transition" id="exportPdfBtn">Export PDF</button>
      </div>
    </div>

    <div class="flex-grow p-4 md:p-6 flex items-center justify-center relative">
      <div class="canvas-container">
        <canvas id="warpCanvas" class="w-full h-full bg-white rounded-lg shadow-sm"></canvas>
      </div>
      
      <!-- Zoom Controls -->
      <div class="zoom-controls">
        <div class="zoom-btn-group">
          <button id="zoomInBtn" class="zoom-btn" title="Zoom In (Ctrl++)">
            <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
          </button>
          <div class="zoom-divider"></div>
          <button id="zoomOutBtn" class="zoom-btn" title="Zoom Out (Ctrl+-)">
            <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
          </button>
        </div>
        <div id="zoomDisplay" class="zoom-display" title="Click to reset zoom">100%</div>
        
        <!-- Pan indicator -->
        <div id="panIndicator" class="pan-indicator">
          <svg viewBox="0 0 24 24"><path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"/></svg>
          <span id="panIndicatorText">Hold Space + Drag</span>
        </div>
        
        <!-- Reset pan button -->
        <button id="resetPanBtn" class="reset-pan-btn" title="Reset pan position">
          <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
          <span>Reset View</span>
        </button>
      </div>
      
      <!-- 3D Viewer -->
      <div id="viewer3DContainer">
        <div class="viewer3D-controls">
          <button id="viewer3DExpand" class="viewer3D-btn" title="Expand">
            <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
          </button>
          <button id="viewer3DToggle" class="viewer3D-btn" title="Minimize">
            <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
          </button>
        </div>
        
        <div class="viewer3D-loading" id="viewer3DLoading">
          <div class="mini-spinner"></div>
          <span>Loading...</span>
        </div>
        <div class="viewer3D-status hidden" id="viewer3DStatus"></div>
        
        <model-viewer
          id="modelViewer"
          alt="3D product preview"
          camera-controls
          auto-rotate
          rotation-per-second="30deg"
          exposure="1.0"
          shadow-intensity="1"
          environment-image="neutral"
          interaction-prompt="none"
          style="background: transparent"
        ></model-viewer>
      </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-box">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Processing...</div>
        <div class="loading-subtext" id="loadingSubtext">Please wait</div>
      </div>
    </div>

    <!-- Error Popup Modal -->
    <div id="errorOverlay" class="error-overlay">
      <div class="error-popup">
        <div class="error-icon">
          <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
        </div>
        <div class="error-title" id="errorTitle">Error</div>
        <div class="error-message" id="errorMessage">Something went wrong.</div>
        <button class="error-close-btn" id="errorCloseBtn">OK</button>
      </div>
    </div>

    <script type="module">
      // ========== HELPERS ==========
      function debounce(fn, wait = 150) {
        let t;
        return (...args) => {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, args), wait);
        };
      }

      // ========== STATE ==========
      let currentImage = null;
      let currentImageDataUrl = null;
      let textureImageDataUrl = null;
      let currentView = "bottom";
      let currentShapeType = "round";
      let currentShape = "250ml_round";
      const EXPORT_SCALE = 6;
      let isExporting = false;

      // Zoom state
      let zoomLevel = 1;
      const MIN_ZOOM = 0.25;
      const MAX_ZOOM = 5;
      const ZOOM_STEP = 0.25;

      // Pan state
      let panX = 0;
      let panY = 0;
      let isPanning = false;
      let isSpacePressed = false;
      let lastMouseX = 0;
      let lastMouseY = 0;

      let isViewer3DMinimized = false;
      let isViewer3DExpanded = false;
      let isModelLoaded = false;

      const canvas = document.getElementById("warpCanvas");
      const ctx = canvas.getContext("2d");
      const uploadText = document.getElementById("uploadText");
      const fileInput = document.getElementById("imageUpload");
      const exportPngBtn = document.getElementById("exportPngBtn");
      const exportSvgBtn = document.getElementById("exportSvgBtn");
      const exportPdfBtn = document.getElementById("exportPdfBtn");
      const shapeTypeSelect = document.getElementById("shapeTypeSelect");
      const shapeSelect = document.getElementById("shapeSelect");
      const viewSelector = document.getElementById("viewSelector");
      
      // Loading elements
      const loadingOverlay = document.getElementById("loadingOverlay");
      const loadingText = document.getElementById("loadingText");
      const loadingSubtext = document.getElementById("loadingSubtext");
      
      // Error popup elements
      const errorOverlay = document.getElementById("errorOverlay");
      const errorTitle = document.getElementById("errorTitle");
      const errorMessage = document.getElementById("errorMessage");
      const errorCloseBtn = document.getElementById("errorCloseBtn");

      // Zoom elements
      const zoomInBtn = document.getElementById("zoomInBtn");
      const zoomOutBtn = document.getElementById("zoomOutBtn");
      const zoomDisplay = document.getElementById("zoomDisplay");
      
      // Pan elements
      const panIndicator = document.getElementById("panIndicator");
      const panIndicatorText = document.getElementById("panIndicatorText");
      const resetPanBtn = document.getElementById("resetPanBtn");

      const viewer3DContainer = document.getElementById("viewer3DContainer");
      const modelViewer = document.getElementById("modelViewer");
      const viewer3DLoading = document.getElementById("viewer3DLoading");
      const viewer3DStatus = document.getElementById("viewer3DStatus");
      const viewer3DToggle = document.getElementById("viewer3DToggle");
      const viewer3DExpand = document.getElementById("viewer3DExpand");

      // ========== ZOOM FUNCTIONS ==========
      
      function canPan() {
        return zoomLevel > 1;
      }

      function updateZoomDisplay() {
        const percentage = Math.round(zoomLevel * 100);
        zoomDisplay.textContent = `${percentage}%`;
        
        // Update button states
        zoomInBtn.disabled = zoomLevel >= MAX_ZOOM;
        zoomOutBtn.disabled = zoomLevel <= MIN_ZOOM;
        
        // Update pan indicator visibility
        if (canPan()) {
          panIndicator.classList.add("visible");
        } else {
          panIndicator.classList.remove("visible");
          panIndicator.classList.remove("active");
        }
        
        // Update reset pan button visibility
        if (panX !== 0 || panY !== 0) {
          resetPanBtn.classList.add("visible");
        } else {
          resetPanBtn.classList.remove("visible");
        }
        
        // Update canvas cursor
        updateCanvasCursor();
      }

      function updateCanvasCursor() {
        canvas.classList.remove("can-pan", "space-held", "panning");
        
        if (isPanning) {
          canvas.classList.add("panning");
        } else if (isSpacePressed && canPan()) {
          canvas.classList.add("space-held");
        } else if (canPan()) {
          canvas.classList.add("can-pan");
        }
      }

      function zoomIn() {
        if (zoomLevel < MAX_ZOOM) {
          zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
          
          // Reset pan if zooming back to 100% or below
          if (zoomLevel <= 1) {
            panX = 0;
            panY = 0;
          }
          
          mainDraw();
          updateZoomDisplay();
        }
      }

      function zoomOut() {
        if (zoomLevel > MIN_ZOOM) {
          zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
          
          // Reset pan if zooming back to 100% or below
          if (zoomLevel <= 1) {
            panX = 0;
            panY = 0;
          }
          
          mainDraw();
          updateZoomDisplay();
        }
      }

      function resetZoom() {
        zoomLevel = 1;
        panX = 0;
        panY = 0;
        mainDraw();
        updateZoomDisplay();
      }

      function resetPan() {
        panX = 0;
        panY = 0;
        mainDraw();
        updateZoomDisplay();
      }

      function handleWheelZoom(event) {
        // Check if Ctrl key is pressed for zoom
        if (event.ctrlKey || event.metaKey) {
          event.preventDefault();
          
          if (event.deltaY < 0) {
            zoomIn();
          } else {
            zoomOut();
          }
        }
      }

      // ========== PAN FUNCTIONS ==========
      
      function startPan(event) {
        if (!canPan()) return;
        if (!isSpacePressed && event.button !== 1) return; // Space must be held or middle mouse
        
        isPanning = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        
        updateCanvasCursor();
        panIndicator.classList.add("active");
        panIndicatorText.textContent = "Panning...";
        
        event.preventDefault();
      }

      function doPan(event) {
        if (!isPanning) return;
        
        const deltaX = event.clientX - lastMouseX;
        const deltaY = event.clientY - lastMouseY;
        
        panX += deltaX;
        panY += deltaY;
        
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        
        mainDraw();
        updateZoomDisplay();
      }

      function endPan() {
        if (isPanning) {
          isPanning = false;
          updateCanvasCursor();
          panIndicator.classList.remove("active");
          panIndicatorText.textContent = "Hold Space + Drag";
        }
      }

      function handleSpaceDown(event) {
        if (event.code === "Space" && !event.repeat && canPan()) {
          // Prevent default only if we're in the canvas area
          const activeElement = document.activeElement;
          const isInputFocused = activeElement && (
            activeElement.tagName === "INPUT" || 
            activeElement.tagName === "TEXTAREA" || 
            activeElement.tagName === "SELECT"
          );
          
          if (!isInputFocused) {
            event.preventDefault();
            isSpacePressed = true;
            updateCanvasCursor();
            panIndicator.classList.add("active");
            panIndicatorText.textContent = "Click & Drag to Pan";
          }
        }
      }

      function handleSpaceUp(event) {
        if (event.code === "Space") {
          isSpacePressed = false;
          if (!isPanning) {
            panIndicator.classList.remove("active");
            panIndicatorText.textContent = "Hold Space + Drag";
          }
          updateCanvasCursor();
          endPan();
        }
      }

      // Touch support for panning
      let touchStartX = 0;
      let touchStartY = 0;
      let isTouchPanning = false;

      function handleTouchStart(event) {
        if (!canPan()) return;
        if (event.touches.length === 2) {
          // Two finger touch for panning
          isTouchPanning = true;
          const touch = event.touches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          lastMouseX = touchStartX;
          lastMouseY = touchStartY;
          isPanning = true;
          updateCanvasCursor();
          event.preventDefault();
        }
      }

      function handleTouchMove(event) {
        if (!isTouchPanning || !isPanning) return;
        if (event.touches.length === 2) {
          const touch = event.touches[0];
          const deltaX = touch.clientX - lastMouseX;
          const deltaY = touch.clientY - lastMouseY;
          
          panX += deltaX;
          panY += deltaY;
          
          lastMouseX = touch.clientX;
          lastMouseY = touch.clientY;
          
          mainDraw();
          updateZoomDisplay();
          event.preventDefault();
        }
      }

      function handleTouchEnd() {
        isTouchPanning = false;
        endPan();
      }

      // ========== LOADING & ERROR FUNCTIONS ==========
      
      function showLoading(message = "Processing...", subtext = "Please wait") {
        loadingText.textContent = message;
        loadingSubtext.textContent = subtext;
        loadingOverlay.classList.add("show");
        exportPngBtn.disabled = true;
        exportSvgBtn.disabled = true;
        exportPdfBtn.disabled = true;
      }

      function updateLoading(message, subtext = "") {
        loadingText.textContent = message;
        if (subtext) loadingSubtext.textContent = subtext;
      }

      function hideLoading() {
        loadingOverlay.classList.remove("show");
        exportPngBtn.disabled = false;
        exportSvgBtn.disabled = false;
        exportPdfBtn.disabled = false;
        isExporting = false;
      }

      function showError(title, message) {
        errorTitle.textContent = title;
        errorMessage.textContent = message;
        errorOverlay.classList.add("show");
      }

      function hideError() {
        errorOverlay.classList.remove("show");
      }

      // Only close error modal when clicking OK button
      errorCloseBtn.addEventListener("click", hideError);

      // ========== DOWNLOAD HELPER ==========
      
      function triggerDownload(blob, filename) {
        return new Promise((resolve, reject) => {
          try {
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            link.style.display = "none";
            document.body.appendChild(link);
            
            setTimeout(() => {
              link.click();
              setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                resolve();
              }, 500);
            }, 100);
          } catch (error) {
            reject(error);
          }
        });
      }

      class PathSampler {
        constructor(pathData) {
          this.pathNode = document.createElementNS("http://www.w3.org/2000/svg", "path");
          this.pathNode.setAttribute("d", pathData);
          this.length = this.pathNode.getTotalLength();
        }
        getPointAt(percentage) {
          return this.pathNode.getPointAtLength(this.length * percentage);
        }
      }

      const shapeTypes = {
        round: "Round",
        round_square: "Round Square",
        rectangle: "Rectangle",
        sweet_box: "Sweet Box",
        sweet_box_te: "Sweet Box TE",
      };

      const COMMON_LABEL_MATERIALS = [
        "Bottom", "Label", "Wrap", "Decal", "Logo", "Sticker",
        "label", "bottom", "wrap", "decal", "logo", "sticker",
        "Material", "Material.001", "Material.002", "Material_0"
      ];

      const allBottleShapes = {
        "250ml_round": {
          type: "round",
          view: "bottom",
          name: "250ml Round",
          width: 837,
          height: 244,
          uploadDimensions: { width: 2908, height: 448 },
          path: "M1.37,162.42L73.32,242.27C283.84,56.41,576.84,75.5,764.01,242.27L835.96,162.42C597.61,-50.29,240.85,-53.15,1.37,162.42Z",
          topPath: "M 835.96,162.42 C 597.61,-50.29 240.85,-53.15 1.37,162.42",
          bottomPath: "M 73.32,242.27 C 283.84,56.41 576.84,75.5 764.01,242.27",
          topIsReversed: true,
          bottomIsReversed: false,
          modelPath: "./assets/models/250ml_round_t.glb",
          targetMaterials: ["Texture"],
        },
        "300ml_round": {
          type: "round",
          view: "bottom",
          name: "300ml Round",
          width: 986.98,
          height: 332.17,
          uploadDimensions: { width: 2906, height: 448 },
          path: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0l-5.32,1.98-45.71-122.15,6.01-2.21c286.86-105.52,601.92-105.52,888.78,0l6.04,2.15-45.75,122.2-5.3-1.98Z",
          topPath: "M49.08,172.19c286.86-105.52,601.92-105.52,888.78,0",
          bottomPath: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0",
          topIsReversed: false,
          bottomIsReversed: true,
          modelPath: "./assets/models/300ml_round_container.glb",
          targetMaterials: ["Bottom", "Label", "Wrap"],
        },
         "500ml_round": {
          type: "round",
          view: "bottom",
          name: "500ml Round",
          width: 945.18,
          height: 430.84,
          uploadDimensions: { width: 2890, height: 886 },
          path: "M846.13,387.86c-120.06-43.77-245.71-65.96-373.55-65.96s-252.55,22.02-372.2,65.47l-.61-1.56L24.95,193.11l2.66-.97c143.01-52.15,292.69-78.58,444.97-78.58s301.97,26.44,444.98,78.59l2.65,1.01-74.09,194.71Z",
          topPath:
            "M27.61,192.14c143.01-52.15,292.69-78.58,444.97-78.58s301.97,26.44,444.98,78.59",
          bottomPath:
            "M846.13,387.86c-120.06-43.77-245.71-65.96-373.55-65.96s-252.55,22.02-372.2,65.47",
          topIsReversed: false,
          bottomIsReversed: true,
          modelPath: "./assets/models/500ml_round_container_t.glb",
          targetMaterials: [" Texture"],
        },
        "750ml_round": {
          type: "round",
          view: "bottom",
          name: "750ml Round",
          width: 1187.25,
          height: 279.7,
          uploadDimensions: { width: 4360, height: 701 },
          path: "M3.26,122.79c376.81-163.05,803.93-163.05,1180.74,0l2.6,1.21-1.14,2.55-67.28,150.03-1.21,2.45-2.49-1.01c-332.55-143.26-709.13-143.26-1041.68,0l-2.54,1.04-1.17-2.48L1.8,126.55l-1.14-2.63,2.6-1.13Z",
          topPath: "M3.26,122.79c376.81-163.05,803.93-163.05,1180.74,0",
          bottomPath: "M1114.48,278.02c-332.55-143.26-709.13-143.26-1041.68,0",
          topIsReversed: false,
          bottomIsReversed: true,
          modelPath: "./assets/models/750ml_round_container_t.glb",
          targetMaterials: [" Texture"],
        },
        "1000ml_round": {
          type: "round",
          view: "bottom",
          name: "1000ml Round",
          width: 1186.89,
          height: 332.33,
          uploadDimensions: { width: 4153, height: 929 },
          path: "M97.62,331.03L114.97,323.22L137.59,313.59L160.4,304.43L183.4,295.74L206.58,287.53L229.93,279.8L253.44,272.55L277.1,265.79L300.9,259.51L324.82,253.73L348.86,248.44L373.02,243.64L397.25,239.35L421.59,235.56L446,232.27L470.46,229.48L494.99,227.2L519.56,225.42L544.16,224.15L568.78,223.39L593.42,223.14L618.06,223.39L642.68,224.15L667.28,225.42L691.84,227.2L716.36,229.48L740.84,232.27L765.25,235.56L789.58,239.35L813.82,243.64L837.98,248.44L862.02,253.73L885.93,259.51L909.74,265.79L933.4,272.55L956.9,279.8L980.26,287.53L1003.43,295.74L1026.43,304.43L1049.25,313.59L1071.87,323.22L1089.23,331.04L1091.77,332.1L1092.96,329.66L1185.4,132.99L1186.65,130.47L1184,129.2L1161.31,118.99L1134.45,107.56L1107.36,96.68L1080.05,86.36L1052.53,76.61L1024.8,67.43L996.9,58.83L968.81,50.8L940.56,43.35L912.17,36.48L883.63,30.21L854.97,24.52L826.19,19.42L797.32,14.92L768.35,11.01L739.31,7.71L710.21,5L681.06,2.89L651.87,1.39L622.65,.48L593.42,.18L564.19,.48L534.97,1.39L505.78,2.89L476.63,5L447.52,7.71L418.48,11.01L389.52,14.92L360.64,19.42L331.87,24.52L303.21,30.21L274.67,36.48L246.27,43.35L218.03,50.8L189.94,58.83L162.03,67.43L134.31,76.61L106.79,86.36L79.47,96.68L52.38,107.56L25.53,118.99L2.83,129.21L.24,130.46L1.42,132.99L93.89,329.65L95.16,332.1L97.62,331.03Z",
          topPath:
            "M2.83,129.21L25.53,118.99L52.38,107.56L79.47,96.68L106.79,86.36L134.31,76.61L162.03,67.43L189.94,58.83L218.03,50.8L246.27,43.35L274.67,36.48L303.21,30.21L331.87,24.52L360.64,19.42L389.52,14.92L418.48,11.01L447.52,7.71L476.63,5L505.78,2.89L534.97,1.39L564.19,.48L593.42,.18L622.65,.48L651.87,1.39L681.06,2.89L710.21,5L739.31,7.71L768.35,11.01L797.32,14.92L826.19,19.42L854.97,24.52L883.63,30.21L912.17,36.48L940.56,43.35L968.81,50.8L996.9,58.83L1024.8,67.43L1052.53,76.61L1080.05,86.36L1107.36,96.68L1134.45,107.56L1161.31,118.99L1184,129.2",
          bottomPath:
            "M97.62,331.03L114.97,323.22L137.59,313.59L160.4,304.43L183.4,295.74L206.58,287.53L229.93,279.8L253.44,272.55L277.1,265.79L300.9,259.51L324.82,253.73L348.86,248.44L373.02,243.64L397.25,239.35L421.59,235.56L446,232.27L470.46,229.48L494.99,227.2L519.56,225.42L544.16,224.15L568.78,223.39L593.42,223.14L618.06,223.39L642.68,224.15L667.28,225.42L691.84,227.2L716.36,229.48L740.84,232.27L765.25,235.56L789.58,239.35L813.82,243.64L837.98,248.44L862.02,253.73L885.93,259.51L909.74,265.79L933.4,272.55L956.9,279.8L980.26,287.53L1003.43,295.74L1026.43,304.43L1049.25,313.59L1071.87,323.22L1089.23,331.04",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/1000mlcontainer_t.glb",
          targetMaterials: [" Texture"],
        },
        "450ml_round_square": {
          type: "round_square",
          view: "bottom",
          name: "450ml Round Square",
          width: 879.22,
          height: 276.16,
          uploadDimensions: { width: 2923, height: 748 },
          path: "M93.16,274.8l9.48-5.52c16.09-9.47,32.49-18.51,49.08-27.07l8.02-3.94c9.34-4.49,18.91-8.56,28.62-12.17,8.99-3.3,18.11-6.37,27.27-9.18,15.76-4.79,31.65-9.33,47.56-13.57,18.8-5.19,37.79-9.92,56.83-14.14l9.07-1.84,8.27-1.5c10.82-1.83,21.76-3.15,32.71-3.94,9.81-.7,19.67-1.17,29.5-1.4,21.39-.46,42.86-.55,64.25-.29,12.27.09,24.57.47,36.82,1.13,13.8.7,27.58,2.2,41.2,4.49,9.2,1.6,18.39,3.47,27.48,5.58,15.63,3.68,31.23,7.65,46.71,11.9,15.9,4.24,31.78,8.78,47.53,13.56,9.16,2.81,18.27,5.88,27.27,9.19,9.71,3.61,19.29,7.68,28.62,12.17,9.02,4.37,17.96,8.98,26.74,13.81,13.78,7.6,26.32,14.75,39.8,22.73l1.29.69.73-1.14,89.79-152.32.72-1.21-1.24-.73-13.45-7.78-11.35-6.29-11.74-6.21-12.33-6.23c-19.27-9.43-38.9-18.29-58.72-26.51l-16-6.53-15.31-5.99-14.52-5.41-13.83-4.89c-23.21-8.03-46.9-14.84-70.84-20.34-19.14-4.36-38.5-8.07-57.9-11.09-11.43-1.81-22.92-3.44-34.4-4.91l-19.63-2.35c-18.16-2.05-36.45-3.52-54.71-4.39-9.72-.44-19.47-.67-29.2-.68h-3.78s-3.78,0-3.78,0l-6.4.04-12.28.25-10.51.39-15.42.86c-13.11.89-26.23,2.07-39.29,3.53l-19.63,2.35c-24.07,3.03-48.1,6.91-71.9,11.61-30.91,6.14-61.46,14.42-91.24,24.74l-13.82,4.89-14.52,5.41-15.31,5.99-16,6.53c-19.82,8.21-39.45,17.07-58.72,26.51l-12.33,6.22-11.74,6.21-11.35,6.29-13.43,7.79-1.22.71.71,1.24,89.83,152.25.7,1.19,1.24-.69Z",
          topPath:
            "M1.22,123.55l13.43-7.79l11.35-6.29l11.74-6.21l12.33-6.22c19.27-9.44,38.9-18.3,58.72-26.51l16-6.53l15.31-5.99l14.52-5.41l13.82-4.89c30.78-10.32,60.33-18.6,91.24-24.74c24.07-4.7,47.83-8.58,71.9-11.61l19.63-2.35c13.06-1.46,26.18-2.64,39.29-3.53l15.42-.86l10.51-.39l12.28-.25l6.4-.04h3.78s3.78,0,3.78,0c9.73.01,19.48.24,29.2.68c18.26.87,36.55,2.34,54.71,4.39l19.63,2.35c11.48,1.47,22.97,3.1,34.4,4.91c19.4,3.02,38.76,6.73,57.9,11.09c23.94,5.5,47.63,12.31,70.84,20.34l13.83,4.89l14.52,5.41l15.31,5.99l16,6.53c19.82,8.22,39.45,17.08,58.72,26.51l12.33,6.23l11.74,6.21l11.35,6.29l13.45,7.78",
          bottomPath:
            "M93.16,274.8l9.48-5.52c16.09-9.47,32.49-18.51,49.08-27.07l8.02-3.94c9.34-4.49,18.91-8.56,28.62-12.17,8.99-3.3,18.11-6.37,27.27-9.18,15.76-4.79,31.65-9.33,47.56-13.57,18.8-5.19,37.79-9.92,56.83-14.14l9.07-1.84,8.27-1.5c10.82-1.83,21.76-3.15,32.71-3.94,9.81-.7,19.67-1.17,29.5-1.4,21.39-.46,42.86-.55,64.25-.29,12.27.09,24.57.47,36.82,1.13,13.8.7,27.58,2.2,41.2,4.49,9.2,1.6,18.39,3.47,27.48,5.58,15.63,3.68,31.23,7.65,46.71,11.9,15.9,4.24,31.78,8.78,47.53,13.56,9.16,2.81,18.27,5.88,27.27,9.19,9.71,3.61,19.29,7.68,28.62,12.17,9.02,4.37,17.96,8.98,26.74,13.81,13.78,7.6,26.32,14.75,39.8,22.73",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/500gms&450ml container_t.glb",
          targetMaterials: [" Texture"],
        },
        "500ml_round_square": {
          type: "round_square",
          view: "bottom",
          name: "500ml Round Square",
          width: 888.9,
          height: 297.78,
          uploadDimensions: { width: 2770, height: 886 },
          path: "M100.22,295.91c7.22-3.68,14.49-7.33,21.74-10.94,12.31-6.17,24.8-12.07,37.38-17.66l8.32-3.56c6.19-2.59,12.48-5.01,18.81-7.25,6.79-2.39,13.66-4.62,20.55-6.67,11.2-3.29,22.5-6.38,33.82-9.23,17.32-4.36,34.73-8.55,52.14-12.54,13.13-3.03,26.38-5.76,39.64-8.17,10.65-1.91,21.41-3.37,32.18-4.37,11.78-1.02,23.62-1.67,35.44-1.95,14.74-.34,29.53-.51,44.27-.49,14.74-.01,29.53.15,44.27.49,9.56.23,19.14.7,28.68,1.39,8.72.64,17.44,1.59,26.09,2.85,7.55,1.11,15.1,2.41,22.59,3.88,14.87,2.96,29.72,6.21,44.47,9.74,16.79,3.93,33.58,8.09,50.26,12.45l11.22,3.06,9.92,2.87,8.8,2.71c10.34,3.28,20.56,7.03,30.56,11.21,9.38,3.95,18.7,8.14,27.88,12.53,13.21,6.34,26.37,12.87,39.42,19.55l2.4,1.28,1.41-2.51,94.51-184.07,1.26-2.46-2.5-1.36-12.45-6.29-12.14-5.86-12.54-5.77-13.15-5.78-14.04-5.89-15.25-6.12-16.64-6.41c-16.62-6.28-33.41-12.25-50.26-17.87-14.15-4.7-28.45-9.06-42.81-13.06-17.59-4.88-35.41-9.14-53.32-12.73-26.55-5.22-53.37-9.42-80.24-12.58-18.01-2.19-36.11-4-54.19-5.45l-17.34-1.16-14.62-.7c-10.74-.42-21.52-.6-32.26-.54-10.72-.06-21.47.13-32.18.54l-14.58.7-17.36,1.16-4.33.34-14.71,1.29-18.35,1.87c-25.34,2.71-50.66,6.23-75.78,10.52-29.81,5.17-59.39,12.09-88.41,20.67l-14.1,4.3c-10.3,3.24-20.58,6.65-30.78,10.2l-16.94,6.02c-16.55,5.99-33.03,12.33-49.33,18.98l-14.02,5.88-13.15,5.78-12.54,5.77-12.14,5.86-12.59,6.36-2.54,1.32,1.3,2.52c31.81,61.1,63.35,122.59,94.42,184.07l1.32,2.45,2.5-1.2Z",
          topPath:
            "M 881.89,111.84 l-12.45-6.29 -12.14-5.86 -12.54-5.77 -13.15-5.78 -14.04-5.89 -15.25-6.12 -16.64-6.41 c-16.62-6.28 -33.41-12.25 -50.26-17.87 -14.15-4.7 -28.45-9.06 -42.81-13.06 -17.59-4.88 -35.41-9.14 -53.32-12.73 -26.55-5.22 -53.37-9.42 -80.24-12.58 -18.01-2.19 -36.11-4 -54.19-5.45 l-17.34-1.16 -14.62-0.7 c-10.74-.42 -21.52-.6 -32.26-.54 -10.72-.06 -21.47.13 -32.18.54 l-14.58.7 -17.36,1.16 -4.33.34 -14.71,1.29 -18.35,1.87 c-25.34,2.71 -50.66,6.23 -75.78,10.52 -29.81,5.17 -59.39,12.09 -88.41,20.67 l-14.1,4.3 c-10.3,3.24 -20.58,6.65 -30.78,10.2 l-16.94,6.02 c-16.55,5.99 -33.03,12.33 -49.33,18.98 l-14.02,5.88 -13.15,5.78 -12.54,5.77 -12.14,5.86 -12.59,6.36",
          bottomPath:
            "M100.22,295.91c7.22-3.68,14.49-7.33,21.74-10.94,12.31-6.17,24.8-12.07,37.38-17.66l8.32-3.56c6.19-2.59,12.48-5.01,18.81-7.25,6.79-2.39,13.66-4.62,20.55-6.67,11.2-3.29,22.5-6.38,33.82-9.23,17.32-4.36,34.73-8.55,52.14-12.54,13.13-3.03,26.38-5.76,39.64-8.17,10.65-1.91,21.41-3.37,32.18-4.37,11.78-1.02,23.62-1.67,35.44-1.95,14.74-.34,29.53-.51,44.27-.49,14.74-.01,29.53.15,44.27.49,9.56.23,19.14.7,28.68,1.39,8.72.64,17.44,1.59,26.09,2.85,7.55,1.11,15.1,2.41,22.59,3.88,14.87,2.96,29.72,6.21,44.47,9.74,16.79,3.93,33.58,8.09,50.26,12.45l11.22,3.06,9.92,2.87,8.8,2.71c10.34,3.28,20.56,7.03,30.56,11.21,9.38,3.95,18.7,8.14,27.88,12.53,13.21,6.34,26.37,12.87,39.42,19.55",
          topIsReversed: true,
          bottomIsReversed: false,
          modelPath: "./assets/models/500ml_container_t.glb",
          targetMaterials: [" Texture"],
        },
        "750ml_rectangle": {
          type: "rectangle",
          view: "bottom",
          name: "500ml / 750ml Rectangle",
          width: 462.62,
          height: 309.76,
          uploadDimensions: { width: 1926, height: 1289 },
          path: "M.99,47.31 C.99,21.73 21.73,.99 47.31,.99 H 415.31 C 440.89,.99 461.63,21.73 461.63,47.31 V 262.45 C 461.63,288.03 440.89,308.77 415.31,308.77 H 47.31 C 21.73,308.77 .99,288.03 .99,262.45 Z",
          topPath:
            "M.99,47.31 C.99,21.73 21.73,.99 47.31,.99 H 415.31 C 440.89,.99 461.63,21.73 461.63,47.31",
          bottomPath:
            "M.99,262.45 C.99,288.03 21.73,308.77 47.31,308.77 H 415.31 C 440.89,308.77 461.63,288.03 461.63,262.45",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/750ml rectangular_t.glb",
          targetMaterials: [" Texture"],
        },
        "1kg_sweet_box_top": {
          type: "sweet_box",
          view: "top",
          name: "1kg Sweet Box",
          width: 636.39,
          height: 455.59,
          uploadDimensions: { width: 1926, height: 1289 },
          path: "M.5.5 h635.39 v454.59 h-635.39 Z",
          topPath: "M0,0 H636.39",
          bottomPath: "M0,455.59 H636.39",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/1000gms_sweet_t.glb",
          targetMaterials: [" Texture"],
        },
        "250ml_sweet_box_top": {
          type: "sweet_box",
          view: "top",
          name: "250g Sweet Box",
          width: 361,
          height: 273.49,
          uploadDimensions: { width: 1461, height: 1100 },
          path: "M9.29.5h342.4c4.85,0,8.82,3.94,8.82,8.79v254.92c0,4.82-3.97,8.79-8.82,8.79H9.29c-4.85,0-8.79-3.97-8.79-8.79V9.29C.5,4.44,4.44.5,9.29.5Z",
          topPath: "M0,0 H361",
          bottomPath: "M0,273.49 H361",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/250gms_sweet_t.glb",
          targetMaterials: ["TopTexture"],
        },
        "500ml_sweet_box_top": {
          type: "sweet_box",
          view: "top",
          name: "500g Sweet Box",
          width: 495.82,
          height: 351.4,
          uploadDimensions: { width: 2064, height: 1463 },
          path: "M489.44,351.01H6.42c-3.32,0-6.04-2.72-6.04-6.04V6.38C.38,3.1,3.09.38,6.42.38h483.02c3.29,0,6.01,2.72,6.01,6.01v338.6c0,3.32-2.72,6.04-6.01,6.04h0Z",
          topPath: "M0,0 H495.82",
          bottomPath: "M0,351.4 H495.82",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/500gms_sweet_t.glb",
          targetMaterials: ["TopTexture"],
        },
        "250ml_sweet_box_bottom": {
          type: "sweet_box",
          view: "bottom",
          name: "250g Sweet Box",
          width: 1342.58,
          height: 189.54,
          uploadDimensions: { width: 5533, height: 404 },
          path: "M662.63.55l-278.9,13.66c-.26,0-.48.03-.74.09L8.88,81.16l-8.31,1.59,1.42,8.27,15.85,89.69,1.64,8.25,8.26-1.36,367.77-65.74c1.19-.23,2.41-.37,3.6-.43l259.43-12.7c1.3-.06,2.64-.03,3.94.09h.11l365.58,24.6c1.84.14,3.69.45,5.44.93.14.03.26.06.37.09l266.12,52.89,7.12,1.34,2.57-6.92,29.28-86.34,2.87-8.88-9.25-2.2-289.39-57.68c-2.38-.62-4.82-1.02-7.28-1.19L668.08.66c-1.16-.11-2.33-.16-3.49-.16-.65,0-1.3.02-1.95.05",
          topPath:
            "M8.88,81.16 L382.99,14.3 c.26-.06 .48-.09 .74-.09 L662.63,0.55 c.65-.03 1.3-.05 1.95-.05 c1.16,0 2.33.05 3.49.16 L1042.28,24.34 c2.46.17 4.9.57 7.28,1.19 l289.39,57.68",
          bottomPath:
            "M27.74, 187.6 l367.77-65.74 c1.19-.23,2.41-.37,3.6-.43 l259.43-12.7 c1.3-.06,2.64-.03,3.94.09 h.11 l365.58,24.6 c1.84.14,3.69.45,5.44.93 .14.03 .26.06 .37.09 l266.12,52.89",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/250gms_sweet_t.glb",
          targetMaterials: ["Bottom1"],
        },
        "500ml_sweet_box_bottom": {
          type: "sweet_box",
          view: "bottom",
          name: "500g Sweet Box",
          width: 1798.7,
          height: 215.31,
          uploadDimensions: { width: 7446, height: 403 },
          path: "M1758.59,213.74l-356.09-70.07c-3.32-.65-6.69-1.11-10.09-1.33l-505.42-33.33c-2.98-.2-5.98-.23-8.96-.09l-341.4,15.99c-3.4.14-6.8.54-10.15,1.13L31.24,213.68l-4.25.74c-3.77.65-7.4-1.84-8.14-5.64L.63,115.74c-.37-1.87.06-3.83,1.13-5.41,1.1-1.59,2.78-2.64,4.68-2.92l4.14-.68L503.67,19.45c3.83-.68,7.68-1.1,11.57-1.3L890,.6c3.4-.17,6.83-.11,10.23.11l495.47,32.68c3.85.25,7.71.76,11.54,1.5l381.26,75.03,4.05.85c1.96.4,3.63,1.59,4.65,3.29,1.02,1.73,1.28,3.77.71,5.67l-26.79,90c-1.05,3.54-4.68,5.7-8.28,4.9l-4.25-.91Z",
          topPath:
            "M.63,115.74c-.37-1.87.06-3.83,1.13-5.41,1.1-1.59,2.78-2.64,4.68-2.92l4.14-.68L503.67,19.45c3.83-.68,7.68-1.1,11.57-1.3L890,.6c3.4-.17,6.83-.11,10.23.11l495.47,32.68c3.85.25,7.71.76,11.54,1.5l381.26,75.03,4.05.85c1.96.4,3.63,1.59,4.65,3.29,1.02,1.73,1.28,3.77.71,5.67",
          bottomPath:
            "M1758.59,213.74l-356.09-70.07c-3.32-.65-6.69-1.11-10.09-1.33l-505.42-33.33c-2.98-.2-5.98-.23-8.96-.09l-341.4,15.99c-3.4.14-6.8.54-10.15,1.13L31.24,213.68",
          topIsReversed: false,
          bottomIsReversed: true,
          modelPath: "./assets/models/500gms_sweet_t.glb",
          targetMaterials: ["Bottom1"],
        },
        "250ml_sweet_box_te_top": {
          type: "sweet_box_te",
          view: "top",
          name: "250g Sweet Box TE",
          width: 378.23,
          height: 296.16,
          uploadDimensions: { width: 503, height: 394 },
          path: "M 344.73 .5 346.35 .54 347.96 .65 349.57 .85 351.17 1.12 354.31 1.92 357.36 3.01 360.29 4.39 363.07 6.05 365.67 7.98 368.07 10.17 370.24 12.57 372.18 15.16 373.84 17.94 375.23 20.88 376.32 23.93 377.11 27.07 377.38 28.66 377.58 30.27 377.7 31.89 377.73 33.51 377.73 262.66 377.7 264.28 377.58 265.89 377.38 267.5 377.11 269.1 376.32 272.24 375.23 275.29 373.84 278.22 372.18 281 370.24 283.6 368.07 286 365.67 288.17 363.07 290.11 360.29 291.77 357.36 293.15 354.31 294.24 351.17 295.03 349.57 295.31 347.96 295.51 346.35 295.62 344.73 295.66 33.51 295.66 31.89 295.62 30.27 295.51 28.66 295.31 27.07 295.03 23.92 294.24 20.88 293.15 17.94 291.77 15.16 290.11 12.56 288.17 10.17 286 7.99 283.6 6.06 281 4.39 278.22 3.01 275.29 1.92 272.24 1.13 269.1 .85 267.5 .66 265.89 .54 264.28 .5 262.66 .5 33.51 .54 31.89 .66 30.27 .85 28.66 1.13 27.07 1.92 23.93 3.01 20.88 4.39 17.94 6.06 15.16 7.99 12.57 10.17 10.17 12.56 7.98 15.16 6.05 17.94 4.39 20.88 3.01 23.92 1.92 27.07 1.12 28.66 .85 30.27 .65 31.89 .54 33.51 .5 344.73 .5 Z",
          topPath: "M0,0 H378.23",
          bottomPath: "M0,296.16 H378.23",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/texture_250_gms_te_sb.glb",
          targetMaterials: ["TopTexture"],
        },
        "250ml_sweet_box_te_bottom": {
          type: "sweet_box_te",
          view: "bottom",
          name: "250g Sweet Box TE",
          width: 557.78,
          height: 475.73,
          uploadDimensions: { width: 742, height: 633 },
          path: "M437.53,98.37c12.09,0,21.88,9.8,21.88,21.88h97.87v235.23h-97.87c0,12.08-9.79,21.88-21.88,21.88h0v97.87H120.25v-97.86h0c-12.09-.01-21.88-9.81-21.88-21.89H.5V120.25h97.87c0-12.08,9.79-21.88,21.88-21.88h0V.5h317.28v97.86h0Z",
          topPath: "M0,0 H557.78",
          bottomPath: "M0,475.73 H557.78",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/texture_250_gms_te_sb.glb",
          targetMaterials: ["Bottom1"],
        },
        "500ml_sweet_box_te_bottom": {
          type: "sweet_box_te",
          view: "bottom",
          name: "500g Sweet Box TE",
          width: 695.7,
          height: 560.63,
          uploadDimensions: { width: 7446, height: 403 },
          path: "M 122.64 3.76 122.39 .92 572.87 .5 572.62 3.34 563.84 104.14 564.26 104.14 566.94 104.29 569.58 104.7 572.17 105.36 574.68 106.27 577.09 107.42 579.38 108.8 581.52 110.39 583.5 112.18 585.29 114.16 586.88 116.3 588.26 118.59 589.41 121 590.32 123.51 590.98 126.1 591.39 128.74 591.54 131.41 591.54 131.84 692.37 123.05 695.2 122.78 695.2 437.82 692.37 437.58 591.54 428.8 591.54 429.22 591.28 432.82 590.5 436.5 589.18 440.16 587.3 443.69 584.89 446.96 582 449.84 578.74 452.26 575.21 454.14 571.54 455.46 567.86 456.23 564.26 456.5 563.84 456.5 572.62 557.3 572.88 560.13 122.39 559.7 122.64 556.87 131.39 456.5 130.96 456.5 127.37 456.23 123.69 455.46 120.02 454.14 116.49 452.26 113.23 449.84 110.34 446.96 107.93 443.69 106.05 440.16 104.72 436.5 103.95 432.82 103.69 429.22 103.69 428.99 103.69 428.8 3.34 437.54 .5 437.78 .5 122.84 3.34 123.09 103.69 131.84 103.69 131.64 103.69 131.41 103.95 127.82 104.72 124.14 106.05 120.47 107.93 116.94 110.34 113.68 113.23 110.79 116.49 108.38 120.02 106.5 123.69 105.17 127.37 104.4 130.96 104.14 131.39 104.14 122.64 3.76 Z",
          topPath: "M 131.39 104.14 H 563.84",
          bottomPath: "M 131.39 456.5 H 563.84",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/texture_500_gms_te_sb.glb",
          targetMaterials: ["Bottom1"],
        },
        "500ml_sweet_box_te_top": {
          type: "sweet_box_te",
          view: "top",
          name: "500g Sweet Box TE",
          width: 509.61,
          height: 374.16,
          uploadDimensions: { width: 2064, height: 1436 },
          path: "M3.86,28.85C4.36,15.15,15.42,4.2,29.12,3.86,179.56.04,330.06.04,480.5,3.86c13.7.34,24.76,11.29,25.26,24.99,3.82,105.45,3.82,211.01,0,316.46-.5,13.7-11.56,24.65-25.26,25-150.44,3.81-300.94,3.81-451.38,0-13.7-.35-24.76-11.3-25.26-25C.04,239.86.04,134.3,3.86,28.85Z",
          topPath: "M0,0 H509.61",
          bottomPath: "M0,374.16 H509.61",
          topIsReversed: false,
          bottomIsReversed: false,
          modelPath: "./assets/models/texture_500_gms_te_sb.glb",
          targetMaterials: ["TopTexture"],
        },
      };

      const shapeGroups = {};
      const keyToGroupName = {};

      // ========== 3D VIEWER FUNCTIONS ==========

      function showStatus(message) {
        viewer3DStatus.textContent = message;
        viewer3DStatus.classList.remove("hidden");
      }

      function hideStatus() {
        viewer3DStatus.classList.add("hidden");
      }

      function show3DLoading() {
        viewer3DLoading.classList.remove("hidden");
        hideStatus();
      }

      function hide3DLoading() {
        viewer3DLoading.classList.add("hidden");
      }

      function findBestMaterial(viewer, preferredNames) {
        if (!viewer.model || !viewer.model.materials) return null;
        const materials = viewer.model.materials;

        for (const name of preferredNames) {
          const mat = materials.find(m => m.name === name);
          if (mat) return mat;
        }

        for (const name of preferredNames) {
          const mat = materials.find(m => m.name.toLowerCase() === name.toLowerCase());
          if (mat) return mat;
        }

        for (const name of preferredNames) {
          const mat = materials.find(m => 
            m.name.toLowerCase().includes(name.toLowerCase()) ||
            name.toLowerCase().includes(m.name.toLowerCase())
          );
          if (mat) return mat;
        }

        for (const name of COMMON_LABEL_MATERIALS) {
          const mat = materials.find(m => m.name === name);
          if (mat) return mat;
        }

        return materials.length > 0 ? materials[0] : null;
      }

      async function applyTextureToMaterial(viewer, material, textureUrl) {
        if (!viewer || !material || !textureUrl) return false;

        try {
          const texture = await viewer.createTexture(textureUrl);
          if (!texture) return false;

          const pbr = material.pbrMetallicRoughness;

          if (typeof pbr.setBaseColorFactor === 'function') {
            pbr.setBaseColorFactor([1.0, 1.0, 1.0, 1.0]);
          }

          if (pbr.baseColorTexture) {
            pbr.baseColorTexture.setTexture(texture);
          }

          try {
            const texInfo = pbr.baseColorTexture;
            if (texInfo && texInfo.texture && texInfo.texture.sampler) {
              const sampler = texInfo.texture.sampler;
              const GL_CLAMP_TO_EDGE = 33071;
              const GL_LINEAR = 9729;
              const GL_LINEAR_MIPMAP_LINEAR = 9987;

              if (typeof sampler.setWrapS === 'function') {
                sampler.setWrapS(GL_CLAMP_TO_EDGE);
                sampler.setWrapT(GL_CLAMP_TO_EDGE);
              }
              if (typeof sampler.setMinFilter === 'function') {
                sampler.setMinFilter(GL_LINEAR_MIPMAP_LINEAR);
              }
              if (typeof sampler.setMagFilter === 'function') {
                sampler.setMagFilter(GL_LINEAR);
              }
            }
          } catch (e) {
            console.warn("Could not set sampler settings:", e);
          }

          if (typeof pbr.setMetallicFactor === 'function') {
            pbr.setMetallicFactor(0.0);
          }
          if (typeof pbr.setRoughnessFactor === 'function') {
            pbr.setRoughnessFactor(0.5);
          }

          return true;
        } catch (error) {
          console.error("Error applying texture:", error);
          return false;
        }
      }

      async function applyTextureToModel() {
        if (!modelViewer.model || !textureImageDataUrl) return;

        const shape = getCurrentShape();
        if (!shape) return;

        const materialNames = shape.targetMaterials || COMMON_LABEL_MATERIALS;
        const material = findBestMaterial(modelViewer, materialNames);

        if (!material) return;

        await applyTextureToMaterial(modelViewer, material, textureImageDataUrl);
      }

      async function load3DModel(shape) {
        isModelLoaded = false;

        if (!shape || !shape.modelPath) {
          showStatus("No 3D model");
          modelViewer.src = "";
          return;
        }

        show3DLoading();
        modelViewer.src = shape.modelPath + "?t=" + Date.now();
      }

      modelViewer.addEventListener("load", async () => {
        isModelLoaded = true;
        hide3DLoading();
        hideStatus();

        let attempts = 0;
        while (!modelViewer.model && attempts < 100) {
          await new Promise(r => setTimeout(r, 50));
          attempts++;
        }

        if (textureImageDataUrl && modelViewer.model) {
          await applyTextureToModel();
        }
      });

      modelViewer.addEventListener("error", () => {
        hide3DLoading();
        showStatus("Load failed");
        isModelLoaded = false;
      });

      modelViewer.addEventListener("progress", (event) => {
        const progress = event.detail.totalProgress;
        if (progress < 1) {
          const percent = Math.round(progress * 100);
          viewer3DLoading.querySelector("span").textContent = `${percent}%`;
        }
      });

      function toggleViewer3D() {
        isViewer3DMinimized = !isViewer3DMinimized;
        viewer3DContainer.classList.toggle("minimized", isViewer3DMinimized);
        
        if (isViewer3DMinimized) {
          isViewer3DExpanded = false;
          viewer3DContainer.classList.remove("expanded");
        }
      }

      function toggleViewer3DExpand() {
        if (isViewer3DMinimized) return;
        isViewer3DExpanded = !isViewer3DExpanded;
        viewer3DContainer.classList.toggle("expanded", isViewer3DExpanded);
      }

      viewer3DToggle.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleViewer3D();
      });

      viewer3DExpand.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleViewer3DExpand();
      });

      viewer3DContainer.addEventListener("click", (e) => {
        if (isViewer3DMinimized && !e.target.closest('.viewer3D-btn')) {
          toggleViewer3D();
        }
      });

      // ========== SHAPE FUNCTIONS ==========

      function preProcessShapes() {
        for (const [key, shape] of Object.entries(allBottleShapes)) {
          shape.topSampler = new PathSampler(shape.topPath);
          shape.bottomSampler = new PathSampler(shape.bottomPath);

          if (!shapeGroups[shape.name]) {
            shapeGroups[shape.name] = {};
          }
          shapeGroups[shape.name][shape.view] = key;
          keyToGroupName[key] = shape.name;
        }
      }

      function getCurrentShape() {
        return currentShape ? allBottleShapes[currentShape] : null;
      }

      function updateUploadPlaceholder() {
        const shape = getCurrentShape();
        if (shape && shape.uploadDimensions) {
          const { width, height } = shape.uploadDimensions;
          uploadText.innerHTML = `<span class="text-xs text-slate-500 block text-center">${width}  ${height}px</span>Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>`;
        } else {
          uploadText.innerHTML = 'Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>';
        }
      }

      function toggleViewSelector() {
        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          viewSelector.classList.remove("hidden");
        } else {
          viewSelector.classList.add("hidden");
        }
      }

      function syncSweetBoxViewControls() {
        const topRadioDiv = document.getElementById("viewTopRadio").parentElement;
        const bottomRadioDiv = document.getElementById("viewBottomRadio").parentElement;

        if ((currentShapeType !== "sweet_box" && currentShapeType !== "sweet_box_te") || !currentShape) {
          topRadioDiv.classList.add("hidden");
          bottomRadioDiv.classList.add("hidden");
          return;
        }

        const groupName = keyToGroupName[currentShape];
        const group = shapeGroups[groupName];

        topRadioDiv.classList.toggle("hidden", !group.top);
        bottomRadioDiv.classList.toggle("hidden", !group.bottom);

        if (currentShape.endsWith("_top")) {
          currentView = "top";
          document.getElementById("viewTopRadio").checked = true;
        } else if (currentShape.endsWith("_bottom")) {
          currentView = "bottom";
          document.getElementById("viewBottomRadio").checked = true;
        }
      }

      function updateSpecificShapeSelector() {
        shapeSelect.innerHTML = "";
        let firstShapeKey = null;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const uniqueNames = new Set();
          for (const key in allBottleShapes) {
            const shape = allBottleShapes[key];
            if (shape.type === currentShapeType && !uniqueNames.has(shape.name)) {
              uniqueNames.add(shape.name);
              const option = document.createElement("option");
              option.value = shape.name;
              option.textContent = shape.name;
              shapeSelect.appendChild(option);
            }
          }
          if (shapeSelect.options.length > 0) {
            const selectedName = shapeSelect.options[0].value;
            shapeSelect.value = selectedName;
            const group = shapeGroups[selectedName];
            firstShapeKey = group.top || group.bottom;
          }
        } else {
          for (const [key, shape] of Object.entries(allBottleShapes)) {
            if (shape.type === currentShapeType) {
              const option = document.createElement("option");
              option.value = key;
              option.textContent = shape.name;
              shapeSelect.appendChild(option);
              if (!firstShapeKey) firstShapeKey = key;
            }
          }
          if (firstShapeKey) shapeSelect.value = firstShapeKey;
        }

        currentShape = firstShapeKey;
        syncSweetBoxViewControls();

        const shape = getCurrentShape();
        load3DModel(shape);
      }

      function populateShapeTypes() {
        shapeTypeSelect.innerHTML = "";
        for (const [key, name] of Object.entries(shapeTypes)) {
          const option = document.createElement("option");
          option.value = key;
          option.textContent = name;
          shapeTypeSelect.appendChild(option);
        }
        shapeTypeSelect.value = currentShapeType;
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
      }

      function drawWarp(localCtx, img, shape, offsetX, offsetY, finalScale, isExport, heightAdjust = 1.0) {
        const sliceCountBase = isExport ? 4000 : 2000;
        const imgWidth = img.width;
        const imgHeight = img.height;
        const sliceCount = Math.min(sliceCountBase, Math.max(1, Math.floor(imgWidth)));
        const sourceSliceWidth = imgWidth / sliceCount;

        const isWideShape = shape.type === "round_square" || shape.type === "sweet_box" || shape.type === "sweet_box_te";
        const isSweetBox = shape.type === "sweet_box" || shape.type === "sweet_box_te";
        const isLargeRound = ["300ml_round", "500ml_round", "750ml_round", "1000ml_round"].includes(currentShape);

        let baseOverlap;
        if (isSweetBox) baseOverlap = isExport ? 40 : 20;
        else if (isLargeRound) baseOverlap = isExport ? 30 : 15;
        else if (isWideShape) baseOverlap = isExport ? 20 : 10;
        else baseOverlap = isExport ? 8 : 4;

        for (let i = 0; i < sliceCount; i++) {
          const t0 = i / sliceCount;
          const t1 = (i + 1) / sliceCount;
          const edgeExtension = isSweetBox ? 0.03 : 0.01;
          const tTop0 = shape.topIsReversed ? 1 - t0 : t0;
          const tTop1 = shape.topIsReversed ? 1 - t1 : t1;
          const tBot0 = shape.bottomIsReversed ? 1 - t0 : t0;
          const tBot1 = shape.bottomIsReversed ? 1 - t1 : t1;

          const clampedTTop0 = Math.min(Math.max(tTop0, -edgeExtension), 1 + edgeExtension);
          const clampedTTop1 = Math.min(Math.max(tTop1, -edgeExtension), 1 + edgeExtension);
          const clampedTBot0 = Math.min(Math.max(tBot0, -edgeExtension), 1 + edgeExtension);
          const clampedTBot1 = Math.min(Math.max(tBot1, -edgeExtension), 1 + edgeExtension);

          if ((clampedTTop0 < -0.05 && clampedTTop1 < -0.05) || (clampedTTop0 > 1.05 && clampedTTop1 > 1.05)) continue;

          const pTop1 = shape.topSampler.getPointAt(Math.min(Math.max(clampedTTop0, 0), 1));
          const pBot1 = shape.bottomSampler.getPointAt(Math.min(Math.max(clampedTBot0, 0), 1));
          const pTop2 = shape.topSampler.getPointAt(Math.min(Math.max(clampedTTop1, 0), 1));
          const pBot2 = shape.bottomSampler.getPointAt(Math.min(Math.max(clampedTBot1, 0), 1));

          const top1X = pTop1.x * finalScale + offsetX;
          const top1Y = pTop1.y * finalScale + offsetY;
          const bot1X = pBot1.x * finalScale + offsetX;
          const bot1Y = pBot1.y * finalScale + offsetY;
          const top2X = pTop2.x * finalScale + offsetX;
          const top2Y = pTop2.y * finalScale + offsetY;
          const bot2X = pBot2.x * finalScale + offsetX;
          const bot2Y = pBot2.y * finalScale + offsetY;

          const midTopX = (top1X + top2X) / 2;
          const midTopY = (top1Y + top2Y) / 2;
          const midBotX = (bot1X + bot2X) / 2;
          const midBotY = (bot1Y + bot2Y) / 2;

          const sliceHeight = Math.hypot(midBotX - midTopX, midBotY - midTopY) * heightAdjust;
          const sliceAngle = Math.atan2(midBotY - midTopY, midBotX - midTopX) - Math.PI / 2;

          const topWidth = Math.hypot(top2X - top1X, top2Y - top1Y);
          const botWidth = Math.hypot(bot2X - bot1X, bot2Y - bot1Y);
          const sliceWidth = Math.max(topWidth, botWidth);

          let overlap = baseOverlap;
          const normalizedT = Math.min(Math.max(t0, 0), 1);

          if (isSweetBox) {
            if (isExport) {
              if (normalizedT < 0.02 || normalizedT > 0.98) overlap = 80;
              else if (normalizedT < 0.05 || normalizedT > 0.95) overlap = 60;
              else if (normalizedT < 0.1 || normalizedT > 0.9) overlap = 40;
              else {
                const edgeFactor = Math.min(normalizedT * 3, (1 - normalizedT) * 3, 1);
                overlap = baseOverlap + (20 - baseOverlap) * (1 - edgeFactor);
              }
            } else {
              if (normalizedT < 0.05 || normalizedT > 0.95) overlap = 40;
              else if (normalizedT < 0.1 || normalizedT > 0.9) overlap = 30;
              else overlap = 20;
            }
          } else if (isWideShape) {
            const edgeFactor = Math.min(normalizedT * 5, (1 - normalizedT) * 5, 1);
            overlap = baseOverlap + (15 - baseOverlap) * (1 - edgeFactor);
            if (isExport) {
              if (normalizedT < 0.05 || normalizedT > 0.95) overlap += 25;
              else if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 15;
            } else {
              if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 10;
            }
          } else if (isLargeRound) {
            if (isExport) {
              if (normalizedT < 0.05 || normalizedT > 0.95) overlap += 25;
              else if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 15;
            } else {
              if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 10;
            }
          }

          if (sliceWidth < 0.1) continue;

          localCtx.save();
          localCtx.translate(midTopX, midTopY);
          localCtx.rotate(sliceAngle);

          let verticalExtension = 0;
          if (shape.type !== "rectangle") {
            if (isSweetBox) verticalExtension = isExport ? 40 : 20;
            else if (isWideShape) verticalExtension = isExport ? 22 : 10;
            else if (shape.type === "round") {
              if (shape.name === "250ml Round") verticalExtension = 0;
              else verticalExtension = isExport ? 10 : 0;
            }
          }

          const sourceLeft = Math.max(0, Math.floor(i * sourceSliceWidth));
          const sourceRight = Math.min(imgWidth, Math.ceil((i + 1) * sourceSliceWidth));
          const sourceW = Math.max(1, sourceRight - sourceLeft);

          localCtx.drawImage(img, sourceLeft, 0, sourceW, imgHeight, -(sliceWidth + overlap) / 2, -verticalExtension, sliceWidth + overlap, sliceHeight + verticalExtension * 2);
          localCtx.restore();
        }
      }

      function renderImageContent(localCtx, targetW, targetH, isExport, exportScale, clearBackground, applyPan = false) {
        if (clearBackground) localCtx.clearRect(0, 0, targetW, targetH);

        const shape = getCurrentShape();
        if (!shape) return;

        const margin = isExport ? 0 : 20;
        const scaleXFit = (targetW - 2 * margin) / shape.width;
        const scaleYFit = (targetH - 2 * margin) / shape.height;
        let finalScale = isExport ? exportScale : Math.min(scaleXFit, scaleYFit);
        
        // Apply zoom level for preview (not for export)
        if (!isExport) {
          finalScale *= zoomLevel;
        }

        const scaledW = shape.width * finalScale;
        const scaledH = shape.height * finalScale;
        let offsetX = (targetW - scaledW) / 2;
        let offsetY = (targetH - scaledH) / 2;
        
        // Apply pan offset for preview
        if (applyPan && !isExport) {
          offsetX += panX;
          offsetY += panY;
        }

        const path = new Path2D(shape.path);
        const transformMatrix = new DOMMatrix();
        transformMatrix.translateSelf(offsetX, offsetY);
        transformMatrix.scaleSelf(finalScale, finalScale);

        if (currentImage) {
          localCtx.save();
          localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
          localCtx.clip(path);
          localCtx.setTransform(1, 0, 0, 1, 0, 0);

          if (!isExport && window.devicePixelRatio && localCtx === ctx) {
            localCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
          }

          let imageOffsetX = 0;
          const needsHorizontalShift = ["500ml_round", "750ml_round", "1000ml_round", "450ml_round_square", "500ml_round_square"].includes(currentShape);
          if (needsHorizontalShift) imageOffsetX = isExport ? 22 : 5;

          if (shape.type === "rectangle" || shape.view === "top" || shape.type === "sweet_box_te") {
            let drawOffsetX = offsetX + imageOffsetX;
            let drawOffsetY = offsetY;
            let drawScaledW = scaledW;
            let drawScaledH = scaledH;

            if (currentShape === "250ml_sweet_box_te_bottom") {
              const scaleFactor = 1.029;
              drawScaledW = scaledW * scaleFactor;
              drawScaledH = scaledH * scaleFactor;
              drawOffsetX = offsetX - (drawScaledW - scaledW) / 2 + imageOffsetX;
              drawOffsetY = offsetY - (drawScaledH - scaledH) / 2;
            }

            localCtx.drawImage(currentImage, drawOffsetX, drawOffsetY, drawScaledW, drawScaledH);
          } else {
            drawWarp(localCtx, currentImage, shape, offsetX + imageOffsetX, offsetY, finalScale, isExport, 1.0);
          }

          localCtx.restore();
        } else {
          localCtx.save();
          localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
          localCtx.fillStyle = "#eee";
          localCtx.fill(path);
          localCtx.restore();
        }
      }

      function drawShape(localCtx, targetW, targetH, isExport, exportScale, clearBackground, applyPan = false) {
        localCtx.imageSmoothingEnabled = true;
        localCtx.imageSmoothingQuality = "high";

        renderImageContent(localCtx, targetW, targetH, isExport, exportScale, clearBackground, applyPan);

        const shape = getCurrentShape();
        if (!shape) {
          if (clearBackground) localCtx.clearRect(0, 0, targetW * (window.devicePixelRatio || 1), targetH * (window.devicePixelRatio || 1));
          const dpr = window.devicePixelRatio || 1;
          localCtx.font = `${16 * dpr}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
          localCtx.textAlign = "center";
          localCtx.fillStyle = "#9ca3af";
          localCtx.fillText("No shapes available for this type/view.", (targetW * dpr) / 2, (targetH * dpr) / 2);
          return;
        }

        const margin = isExport ? 0 : 20;
        const scaleXFit = (targetW - 2 * margin) / shape.width;
        const scaleYFit = (targetH - 2 * margin) / shape.height;
        let finalScale = isExport ? exportScale : Math.min(scaleXFit, scaleYFit);
        
        // Apply zoom level for preview (not for export)
        if (!isExport) {
          finalScale *= zoomLevel;
        }
        
        const scaledW = shape.width * finalScale;
        const scaledH = shape.height * finalScale;
        let offsetX = (targetW - scaledW) / 2;
        let offsetY = (targetH - scaledH) / 2;
        
        // Apply pan offset for preview
        if (applyPan && !isExport) {
          offsetX += panX;
          offsetY += panY;
        }

        const path = new Path2D(shape.path);
        const transformMatrix = new DOMMatrix();
        transformMatrix.translateSelf(offsetX, offsetY);
        transformMatrix.scaleSelf(finalScale, finalScale);

        localCtx.save();
        localCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
        if (!isExport) {
          localCtx.strokeStyle = "#ed312c";
          localCtx.lineWidth = 2 / finalScale;
          localCtx.stroke(path);
        }
        localCtx.restore();
      }

      function mainDraw() {
        resizeCanvas();
        drawShape(ctx, canvas.clientWidth, canvas.clientHeight, false, 1, true, true);
      }

      async function processUploadedImage(img, shape) {
        updateLoading("Applying to shape...", "Almost done");
        
        currentImage = img;

        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.drawImage(img, 0, 0);
        currentImageDataUrl = tempCanvas.toDataURL("image/png");
        textureImageDataUrl = currentImageDataUrl;

        await new Promise(r => setTimeout(r, 100));

        if (isModelLoaded && modelViewer.model) {
          updateLoading("Applying 3D texture...", "Finishing up");
          await applyTextureToModel();
        }

        mainDraw();
        hideLoading();
      }

      async function handleImageUpload(event) {
        const file = (event.target.files || [])[0];

        if (!file) {
          currentImage = null;
          currentImageDataUrl = null;
          textureImageDataUrl = null;
          mainDraw();
          updateUploadPlaceholder();
          const shape = getCurrentShape();
          if (shape) load3DModel(shape);
          return;
        }

        showLoading("Loading image...", "Reading file");

        const isSVG = file.type === "image/svg+xml" || file.name.toLowerCase().endsWith(".svg");
        const shape = getCurrentShape();

        if (isSVG) {
          const reader = new FileReader();
          reader.onload = async function (e) {
            updateLoading("Processing SVG...", "Parsing file");
            
            let svgText = e.target.result;
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
            const svgElement = svgDoc.querySelector("svg");

            const parserError = svgDoc.querySelector("parsererror");
            if (parserError || !svgElement) {
              hideLoading();
              showError("Invalid SVG File", "The SVG file could not be parsed. Please make sure it's a valid SVG file.");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
              return;
            }

            let width = svgElement.getAttribute("width");
            let height = svgElement.getAttribute("height");
            const viewBox = svgElement.getAttribute("viewBox");

            if (width) width = parseFloat(width);
            if (height) height = parseFloat(height);

            if ((!width || !height) && viewBox) {
              const vbParts = viewBox.split(/[\s,]+/).map(parseFloat);
              if (vbParts.length === 4) {
                if (!width) width = vbParts[2];
                if (!height) height = vbParts[3];
              }
            }

            if (!width || !height || isNaN(width) || isNaN(height)) {
              if (shape && shape.uploadDimensions) {
                width = width || shape.uploadDimensions.width;
                height = height || shape.uploadDimensions.height;
              } else {
                width = width || 1000;
                height = height || 1000;
              }
            }

            svgElement.setAttribute("width", width);
            svgElement.setAttribute("height", height);
            if (!viewBox) svgElement.setAttribute("viewBox", `0 0 ${width} ${height}`);

            svgText = new XMLSerializer().serializeToString(svgDoc);
            const blob = new Blob([svgText], { type: "image/svg+xml" });
            const url = URL.createObjectURL(blob);

            const img = new Image();
            img.onload = async () => {
              if (shape && shape.uploadDimensions) {
                const expectedWidth = shape.uploadDimensions.width;
                const expectedHeight = shape.uploadDimensions.height;

                if (width < expectedWidth || height < expectedHeight) {
                  hideLoading();
                  showError(
                    "Image Too Small",
                    `The image dimensions (${Math.round(width)}  ${Math.round(height)}px) are smaller than required.\n\nMinimum size: ${expectedWidth}  ${expectedHeight}px`
                  );
                  currentImage = null;
                  currentImageDataUrl = null;
                  textureImageDataUrl = null;
                  fileInput.value = "";
                  updateUploadPlaceholder();
                  URL.revokeObjectURL(url);
                  mainDraw();
                  return;
                }
              }

              const fullName = file.name;
              const dotIndex = fullName.lastIndexOf(".");
              let name = dotIndex !== -1 ? fullName.substring(0, dotIndex) : fullName;
              const ext = dotIndex !== -1 ? fullName.substring(dotIndex) : "";
              if (name.length > 12) name = name.substring(0, 12) + "...";
              uploadText.textContent = `${name}${ext}`;

              await processUploadedImage(img, shape);
            };

            img.onerror = () => {
              URL.revokeObjectURL(url);
              hideLoading();
              showError("Failed to Load SVG", "The SVG file could not be loaded. Please try a different file.");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
            };

            img.src = url;
          };

          reader.onerror = () => {
            hideLoading();
            showError("File Read Error", "Failed to read the SVG file. Please try again.");
            fileInput.value = "";
            updateUploadPlaceholder();
            mainDraw();
          };

          reader.readAsText(file);
        } else {
          const reader = new FileReader();
          reader.onload = async function (e) {
            updateLoading("Processing image...", "Loading pixels");
            
            const img = new Image();
            img.onload = async () => {
              if (shape && shape.uploadDimensions) {
                const expectedWidth = shape.uploadDimensions.width;
                const expectedHeight = shape.uploadDimensions.height;

                if (img.width < expectedWidth || img.height < expectedHeight) {
                  hideLoading();
                  showError(
                    "Image Too Small",
                    `The image dimensions (${img.width}  ${img.height}px) are smaller than required.\n\nMinimum size: ${expectedWidth}  ${expectedHeight}px`
                  );
                  currentImage = null;
                  currentImageDataUrl = null;
                  textureImageDataUrl = null;
                  fileInput.value = "";
                  updateUploadPlaceholder();
                  mainDraw();
                  return;
                }
              }

              const fullName = file.name;
              const dotIndex = fullName.lastIndexOf(".");
              let name = dotIndex !== -1 ? fullName.substring(0, dotIndex) : fullName;
              const ext = dotIndex !== -1 ? fullName.substring(dotIndex) : "";
              if (name.length > 12) name = name.substring(0, 12) + "...";
              uploadText.textContent = `${name}${ext}`;

              await processUploadedImage(img, shape);
            };
            img.onerror = () => {
              hideLoading();
              showError("Failed to Load Image", "The image file could not be loaded. Please try a different file format (PNG, JPG, etc.).");
              currentImage = null;
              currentImageDataUrl = null;
              textureImageDataUrl = null;
              fileInput.value = "";
              updateUploadPlaceholder();
              mainDraw();
            };
            img.src = e.target.result;
          };
          
          reader.onerror = () => {
            hideLoading();
            showError("File Read Error", "Failed to read the image file. Please try again.");
            fileInput.value = "";
            updateUploadPlaceholder();
            mainDraw();
          };
          
          reader.readAsDataURL(file);
        }
      }

      async function handleViewChange(event) {
        const newView = event.target.value;
        currentView = newView;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const groupName = shapeSelect.value;
          const group = shapeGroups[groupName];
          const newShapeKey = group[newView];

          if (newShapeKey) {
            currentShape = newShapeKey;
            updateUploadPlaceholder();
            currentImage = null;
            currentImageDataUrl = null;
            textureImageDataUrl = null;
            fileInput.value = "";

            const shape = getCurrentShape();
            load3DModel(shape);
            mainDraw();
          }
        }
      }

      async function handleShapeTypeChange(event) {
        currentShapeType = event.target.value;
        toggleViewSelector();
        updateSpecificShapeSelector();
        updateUploadPlaceholder();
        currentImage = null;
        currentImageDataUrl = null;
        textureImageDataUrl = null;
        fileInput.value = "";
        // Reset zoom and pan when changing shape type
        zoomLevel = 1;
        panX = 0;
        panY = 0;
        updateZoomDisplay();
        mainDraw();
      }

      async function handleShapeChange(event) {
        const selectedValue = event.target.value;

        if (currentShapeType === "sweet_box" || currentShapeType === "sweet_box_te") {
          const group = shapeGroups[selectedValue];
          currentShape = group.top || group.bottom;
        } else {
          currentShape = selectedValue;
        }

        syncSweetBoxViewControls();
        updateUploadPlaceholder();
        currentImage = null;
        currentImageDataUrl = null;
        textureImageDataUrl = null;
        fileInput.value = "";
        // Reset zoom and pan when changing shape
        zoomLevel = 1;
        panX = 0;
        panY = 0;
        updateZoomDisplay();

        const shape = getCurrentShape();
        load3DModel(shape);
        mainDraw();
      }

      // ========== EXPORT FUNCTIONS ==========

      // Upscale image for better quality export
      function upscaleImage(img, targetWidth, targetHeight) {
        return new Promise((resolve) => {
          const upscaleCanvas = document.createElement("canvas");
          upscaleCanvas.width = targetWidth;
          upscaleCanvas.height = targetHeight;
          const upscaleCtx = upscaleCanvas.getContext("2d");
          
          upscaleCtx.imageSmoothingEnabled = true;
          upscaleCtx.imageSmoothingQuality = "high";
          upscaleCtx.drawImage(img, 0, 0, targetWidth, targetHeight);
          
          const upscaledImg = new Image();
          upscaledImg.onload = () => resolve(upscaledImg);
          upscaledImg.src = upscaleCanvas.toDataURL("image/png", 1.0);
        });
      }

      async function exportPNG() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }

        isExporting = true;
        showLoading("Exporting PNG...", "Generating high-resolution image");

        await new Promise(r => setTimeout(r, 50));

        try {
          updateLoading("Exporting PNG...", "Upscaling image");
          
          // Upscale the source image if needed
          const targetImgWidth = shape.uploadDimensions ? shape.uploadDimensions.width * 2 : currentImage.width * 2;
          const targetImgHeight = shape.uploadDimensions ? shape.uploadDimensions.height * 2 : currentImage.height * 2;
          
          let processedImage = currentImage;
          if (currentImage.width < targetImgWidth || currentImage.height < targetImgHeight) {
            processedImage = await upscaleImage(currentImage, 
              Math.max(currentImage.width, targetImgWidth), 
              Math.max(currentImage.height, targetImgHeight)
            );
          }
          
          // Temporarily swap currentImage for export
          const originalImage = currentImage;
          currentImage = processedImage;
          
          updateLoading("Exporting PNG...", "Creating canvas");
          
          const exportWidth = shape.width * EXPORT_SCALE;
          const exportHeight = shape.height * EXPORT_SCALE;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const exportCtx = exportCanvas.getContext("2d", { alpha: true });

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PNG...", "Rendering image");

          drawShape(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, true, false);
          
          // Restore original image
          currentImage = originalImage;

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PNG...", "Generating file");

          const blob = await new Promise((resolve, reject) => {
            exportCanvas.toBlob(
              (b) => {
                if (b) resolve(b);
                else reject(new Error("Failed to create blob"));
              },
              "image/png",
              1.0
            );
          });

          updateLoading("Exporting PNG...", "Starting download");
          
          await triggerDownload(blob, `${currentShape}_Wrap.png`);
          
          hideLoading();
        } catch (error) {
          console.error("Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the PNG file. Please try again.");
        }
      }

      function hexToRgb(hex) {
        const h = hex.replace("#", "");
        const bigint = parseInt(h.length === 3 ? h.split("").map((c) => c + c).join("") : h, 16);
        return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
      }

      function rgbToCmyk(r, g, b) {
        const rn = r / 255, gn = g / 255, bn = b / 255;
        const k = 1 - Math.max(rn, gn, bn);
        if (k >= 1) return { c: 0, m: 0, y: 0, k: 1 };
        return { c: (1 - rn - k) / (1 - k), m: (1 - gn - k) / (1 - k), y: (1 - bn - k) / (1 - k), k };
      }

      function hexToCmykPercentString(hex) {
        const rgb = hexToRgb(hex);
        const cmyk = rgbToCmyk(rgb.r, rgb.g, rgb.b);
        const pc = (v) => Math.round(v * 100);
        return `${pc(cmyk.c)}% ${pc(cmyk.m)}% ${pc(cmyk.y)}% ${pc(cmyk.k)}%`;
      }

      function createSVGString() {
        const shape = getCurrentShape();
        if (!shape) return null;
        let svgContent = "";

        if (currentImage) {
          const exportWidth = shape.width * EXPORT_SCALE;
          const exportHeight = shape.height * EXPORT_SCALE;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const exportCtx = exportCanvas.getContext("2d", { alpha: true });
          renderImageContent(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, true, false);
          const rasterData = exportCanvas.toDataURL("image/png");
          svgContent = `<image x="0" y="0" width="${shape.width}" height="${shape.height}" xlink:href="${rasterData}" preserveAspectRatio="none" />`;
          svgContent += `\n<!-- CMYK-VECTORS-HINT: fill=${hexToCmykPercentString("#eeeeee")} (vectors only) -->`;
        } else {
          svgContent = `<path d="${shape.path}" fill="#eeeeee" data-cmyk-fill="${hexToCmykPercentString("#eeeeee")}" />`;
        }

        return `<?xml version="1.0" encoding="UTF-8"?>\n<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 ${shape.width} ${shape.height}" xml:space="preserve">\n${svgContent}\n</svg>`;
      }

      async function exportSVG() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }
        
        isExporting = true;
        showLoading("Exporting SVG...", "Creating vector file");

        await new Promise(r => setTimeout(r, 50));

        try {
          updateLoading("Exporting SVG...", "Generating content");
          
          const svgString = createSVGString();
          if (!svgString) {
            throw new Error("Failed to create SVG content");
          }

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting SVG...", "Starting download");

          const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
          await triggerDownload(blob, `${currentShape}_Wrap.svg`);
          
          hideLoading();
        } catch (error) {
          console.error("Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the SVG file. Please try again.");
        }
      }

      // ========== PDF EXPORT (Transparent Background for Adobe Illustrator) ==========
      async function exportPDF() {
        if (isExporting) return;
        
        if (!currentImage) {
          showError("No Image", "Please upload an image first before exporting.");
          return;
        }
        
        const shape = getCurrentShape();
        if (!shape) {
          showError("No Shape Selected", "Please select a shape before exporting.");
          return;
        }
        
        // Check if jsPDF is loaded
        if (typeof window.jspdf === 'undefined') {
          showError("Library Error", "PDF library not loaded. Please refresh the page and try again.");
          return;
        }

        isExporting = true;
        showLoading("Exporting PDF...", "Creating document");

        await new Promise(r => setTimeout(r, 50));

        try {
          const { jsPDF } = window.jspdf;
          
          updateLoading("Exporting PDF...", "Rendering image");
          
          // Create high-resolution canvas with TRANSPARENCY
          const exportWidth = shape.width * EXPORT_SCALE;
          const exportHeight = shape.height * EXPORT_SCALE;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const exportCtx = exportCanvas.getContext("2d", { alpha: true });
          
          // Clear with transparent background (NO white fill)
          exportCtx.clearRect(0, 0, exportWidth, exportHeight);
          
          // Draw only the shape content (no background)
          renderImageContent(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, false, false);

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PDF...", "Generating PDF");

          // Get image data as PNG to preserve transparency
          const imgData = exportCanvas.toDataURL('image/png');
          
          // Create PDF with exact dimensions
          const pdf = new jsPDF({
            orientation: shape.width > shape.height ? 'landscape' : 'portrait',
            unit: 'pt',
            format: [shape.width, shape.height],
            compress: true
          });
          
          // Add the transparent PNG image
          pdf.addImage(imgData, 'PNG', 0, 0, shape.width, shape.height, undefined, 'FAST');
          
          // Add metadata
          pdf.setProperties({
            title: `${currentShape}_Wrap`,
            subject: 'Label Wrap Export - Transparent Background',
            creator: 'Terra Tech Packs',
            keywords: 'label, wrap, packaging, transparent'
          });

          await new Promise(r => setTimeout(r, 50));
          updateLoading("Exporting PDF...", "Starting download");

          // Save the PDF
          pdf.save(`${currentShape}_Wrap.pdf`);
          
          await new Promise(r => setTimeout(r, 500));
          
          hideLoading();
        } catch (error) {
          console.error("PDF Export error:", error);
          hideLoading();
          showError("Export Failed", "Failed to generate the PDF file. Please try again.");
        }
      }

      // --- Event Listeners ---
      window.addEventListener("resize", debounce(mainDraw, 150));
      fileInput.addEventListener("input", handleImageUpload);
      exportPngBtn.addEventListener("click", exportPNG);
      exportSvgBtn.addEventListener("click", exportSVG);
      exportPdfBtn.addEventListener("click", exportPDF);
      shapeTypeSelect.addEventListener("change", handleShapeTypeChange);
      shapeSelect.addEventListener("change", handleShapeChange);
      document.querySelectorAll('input[name="view_type"]').forEach((radio) => {
        radio.addEventListener("change", handleViewChange);
      });

      // Zoom controls
      zoomInBtn.addEventListener("click", zoomIn);
      zoomOutBtn.addEventListener("click", zoomOut);
      zoomDisplay.addEventListener("click", resetZoom);
      resetPanBtn.addEventListener("click", resetPan);
      canvas.addEventListener("wheel", handleWheelZoom, { passive: false });

      // Pan controls - Mouse
      canvas.addEventListener("mousedown", startPan);
      window.addEventListener("mousemove", doPan);
      window.addEventListener("mouseup", endPan);
      window.addEventListener("mouseleave", endPan);

      // Pan controls - Touch
      canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
      canvas.addEventListener("touchend", handleTouchEnd);
      canvas.addEventListener("touchcancel", handleTouchEnd);

      // Pan controls - Keyboard (Space)
      window.addEventListener("keydown", handleSpaceDown);
      window.addEventListener("keyup", handleSpaceUp);

      // Handle window blur to reset space state
      window.addEventListener("blur", () => {
        isSpacePressed = false;
        endPan();
        updateCanvasCursor();
      });

      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey || e.metaKey) {
          if (e.key === "p") {
            e.preventDefault();
            exportPNG();
          } else if (e.key === "s") {
            e.preventDefault();
            exportSVG();
          } else if (e.key === "=" || e.key === "+") {
            e.preventDefault();
            zoomIn();
          } else if (e.key === "-") {
            e.preventDefault();
            zoomOut();
          } else if (e.key === "0") {
            e.preventDefault();
            resetZoom();
          }
        }
      });

      const fileUploadLabel = document.querySelector(".file-upload-label");
      fileUploadLabel.addEventListener("dragover", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.add("dragover");
      });
      fileUploadLabel.addEventListener("dragleave", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.remove("dragover");
      });
      fileUploadLabel.addEventListener("drop", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.remove("dragover");
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          fileInput.files = e.dataTransfer.files;
          fileInput.dispatchEvent(new Event("input", { bubbles: true }));
        }
      });

      // --- Initialization ---
      function initializeApp() {
        preProcessShapes();
        populateShapeTypes();
        toggleViewSelector();
        updateSpecificShapeSelector();
        updateUploadPlaceholder();
        updateZoomDisplay();
        mainDraw();
      }

      initializeApp();
    </script>
  </body>
</html>