<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bottle Label SVG Warper (Tailwind CSS)</title>
    <!-- Include Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Custom style for the drag-over effect and hiding radio button parents */
      .dragover {
        border-color: #3b82f6; /* Equivalent to border-blue-500 */
      }
      .radio-container.hidden {
          display: none;
      }
    </style>
  </head>
  <body class="bg-slate-100 flex flex-col h-screen overflow-hidden font-sans">

    <!-- === TOP CONTROLS BAR === -->
    <div class="bg-white shadow-md z-10">
      <div class="container mx-auto p-4 flex justify-center items-end flex-wrap gap-x-6 gap-y-4">

        <!-- Shape Type Selector -->
        <div class="flex flex-col">
          <label for="shapeTypeSelect" class="text-xs font-semibold text-slate-600 mb-1">Select Shape Type:</label>
          <select id="shapeTypeSelect" class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 transition cursor-pointer"></select>
        </div>

        <!-- Specific Shape Selector -->
        <div class="flex flex-col">
          <label for="shapeSelect" class="text-xs font-semibold text-slate-600 mb-1">Select Specific Shape:</label>
          <select id="shapeSelect" class="h-12 min-w-[180px] px-3 py-2 bg-white border-2 border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 hover:border-blue-500 transition cursor-pointer"></select>
        </div>

        <!-- Top/Bottom View Selector (for Sweet Box) -->
        <div id="viewSelector" class="hidden self-end pb-1">
          <div class="radio-group flex flex-col gap-1">
            <div class="radio-container">
              <input type="radio" id="viewTopRadio" name="view_type" value="top" class="cursor-pointer accent-blue-600">
              <label for="viewTopRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Top</label>
            </div>
            <div class="radio-container">
              <input type="radio" id="viewBottomRadio" name="view_type" value="bottom" checked class="cursor-pointer accent-blue-600">
              <label for="viewBottomRadio" class="text-sm ml-2 text-slate-700 cursor-pointer">Bottom</label>
            </div>
          </div>
        </div>

        <!-- File Upload Area -->
        <div id="dropArea" class="flex flex-col relative">
          <label for="imageUpload" class="text-xs font-semibold text-slate-600 mb-1">Upload Label:</label>
          <label class="file-upload-label h-12 min-w-[180px] flex items-center justify-center px-5 bg-slate-50 border-2 border-dashed border-slate-400 rounded-lg cursor-pointer hover:border-blue-500 transition" for="imageUpload">
            <input type="file" id="imageUpload" class="hidden" accept="image/*" />
            <small id="uploadText" class="font-medium text-slate-700">Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span></small>
          </label>
          <small id="imgError" class="hidden absolute -bottom-5 left-0 w-full text-center text-xs font-medium text-red-600"></small>
        </div>

        <!-- Export Buttons -->
        <button class="export h-12 px-6 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition" id="exportPngBtn">Export PNG</button>
        <button class="export h-12 px-6 bg-orange-500 text-white font-semibold rounded-lg hover:bg-orange-600 transition" id="exportSvgBtn">
          Export SVG
        </button>
        <button class="export h-12 px-6 bg-purple-600 text-white font-semibold rounded-lg hover:bg-purple-700 transition" id="exportAiBtn">
          Export AI
        </button>
      </div>
    </div>

    <!-- === CANVAS CONTAINER === -->
    <div class="flex-grow p-4 md:p-6 flex items-center justify-center">
      <canvas id="warpCanvas" class="w-full h-full bg-white rounded-lg shadow-sm"></canvas>
    </div>

    <script>
      let currentImage = null;
      let currentView = 'bottom';
      let currentShapeType = "round";
      let currentShape = "250ml_round";
      const EXPORT_SCALE = 4;

      const canvas = document.getElementById("warpCanvas");
      const ctx = canvas.getContext("2d");
      const uploadText = document.getElementById("uploadText");
      const imgError = document.getElementById("imgError");
      const dropArea = document.getElementById("dropArea");
      const fileInput = document.getElementById("imageUpload");
      const exportPngBtn = document.getElementById("exportPngBtn");
      const exportSvgBtn = document.getElementById("exportSvgBtn");
      const exportAiBtn = document.getElementById("exportAiBtn");
      const shapeTypeSelect = document.getElementById("shapeTypeSelect");
      const shapeSelect = document.getElementById("shapeSelect");
      const viewSelector = document.getElementById("viewSelector");

      class PathSampler {
        constructor(pathData) {
          this.pathNode = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          this.pathNode.setAttribute("d", pathData);
          this.length = this.pathNode.getTotalLength();
        }
        getPointAt(percentage) {
          return this.pathNode.getPointAtLength(this.length * percentage);
        }
      }

      const shapeTypes = {
        'round': 'Round',
        'round_square': 'Round Square',
        'rectangle': 'Rectangle',
        'sweet_box': 'Sweet Box',
        'sweet_box_te': 'Sweet Box TE' 
      };

      const allBottleShapes = {
        "250ml_round": {
          type: "round",
          view: "bottom",
          name: "250ml Round",
          width: 837,
          height: 244,
          path: "M1.37,162.42L73.32,242.27C283.84,56.41,576.84,75.5,764.01,242.27L835.96,162.42C597.61,-50.29,240.85,-53.15,1.37,162.42Z",
          topPath: "M 835.96,162.42 C 597.61,-50.29 240.85,-53.15 1.37,162.42",
          bottomPath:"M 73.32,242.27 C 283.84,56.41 576.84,75.5 764.01,242.27",
          topIsReversed: true,
          bottomIsReversed: false,
        },
        "300ml_round": {
          type: "round",
          view: "bottom",
          name: "300ml Round",
          width: 986.98,
          height: 332.17,
          path: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0l-5.32,1.98-45.71-122.15,6.01-2.21c286.86-105.52,601.92-105.52,888.78,0l6.04,2.15-45.75,122.2-5.3-1.98Z",
          topPath: "M49.08,172.19c286.86-105.52,601.92-105.52,888.78,0",
          bottomPath: "M892.85,294.57c-257.8-94.83-540.94-94.83-798.75,0",
          topIsReversed: false,
          bottomIsReversed: true,
        },
        "500ml_round": {
          type: "round",
          view: "bottom",
          name: "500ml Round",
          width: 945.18,
          height: 430.84,
          path: "M846.13,387.86c-120.06-43.77-245.71-65.96-373.55-65.96s-252.55,22.02-372.2,65.47l-.61-1.56L24.95,193.11l2.66-.97c143.01-52.15,292.69-78.58,444.97-78.58s301.97,26.44,444.98,78.59l2.65,1.01-74.09,194.71Z",
          topPath: "M27.61,192.14c143.01-52.15,292.69-78.58,444.97-78.58s301.97,26.44,444.98,78.59",
          bottomPath: "M846.13,387.86c-120.06-43.77-245.71-65.96-373.55-65.96s-252.55,22.02-372.2,65.47",
          topIsReversed: false,
          bottomIsReversed: true,
        },
        "750ml_round": {
          type: "round",
          view: "bottom",
          name: "750ml Round",
          width: 1187.25,
          height: 279.7,
          path: "M3.26,122.79c376.81-163.05,803.93-163.05,1180.74,0l2.6,1.21-1.14,2.55-67.28,150.03-1.21,2.45-2.49-1.01c-332.55-143.26-709.13-143.26-1041.68,0l-2.54,1.04-1.17-2.48L1.8,126.55l-1.14-2.63,2.6-1.13Z",
          topPath: "M3.26,122.79c376.81-163.05,803.93-163.05,1180.74,0",
          bottomPath: "M1114.48,278.02c-332.55-143.26-709.13-143.26-1041.68,0",
          topIsReversed: false,
          bottomIsReversed: true,
        },
        "1000ml_round": {
            type: "round",
            view: "bottom",
            name: "1000ml Round",
            width: 1186.89,
            height: 332.33,
            path: "M97.62,331.03L114.97,323.22L137.59,313.59L160.4,304.43L183.4,295.74L206.58,287.53L229.93,279.8L253.44,272.55L277.1,265.79L300.9,259.51L324.82,253.73L348.86,248.44L373.02,243.64L397.25,239.35L421.59,235.56L446,232.27L470.46,229.48L494.99,227.2L519.56,225.42L544.16,224.15L568.78,223.39L593.42,223.14L618.06,223.39L642.68,224.15L667.28,225.42L691.84,227.2L716.36,229.48L740.84,232.27L765.25,235.56L789.58,239.35L813.82,243.64L837.98,248.44L862.02,253.73L885.93,259.51L909.74,265.79L933.4,272.55L956.9,279.8L980.26,287.53L1003.43,295.74L1026.43,304.43L1049.25,313.59L1071.87,323.22L1089.23,331.04L1091.77,332.1L1092.96,329.66L1185.4,132.99L1186.65,130.47L1184,129.2L1161.31,118.99L1134.45,107.56L1107.36,96.68L1080.05,86.36L1052.53,76.61L1024.8,67.43L996.9,58.83L968.81,50.8L940.56,43.35L912.17,36.48L883.63,30.21L854.97,24.52L826.19,19.42L797.32,14.92L768.35,11.01L739.31,7.71L710.21,5L681.06,2.89L651.87,1.39L622.65,.48L593.42,.18L564.19,.48L534.97,1.39L505.78,2.89L476.63,5L447.52,7.71L418.48,11.01L389.52,14.92L360.64,19.42L331.87,24.52L303.21,30.21L274.67,36.48L246.27,43.35L218.03,50.8L189.94,58.83L162.03,67.43L134.31,76.61L106.79,86.36L79.47,96.68L52.38,107.56L25.53,118.99L2.83,129.21L.24,130.46L1.42,132.99L93.89,329.65L95.16,332.1L97.62,331.03Z",
            topPath: "M2.83,129.21L25.53,118.99L52.38,107.56L79.47,96.68L106.79,86.36L134.31,76.61L162.03,67.43L189.94,58.83L218.03,50.8L246.27,43.35L274.67,36.48L303.21,30.21L331.87,24.52L360.64,19.42L389.52,14.92L418.48,11.01L447.52,7.71L476.63,5L505.78,2.89L534.97,1.39L564.19,.48L593.42,.18L622.65,.48L651.87,1.39L681.06,2.89L710.21,5L739.31,7.71L768.35,11.01L797.32,14.92L826.19,19.42L854.97,24.52L883.63,30.21L912.17,36.48L940.56,43.35L968.81,50.8L996.9,58.83L1024.8,67.43L1052.53,76.61L1080.05,86.36L1107.36,96.68L1134.45,107.56L1161.31,118.99L1184,129.2",
            bottomPath: "M97.62,331.03L114.97,323.22L137.59,313.59L160.4,304.43L183.4,295.74L206.58,287.53L229.93,279.8L253.44,272.55L277.1,265.79L300.9,259.51L324.82,253.73L348.86,248.44L373.02,243.64L397.25,239.35L421.59,235.56L446,232.27L470.46,229.48L494.99,227.2L519.56,225.42L544.16,224.15L568.78,223.39L593.42,223.14L618.06,223.39L642.68,224.15L667.28,225.42L691.84,227.2L716.36,229.48L740.84,232.27L765.25,235.56L789.58,239.35L813.82,243.64L837.98,248.44L862.02,253.73L885.93,259.51L909.74,265.79L933.4,272.55L956.9,279.8L980.26,287.53L1003.43,295.74L1026.43,304.43L1049.25,313.59L1071.87,323.22L1089.23,331.04",
            topIsReversed: false,
            bottomIsReversed: false,
        },
        "450ml_round_square": {
          type: "round_square",
          view: "bottom",
          name: "450ml Round Square",
          width: 879.22,
          height: 276.16,
          path: "M93.16,274.8l9.48-5.52c16.09-9.47,32.49-18.51,49.08-27.07l8.02-3.94c9.34-4.49,18.91-8.56,28.62-12.17,8.99-3.3,18.11-6.37,27.27-9.18,15.76-4.79,31.65-9.33,47.56-13.57,18.8-5.19,37.79-9.92,56.83-14.14l9.07-1.84,8.27-1.5c10.82-1.83,21.76-3.15,32.71-3.94,9.81-.7,19.67-1.17,29.5-1.4,21.39-.46,42.86-.55,64.25-.29,12.27.09,24.57.47,36.82,1.13,13.8.7,27.58,2.2,41.2,4.49,9.2,1.6,18.39,3.47,27.48,5.58,15.63,3.68,31.23,7.65,46.71,11.9,15.9,4.24,31.78,8.78,47.53,13.56,9.16,2.81,18.27,5.88,27.27,9.19,9.71,3.61,19.29,7.68,28.62,12.17,9.02,4.37,17.96,8.98,26.74,13.81,13.78,7.6,26.32,14.75,39.8,22.73l1.29.69.73-1.14,89.79-152.32.72-1.21-1.24-.73-13.45-7.78-11.35-6.29-11.74-6.21-12.33-6.23c-19.27-9.43-38.9-18.29-58.72-26.51l-16-6.53-15.31-5.99-14.52-5.41-13.83-4.89c-23.21-8.03-46.9-14.84-70.84-20.34-19.14-4.36-38.5-8.07-57.9-11.09-11.43-1.81-22.92-3.44-34.4-4.91l-19.63-2.35c-18.16-2.05-36.45-3.52-54.71-4.39-9.72-.44-19.47-.67-29.2-.68h-3.78s-3.78,0-3.78,0l-6.4.04-12.28.25-10.51.39-15.42.86c-13.11.89-26.23,2.07-39.29,3.53l-19.63,2.35c-24.07,3.03-48.1,6.91-71.9,11.61-30.91,6.14-61.46,14.42-91.24,24.74l-13.82,4.89-14.52,5.41-15.31,5.99-16,6.53c-19.82,8.21-39.45,17.07-58.72,26.51l-12.33,6.22-11.74,6.21-11.35,6.29-13.43,7.79-1.22.71.71,1.24,89.83,152.25.7,1.19,1.24-.69Z",
          topPath: "M1.22,123.55l13.43-7.79l11.35-6.29l11.74-6.21l12.33-6.22c19.27-9.44,38.9-18.3,58.72-26.51l16-6.53l15.31-5.99l14.52-5.41l13.82-4.89c30.78-10.32,60.33-18.6,91.24-24.74c24.07-4.7,47.83-8.58,71.9-11.61l19.63-2.35c13.06-1.46,26.18-2.64,39.29-3.53l15.42-.86l10.51-.39l12.28-.25l6.4-.04h3.78s3.78,0,3.78,0c9.73.01,19.48.24,29.2.68c18.26.87,36.55,2.34,54.71,4.39l19.63,2.35c11.48,1.47,22.97,3.1,34.4,4.91c19.4,3.02,38.76,6.73,57.9,11.09c23.94,5.5,47.63,12.31,70.84,20.34l13.83,4.89l14.52,5.41l15.31,5.99l16,6.53c19.82,8.22,39.45,17.08,58.72,26.51l12.33,6.23l11.74,6.21l11.35,6.29l13.45,7.78",
          bottomPath: "M93.16,274.8l9.48-5.52c16.09-9.47,32.49-18.51,49.08-27.07l8.02-3.94c9.34-4.49,18.91-8.56,28.62-12.17,8.99-3.3,18.11-6.37,27.27-9.18,15.76-4.79,31.65-9.33,47.56-13.57,18.8-5.19,37.79-9.92,56.83-14.14l9.07-1.84,8.27-1.5c10.82-1.83,21.76-3.15,32.71-3.94,9.81-.7,19.67-1.17,29.5-1.4,21.39-.46,42.86-.55,64.25-.29,12.27.09,24.57.47,36.82,1.13,13.8.7,27.58,2.2,41.2,4.49,9.2,1.6,18.39,3.47,27.48,5.58,15.63,3.68,31.23,7.65,46.71,11.9,15.9,4.24,31.78,8.78,47.53,13.56,9.16,2.81,18.27,5.88,27.27,9.19,9.71,3.61,19.29,7.68,28.62,12.17,9.02,4.37,17.96,8.98,26.74,13.81,13.78,7.6,26.32,14.75,39.8,22.73",
          topIsReversed: false,
          bottomIsReversed: false,
        },
        "500ml_round_square": {
          type: "round_square",
          view: "bottom",
          name: "500ml Round Square",
          width: 888.9,
          height: 297.78,
          path: "M100.22,295.91c7.22-3.68,14.49-7.33,21.74-10.94,12.31-6.17,24.8-12.07,37.38-17.66l8.32-3.56c6.19-2.59,12.48-5.01,18.81-7.25,6.79-2.39,13.66-4.62,20.55-6.67,11.2-3.29,22.5-6.38,33.82-9.23,17.32-4.36,34.73-8.55,52.14-12.54,13.13-3.03,26.38-5.76,39.64-8.17,10.65-1.91,21.41-3.37,32.18-4.37,11.78-1.02,23.62-1.67,35.44-1.95,14.74-.34,29.53-.51,44.27-.49,14.74-.01,29.53.15,44.27.49,9.56.23,19.14.7,28.68,1.39,8.72.64,17.44,1.59,26.09,2.85,7.55,1.11,15.1,2.41,22.59,3.88,14.87,2.96,29.72,6.21,44.47,9.74,16.79,3.93,33.58,8.09,50.26,12.45l11.22,3.06,9.92,2.87,8.8,2.71c10.34,3.28,20.56,7.03,30.56,11.21,9.38,3.95,18.7,8.14,27.88,12.53,13.21,6.34,26.37,12.87,39.42,19.55l2.4,1.28,1.41-2.51,94.51-184.07,1.26-2.46-2.5-1.36-12.45-6.29-12.14-5.86-12.54-5.77-13.15-5.78-14.04-5.89-15.25-6.12-16.64-6.41c-16.62-6.28-33.41-12.25-50.26-17.87-14.15-4.7-28.45-9.06-42.81-13.06-17.59-4.88-35.41-9.14-53.32-12.73-26.55-5.22-53.37-9.42-80.24-12.58-18.01-2.19-36.11-4-54.19-5.45l-17.34-1.16-14.62-.7c-10.74-.42-21.52-.6-32.26-.54-10.72-.06-21.47.13-32.18.54l-14.58.7-17.36,1.16-4.33.34-14.71,1.29-18.35,1.87c-25.34,2.71-50.66,6.23-75.78,10.52-29.81,5.17-59.39,12.09-88.41,20.67l-14.1,4.3c-10.3,3.24-20.58,6.65-30.78,10.2l-16.94,6.02c-16.55,5.99-33.03,12.33-49.33,18.98l-14.02,5.88-13.15,5.78-12.54,5.77-12.14,5.86-12.59,6.36-2.54,1.32,1.3,2.52c31.81,61.1,63.35,122.59,94.42,184.07l1.32,2.45,2.5-1.2Z",
          topPath:"M 881.89,111.84 l-12.45-6.29 -12.14-5.86 -12.54-5.77 -13.15-5.78 -14.04-5.89 -15.25-6.12 -16.64-6.41 c-16.62-6.28 -33.41-12.25 -50.26-17.87 -14.15-4.7 -28.45-9.06 -42.81-13.06 -17.59-4.88 -35.41-9.14 -53.32-12.73 -26.55-5.22 -53.37-9.42 -80.24-12.58 -18.01-2.19 -36.11-4 -54.19-5.45 l-17.34-1.16 -14.62-0.7 c-10.74-.42 -21.52-.6 -32.26-.54 -10.72-.06 -21.47.13 -32.18.54 l-14.58.7 -17.36,1.16 -4.33.34 -14.71,1.29 -18.35,1.87 c-25.34,2.71 -50.66,6.23 -75.78,10.52 -29.81,5.17 -59.39,12.09 -88.41,20.67 l-14.1,4.3 c-10.3,3.24 -20.58,6.65 -30.78,10.2 l-16.94,6.02 c-16.55,5.99 -33.03,12.33 -49.33,18.98 l-14.02,5.88 -13.15,5.78 -12.54,5.77 -12.14,5.86 -12.59,6.36",
          bottomPath: "M100.22,295.91c7.22-3.68,14.49-7.33,21.74-10.94,12.31-6.17,24.8-12.07,37.38-17.66l8.32-3.56c6.19-2.59,12.48-5.01,18.81-7.25,6.79-2.39,13.66-4.62,20.55-6.67,11.2-3.29,22.5-6.38,33.82-9.23,17.32-4.36,34.73-8.55,52.14-12.54,13.13-3.03,26.38-5.76,39.64-8.17,10.65-1.91,21.41-3.37,32.18-4.37,11.78-1.02,23.62-1.67,35.44-1.95,14.74-.34,29.53-.51,44.27-.49,14.74-.01,29.53.15,44.27.49,9.56.23,19.14.7,28.68,1.39,8.72.64,17.44,1.59,26.09,2.85,7.55,1.11,15.1,2.41,22.59,3.88,14.87,2.96,29.72,6.21,44.47,9.74,16.79,3.93,33.58,8.09,50.26,12.45l11.22,3.06,9.92,2.87,8.8,2.71c10.34,3.28,20.56,7.03,30.56,11.21,9.38,3.95,18.7,8.14,27.88,12.53,13.21,6.34,26.37,12.87,39.42,19.55",
          topIsReversed: true,
          bottomIsReversed: false,
        },
        "750ml_rectangle": {
            type: "rectangle",
            view: "bottom",
            name: "500ml / 750ml Rectangle",
            width: 462.62,
            height: 309.76,
            path: "M.99,47.31 C.99,21.73 21.73,.99 47.31,.99 H 415.31 C 440.89,.99 461.63,21.73 461.63,47.31 V 262.45 C 461.63,288.03 440.89,308.77 415.31,308.77 H 47.31 C 21.73,308.77 .99,288.03 .99,262.45 Z",
            topPath: "M.99,47.31 C.99,21.73 21.73,.99 47.31,.99 H 415.31 C 440.89,.99 461.63,21.73 461.63,47.31",
            bottomPath: "M.99,262.45 C.99,288.03 21.73,308.77 47.31,308.77 H 415.31 C 440.89,308.77 461.63,288.03 461.63,262.45",
            topIsReversed: false,
            bottomIsReversed: false,
        },
        "1kg_sweet_box_top": {
            type: "sweet_box",
            view: "top",
            name: "1kg Sweet Box",
            width: 636.39,
            height: 455.59,
            path: "M.5.5 h635.39 v454.59 h-635.39 Z",
            topPath: "M0,0 H636.39",
            bottomPath: "M0,455.59 H636.39",
            topIsReversed: false,
            bottomIsReversed: false,
        },
        "250ml_sweet_box_top": {
            type: "sweet_box",
            view: "top",
            name: "250ml Sweet Box",
            width: 361,
            height: 273.49,
            path: "M9.29.5h342.4c4.85,0,8.82,3.94,8.82,8.79v254.92c0,4.82-3.97,8.79-8.82,8.79H9.29c-4.85,0-8.79-3.97-8.79-8.79V9.29C.5,4.44,4.44.5,9.29.5Z",
            topPath: "M0,0 H361",
            bottomPath: "M0,273.49 H361",
            topIsReversed: false,
            bottomIsReversed: false,
        },
        "500ml_sweet_box_top": {
            type: "sweet_box",
            view: "top",
            name: "500ml Sweet Box",
            width: 495.82,
            height: 351.4,
            path: "M489.44,351.01H6.42c-3.32,0-6.04-2.72-6.04-6.04V6.38C.38,3.1,3.09.38,6.42.38h483.02c3.29,0,6.01,2.72,6.01,6.01v338.6c0,3.32-2.72,6.04-6.01,6.04h0Z",
            topPath: "M0,0 H495.82",
            bottomPath: "M0,351.4 H495.82",
            topIsReversed: false,
            bottomIsReversed: false,
        },
        "250ml_sweet_box_bottom": {
          type: "sweet_box",
          view: "bottom",
          name: "250ml Sweet Box",
          width: 1342.58,
          height: 189.54,
          path: "M662.63.55l-278.9,13.66c-.26,0-.48.03-.74.09L8.88,81.16l-8.31,1.59,1.42,8.27,15.85,89.69,1.64,8.25,8.26-1.36,367.77-65.74c1.19-.23,2.41-.37,3.6-.43l259.43-12.7c1.3-.06,2.64-.03,3.94.09h.11l365.58,24.6c1.84.14,3.69.45,5.44.93.14.03.26.06.37.09l266.12,52.89,7.12,1.34,2.57-6.92,29.28-86.34,2.87-8.88-9.25-2.2-289.39-57.68c-2.38-.62-4.82-1.02-7.28-1.19L668.08.66c-1.16-.11-2.33-.16-3.49-.16-.65,0-1.3.02-1.95.05",
          topPath: "M8.88,81.16 L382.99,14.3 c.26-.06 .48-.09 .74-.09 L662.63,0.55 c.65-.03 1.3-.05 1.95-.05 c1.16,0 2.33.05 3.49.16 L1042.28,24.34 c2.46.17 4.9.57 7.28,1.19 l289.39,57.68",
          bottomPath: "M27.74, 187.6 l367.77-65.74 c1.19-.23,2.41-.37,3.6-.43 l259.43-12.7 c1.3-.06,2.64-.03,3.94.09 h.11 l365.58,24.6 c1.84.14,3.69.45,5.44.93 .14.03 .26.06 .37.09 l266.12,52.89",
          topIsReversed: false,
          bottomIsReversed: false,
        },
        "500ml_sweet_box_bottom": {
          type: "sweet_box",
          view: "bottom",
          name: "500ml Sweet Box",
          width: 1798.7,
          height: 215.31,
          path: "M1758.59,213.74l-356.09-70.07c-3.32-.65-6.69-1.11-10.09-1.33l-505.42-33.33c-2.98-.2-5.98-.23-8.96-.09l-341.4,15.99c-3.4.14-6.8.54-10.15,1.13L31.24,213.68l-4.25.74c-3.77.65-7.4-1.84-8.14-5.64L.63,115.74c-.37-1.87.06-3.83,1.13-5.41,1.1-1.59,2.78-2.64,4.68-2.92l4.14-.68L503.67,19.45c3.83-.68,7.68-1.1,11.57-1.3L890,.6c3.4-.17,6.83-.11,10.23.11l495.47,32.68c3.85.25,7.71.76,11.54,1.5l381.26,75.03,4.05.85c1.96.4,3.63,1.59,4.65,3.29,1.02,1.73,1.28,3.77.71,5.67l-26.79,90c-1.05,3.54-4.68,5.7-8.28,4.9l-4.25-.91Z",
          topPath:"M.63,115.74c-.37-1.87.06-3.83,1.13-5.41,1.1-1.59,2.78-2.64,4.68-2.92l4.14-.68L503.67,19.45c3.83-.68,7.68-1.1,11.57-1.3L890,.6c3.4-.17,6.83-.11,10.23.11l495.47,32.68c3.85.25,7.71.76,11.54,1.5l381.26,75.03,4.05.85c1.96.4,3.63,1.59,4.65,3.29,1.02,1.73,1.28,3.77.71,5.67",
          bottomPath:"M1758.59,213.74l-356.09-70.07c-3.32-.65-6.69-1.11-10.09-1.33l-505.42-33.33c-2.98-.2-5.98-.23-8.96-.09l-341.4,15.99c-3.4.14-6.8.54-10.15,1.13L31.24,213.68",
          topIsReversed: false,
          bottomIsReversed: true,
        },
        "250ml_sweet_box_te_top": {
            type: "sweet_box_te",
            view: "top",
            name: "250ml Sweet Box TE",
            width: 378.23,
            height: 296.16,
            path: "M 344.73 .5 346.35 .54 347.96 .65 349.57 .85 351.17 1.12 354.31 1.92 357.36 3.01 360.29 4.39 363.07 6.05 365.67 7.98 368.07 10.17 370.24 12.57 372.18 15.16 373.84 17.94 375.23 20.88 376.32 23.93 377.11 27.07 377.38 28.66 377.58 30.27 377.7 31.89 377.73 33.51 377.73 262.66 377.7 264.28 377.58 265.89 377.38 267.5 377.11 269.1 376.32 272.24 375.23 275.29 373.84 278.22 372.18 281 370.24 283.6 368.07 286 365.67 288.17 363.07 290.11 360.29 291.77 357.36 293.15 354.31 294.24 351.17 295.03 349.57 295.31 347.96 295.51 346.35 295.62 344.73 295.66 33.51 295.66 31.89 295.62 30.27 295.51 28.66 295.31 27.07 295.03 23.92 294.24 20.88 293.15 17.94 291.77 15.16 290.11 12.56 288.17 10.17 286 7.99 283.6 6.06 281 4.39 278.22 3.01 275.29 1.92 272.24 1.13 269.1 .85 267.5 .66 265.89 .54 264.28 .5 262.66 .5 33.51 .54 31.89 .66 30.27 .85 28.66 1.13 27.07 1.92 23.93 3.01 20.88 4.39 17.94 6.06 15.16 7.99 12.57 10.17 10.17 12.56 7.98 15.16 6.05 17.94 4.39 20.88 3.01 23.92 1.92 27.07 1.12 28.66 .85 30.27 .65 31.89 .54 33.51 .5 344.73 .5 Z",
            topPath: "M0,0 H378.23",
            bottomPath: "M0,296.16 H378.23",
            topIsReversed: false,
            bottomIsReversed: false,
        },
        "250ml_sweet_box_te_bottom": {
            type: "sweet_box_te",
            view: "bottom",
            name: "250ml Sweet Box TE",
            width: 557.78,
            height: 475.73,
            path: "M437.53,98.37c12.09,0,21.88,9.8,21.88,21.88h97.87v235.23h-97.87c0,12.08-9.79,21.88-21.88,21.88h0v97.87H120.25v-97.86h0c-12.09-.01-21.88-9.81-21.88-21.89H.5V120.25h97.87c0-12.08,9.79-21.88,21.88-21.88h0V.5h317.28v97.86h0Z",
            topPath: "M0,0 H557.78",
            bottomPath: "M0,475.73 H557.78",
            topIsReversed: false,
            bottomIsReversed: false,
        },
        "500ml_sweet_box_te_bottom": {
            type: "sweet_box_te",
            view: "bottom",
            name: "500ml Sweet Box TE",
            width: 695.7,
            height: 560.63,
            path: "M 122.64 3.76 122.39 .92 572.87 .5 572.62 3.34 563.84 104.14 564.26 104.14 566.94 104.29 569.58 104.7 572.17 105.36 574.68 106.27 577.09 107.42 579.38 108.8 581.52 110.39 583.5 112.18 585.29 114.16 586.88 116.3 588.26 118.59 589.41 121 590.32 123.51 590.98 126.1 591.39 128.74 591.54 131.41 591.54 131.84 692.37 123.05 695.2 122.78 695.2 437.82 692.37 437.58 591.54 428.8 591.54 429.22 591.28 432.82 590.5 436.5 589.18 440.16 587.3 443.69 584.89 446.96 582 449.84 578.74 452.26 575.21 454.14 571.54 455.46 567.86 456.23 564.26 456.5 563.84 456.5 572.62 557.3 572.88 560.13 122.39 559.7 122.64 556.87 131.39 456.5 130.96 456.5 127.37 456.23 123.69 455.46 120.02 454.14 116.49 452.26 113.23 449.84 110.34 446.96 107.93 443.69 106.05 440.16 104.72 436.5 103.95 432.82 103.69 429.22 103.69 428.99 103.69 428.8 3.34 437.54 .5 437.78 .5 122.84 3.34 123.09 103.69 131.84 103.69 131.64 103.69 131.41 103.95 127.82 104.72 124.14 106.05 120.47 107.93 116.94 110.34 113.68 113.23 110.79 116.49 108.38 120.02 106.5 123.69 105.17 127.37 104.4 130.96 104.14 131.39 104.14 122.64 3.76 Z",
            topPath: "M 131.39 104.14 H 563.84",
            bottomPath: "M 131.39 456.5 H 563.84",
            topIsReversed: false,
            bottomIsReversed: false,
        },
        "500ml_sweet_box_te_top": {
            type: "sweet_box_te",
            view: "top",
            name: "500ml Sweet Box TE",
            width: 509.61,
            height: 374.16,
            path: "M3.86,28.85C4.36,15.15,15.42,4.2,29.12,3.86,179.56.04,330.06.04,480.5,3.86c13.7.34,24.76,11.29,25.26,24.99,3.82,105.45,3.82,211.01,0,316.46-.5,13.7-11.56,24.65-25.26,25-150.44,3.81-300.94,3.81-451.38,0-13.7-.35-24.76-11.3-25.26-25C.04,239.86.04,134.3,3.86,28.85Z",
            topPath: "M0,0 H509.61",
            bottomPath: "M0,374.16 H509.61",
            topIsReversed: false,
            bottomIsReversed: false,
        }
      };

      const shapeGroups = {};
      const keyToGroupName = {};
      
      // Pre-process shapes to create helper maps for faster lookups
      function preProcessShapes() {
        for (const [key, shape] of Object.entries(allBottleShapes)) {
          // Initialize path samplers
          shape.topSampler = new PathSampler(shape.topPath);
          shape.bottomSampler = new PathSampler(shape.bottomPath);
          
          // Group shapes by name for sweet box logic
          if (!shapeGroups[shape.name]) {
              shapeGroups[shape.name] = {};
          }
          shapeGroups[shape.name][shape.view] = key;
          
          // Map individual keys back to their group name
          keyToGroupName[key] = shape.name;
        }
      }

      function getCurrentShape() {
        return currentShape ? allBottleShapes[currentShape] : null;
      }

      function toggleViewSelector() {
          if (currentShapeType === 'sweet_box' || currentShapeType === 'sweet_box_te') {
              viewSelector.classList.remove('hidden');
          } else {
              viewSelector.classList.add('hidden');
          }
      }

      function syncSweetBoxViewControls() {
        const topRadioDiv = document.getElementById('viewTopRadio').parentElement;
        const bottomRadioDiv = document.getElementById('viewBottomRadio').parentElement;

       if ((currentShapeType !== 'sweet_box' && currentShapeType !== 'sweet_box_te') || !currentShape) {
            topRadioDiv.classList.add('hidden');
            bottomRadioDiv.classList.add('hidden');
            return;
        }

        const groupName = keyToGroupName[currentShape];
        const group = shapeGroups[groupName];

        topRadioDiv.classList.toggle('hidden', !group.top);
        bottomRadioDiv.classList.toggle('hidden', !group.bottom);

        if (currentShape.endsWith('_top')) {
            currentView = 'top';
            document.getElementById('viewTopRadio').checked = true;
        } else if (currentShape.endsWith('_bottom')) {
            currentView = 'bottom';
            document.getElementById('viewBottomRadio').checked = true;
        }
      }

      function updateSpecificShapeSelector() {
          shapeSelect.innerHTML = "";
          let firstShapeKey = null;

          if (currentShapeType === 'sweet_box' || currentShapeType === 'sweet_box_te') {
              const uniqueNames = new Set();
              for (const key in allBottleShapes) {
                  const shape = allBottleShapes[key];
                  if (shape.type === currentShapeType && !uniqueNames.has(shape.name)) {
                      uniqueNames.add(shape.name);
                      const option = document.createElement("option");
                      option.value = shape.name; 
                      option.textContent = shape.name;
                      shapeSelect.appendChild(option);
                  }
              }
              if (shapeSelect.options.length > 0) {
                  const selectedName = shapeSelect.options[0].value;
                  shapeSelect.value = selectedName;
                  const group = shapeGroups[selectedName];
                  firstShapeKey = group.top || group.bottom;
              }
          } else {
              for (const [key, shape] of Object.entries(allBottleShapes)) {
                  if (shape.type === currentShapeType) {
                      const option = document.createElement("option");
                      option.value = key;
                      option.textContent = shape.name;
                      shapeSelect.appendChild(option);
                      if (!firstShapeKey) {
                          firstShapeKey = key;
                      }
                  }
              }
              if (firstShapeKey) {
                  shapeSelect.value = firstShapeKey;
              }
          }

          currentShape = firstShapeKey;
          syncSweetBoxViewControls();
      }
      
      function populateShapeTypes() {
        shapeTypeSelect.innerHTML = "";
        for(const [key, name] of Object.entries(shapeTypes)) {
          const option = document.createElement("option");
          option.value = key;
          option.textContent = name;
          shapeTypeSelect.appendChild(option);
        }
        shapeTypeSelect.value = currentShapeType;
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
      }

      function drawWarp(localCtx, img, shape, offsetX, offsetY, finalScale, isExport, heightAdjust = 1.0) {
        const sliceCount = isExport ? 4000 : 2000;
        const imgWidth = img.width;
        const imgHeight = img.height;
        const sourceSliceWidth = imgWidth / sliceCount;

        const isWideShape = (shape.type === 'round_square' || shape.type === 'sweet_box' || shape.type === 'sweet_box_te');
        const isSweetBox = (shape.type === 'sweet_box' || shape.type === 'sweet_box_te');
        const isLargeRound = (currentShape === '300ml_round' || currentShape === '500ml_round' || currentShape === '750ml_round' || currentShape === '1000ml_round');
        
        let baseOverlap;
        if (isSweetBox) {
          baseOverlap = isExport ? 40 : 20;
        } else if (isLargeRound) {
            baseOverlap = isExport ? 30 : 15;
        } else if (isWideShape) {
          baseOverlap = isExport ? 20 : 10;
        } else {
          baseOverlap = isExport ? 8 : 4;
        }

        const extendAmount = isSweetBox ? (isExport ? 30 : 15) : (isExport ? 10 : 5);
        const startOffset = -extendAmount;
        const endOffset = extendAmount;

        for (let i = startOffset; i < sliceCount + endOffset; i++) {
          const t0 = i / sliceCount;
          const t1 = (i + 1) / sliceCount;
          const edgeExtension = isSweetBox ? 0.03 : 0.01;
          const tTop0 = shape.topIsReversed ? 1 - t0 : t0;
          const tTop1 = shape.topIsReversed ? 1 - t1 : t1;
          const tBot0 = shape.bottomIsReversed ? 1 - t0 : t0;
          const tBot1 = shape.bottomIsReversed ? 1 - t1 : t1;
          const clampedTTop0 = Math.min(Math.max(tTop0, -edgeExtension), 1 + edgeExtension);
          const clampedTTop1 = Math.min(Math.max(tTop1, -edgeExtension), 1 + edgeExtension);
          const clampedTBot0 = Math.min(Math.max(tBot0, -edgeExtension), 1 + edgeExtension);
          const clampedTBot1 = Math.min(Math.max(tBot1, -edgeExtension), 1 + edgeExtension);

          if ((clampedTTop0 < -0.05 && clampedTTop1 < -0.05) || (clampedTTop0 > 1.05 && clampedTTop1 > 1.05)) continue;

          const pTop1 = shape.topSampler.getPointAt(Math.min(Math.max(clampedTTop0, 0), 1));
          const pBot1 = shape.bottomSampler.getPointAt(Math.min(Math.max(clampedTBot0, 0), 1));
          const pTop2 = shape.topSampler.getPointAt(Math.min(Math.max(clampedTTop1, 0), 1));
          const pBot2 = shape.bottomSampler.getPointAt(Math.min(Math.max(clampedTBot1, 0), 1));

          const top1X = pTop1.x * finalScale + offsetX;
          const top1Y = pTop1.y * finalScale + offsetY;
          const bot1X = pBot1.x * finalScale + offsetX;
          const bot1Y = pBot1.y * finalScale + offsetY;
          const top2X = pTop2.x * finalScale + offsetX;
          const top2Y = pTop2.y * finalScale + offsetY;
          const bot2X = pBot2.x * finalScale + offsetX;
          const bot2Y = pBot2.y * finalScale + offsetY;

          const midTopX = (top1X + top2X) / 2;
          const midTopY = (top1Y + top2Y) / 2;
          const midBotX = (bot1X + bot2X) / 2;
          const midBotY = (bot1Y + bot2Y) / 2;

          const sliceHeight = Math.hypot(midBotX - midTopX, midBotY - midTopY) * heightAdjust;
          const sliceAngle = Math.atan2(midBotY - midTopY, midBotX - midTopX) - Math.PI / 2;

          const topWidth = Math.hypot(top2X - top1X, top2Y - top1Y);
          const botWidth = Math.hypot(bot2X - bot1X, bot2Y - bot1Y);
          const sliceWidth = Math.max(topWidth, botWidth);
          
          let overlap = baseOverlap;
          if (isSweetBox) {
            const normalizedT = Math.min(Math.max(t0, 0), 1);
            if (isExport) {
              if (normalizedT < 0.02 || normalizedT > 0.98) { overlap = 80; } 
              else if (normalizedT < 0.05 || normalizedT > 0.95) { overlap = 60; } 
              else if (normalizedT < 0.1 || normalizedT > 0.9) { overlap = 40; } 
              else { const edgeFactor = Math.min(normalizedT * 3, (1 - normalizedT) * 3, 1); overlap = baseOverlap + (20 - baseOverlap) * (1 - edgeFactor); }
            } else {
              if (normalizedT < 0.05 || normalizedT > 0.95) { overlap = 40; } 
              else if (normalizedT < 0.1 || normalizedT > 0.9) { overlap = 30; } 
              else { overlap = 20; }
            }
          } else if (isWideShape) {
            const normalizedT = Math.min(Math.max(t0, 0), 1);
            const edgeFactor = Math.min(normalizedT * 5, (1 - normalizedT) * 5, 1);
            overlap = baseOverlap + (15 - baseOverlap) * (1 - edgeFactor);
            if (isExport) {
              if (normalizedT < 0.05 || normalizedT > 0.95) overlap += 25;
              else if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 15;
            } else {
              if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 10;
            }
          }
          else if (isLargeRound) {
            const normalizedT = Math.min(Math.max(t0, 0), 1);
            if (isExport) {
            if (normalizedT < 0.05 || normalizedT > 0.95) overlap += 25;
            else if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 15;
            } else {
            if (normalizedT < 0.1 || normalizedT > 0.9) overlap += 10;
            }
          }
          
          if (sliceWidth < 0.1) continue;

          localCtx.save();
          localCtx.translate(midTopX, midTopY);
          localCtx.rotate(sliceAngle);
          
          let verticalExtension = 0;
          if(shape.type !== 'rectangle') {
             if(isSweetBox) { verticalExtension = isExport ? 40 : 20; } 
             else if(isWideShape) { verticalExtension = isExport ? 22 : 10; } 
             else if (shape.type === "round") { 
              if(shape.name === "250ml Round"){
                verticalExtension = isExport ? 0 : 0;
              }else{
                verticalExtension = isExport ? 10 : 0; 
              }
            }
          }
          
          let sourceSliceIndex;
          if (i < 0) {
              sourceSliceIndex = 0;
          } else if (i >= sliceCount) {
              sourceSliceIndex = sliceCount - 1;
          } else {
              sourceSliceIndex = i;
          }

          const sourceX = sourceSliceIndex * sourceSliceWidth;
          
          localCtx.drawImage(
            img,
            sourceX, 0,
            sourceSliceWidth, imgHeight,
            -(sliceWidth + overlap) / 2, -verticalExtension,
            sliceWidth + overlap, sliceHeight + (verticalExtension * 2)
          );

          localCtx.restore();
        }
      }
      
      function renderImageContent(localCtx, targetW, targetH, isExport, exportScale, clearBackground) {
        if (clearBackground) {
          localCtx.clearRect(0, 0, targetW, targetH);
        }
        
        const shape = getCurrentShape();
        if (!shape) return;

        const margin = isExport ? 0 : 20;
        const scaleXFit = (targetW - 2 * margin) / shape.width;
        const scaleYFit = (targetH - 2 * margin) / shape.height;
        const finalScale = isExport ? exportScale : Math.min(scaleXFit, scaleYFit);

        const scaledW = shape.width * finalScale;
        const scaledH = shape.height * finalScale;
        const offsetX = (targetW - scaledW) / 2;
        const offsetY = (targetH - scaledH) / 2;
        
        const path = new Path2D(shape.path);
        const transformMatrix = new DOMMatrix();
        transformMatrix.translateSelf(offsetX, offsetY);
        transformMatrix.scaleSelf(finalScale, finalScale);
        
        if (currentImage) {
          localCtx.save();
          localCtx.transform(
            transformMatrix.a, transformMatrix.b, transformMatrix.c, 
            transformMatrix.d, transformMatrix.e, transformMatrix.f
          );
          localCtx.clip(path);
          
          localCtx.setTransform(1, 0, 0, 1, 0, 0);
          
          if (!isExport && window.devicePixelRatio && localCtx === ctx) {
          localCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
          }

          // Add horizontal shift for specific shapes
          let imageOffsetX = 0;
          const needsHorizontalShift = [ 
            '500ml_round', 
            '750ml_round', 
            '1000ml_round',
            '450ml_round_square',
            '500ml_round_square'
          ].includes(currentShape);
          
          if (needsHorizontalShift) {
            // Shift right - adjust this value to move more or less (positive = right, negative = left)
            imageOffsetX = isExport ? 22 : 5; // More shift for export, less for preview
          }

          // Check if the shape is flat (rectangle, top-view, or te-box) and should not be warped
          if (shape.type === 'rectangle' || shape.view === 'top' || shape.type === 'sweet_box_te') {
        
            let drawOffsetX = offsetX + imageOffsetX;
            let drawOffsetY = offsetY;
            let drawScaledW = scaledW;
            let drawScaledH = scaledH;

            // --- MODIFICATION: Add bleed for this specific shape ---
            if (currentShape === '250ml_sweet_box_te_bottom') {
              const scaleFactor = 1.029;
              drawScaledW = scaledW * scaleFactor;
              drawScaledH = scaledH * scaleFactor;
              // Re-center the oversized image so it scales from the middle
              drawOffsetX = offsetX - (drawScaledW - scaledW) / 2 + imageOffsetX;
              drawOffsetY = offsetY - (drawScaledH - scaledH) / 2;
            }
            // --- END MODIFICATION ---

            localCtx.drawImage(
              currentImage, 
              drawOffsetX, 
              drawOffsetY, 
              drawScaledW, 
              drawScaledH
            );
          } else {
                // For all other shapes, use the original perspective warp logic with offset
                const heightAdjust = 1.0;
                drawWarp(localCtx, currentImage, shape, offsetX + imageOffsetX, offsetY, finalScale, isExport, heightAdjust);
              }

          localCtx.restore();

        } else {
          localCtx.save();
          localCtx.transform(
            transformMatrix.a, transformMatrix.b, transformMatrix.c, 
            transformMatrix.d, transformMatrix.e, transformMatrix.f
          );
          localCtx.fillStyle = "#eee";
          localCtx.fill(path);
          localCtx.restore();
        }
      }

      function drawShape(localCtx, targetW, targetH, isExport, exportScale, clearBackground) {
        localCtx.imageSmoothingEnabled = true;
        localCtx.imageSmoothingQuality = "high";

        renderImageContent(localCtx, targetW, targetH, isExport, exportScale, clearBackground);
        
        const shape = getCurrentShape();
        if (!shape) {
            if (clearBackground) localCtx.clearRect(0,0,targetW * (window.devicePixelRatio || 1) ,targetH * (window.devicePixelRatio || 1));
            const dpr = window.devicePixelRatio || 1;
            localCtx.font = `${16 * dpr}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
            localCtx.textAlign = "center";
            localCtx.fillStyle = "#9ca3af";
            localCtx.fillText("No shapes available for this type/view.", targetW * dpr /2, targetH * dpr /2);
            return;
        }

        const margin = isExport ? 0 : 20;
        const scaleXFit = (targetW - 2 * margin) / shape.width;
        const scaleYFit = (targetH - 2 * margin) / shape.height;
        const finalScale = isExport ? exportScale : Math.min(scaleXFit, scaleYFit);
        const scaledW = shape.width * finalScale;
        const scaledH = shape.height * finalScale;
        const offsetX = (targetW - scaledW) / 2;
        const offsetY = (targetH - scaledH) / 2;
        
        const path = new Path2D(shape.path);
        const transformMatrix = new DOMMatrix();
        transformMatrix.translateSelf(offsetX, offsetY);
        transformMatrix.scaleSelf(finalScale, finalScale);
        
        localCtx.save();
        localCtx.transform(
          transformMatrix.a, transformMatrix.b, transformMatrix.c, 
          transformMatrix.d, transformMatrix.e, transformMatrix.f
        );
        localCtx.strokeStyle = "#ed312c";
        localCtx.lineWidth = isExport ? 0.75 : (2 / finalScale); 
        localCtx.stroke(path);
        localCtx.restore();
      }

      function mainDraw() {
        resizeCanvas();
        drawShape(ctx, canvas.clientWidth, canvas.clientHeight, false, 1, true);
      }

      function handleImageUpload(event) {
        const file = (event.target.files || [])[0];
        imgError.classList.add('hidden');
        imgError.innerHTML = "";

        if (!file) {
          currentImage = null;
          mainDraw();
          uploadText.innerHTML = 'Drag & drop or <span class="font-semibold text-blue-600 underline">Browse</span>';
          return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
          const img = new Image();
          img.onload = () => {
            const fullName = file.name;
            const dotIndex = fullName.lastIndexOf(".");
            let name =
              dotIndex !== -1 ? fullName.substring(0, dotIndex) : fullName;
            const ext = dotIndex !== -1 ? fullName.substring(dotIndex) : "";
            if (name.length > 12) name = name.substring(0, 12) + '...';
            uploadText.textContent = `${name}${ext}`;
            currentImage = img;
            mainDraw();
          };
          img.onerror = () => {
            imgError.classList.remove('hidden');
            imgError.textContent = "Failed to load image.";
            currentImage = null;
            mainDraw();
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }

      function handleViewChange(event) {
          const newView = event.target.value;
          currentView = newView;

          if (currentShapeType === 'sweet_box' || currentShapeType === 'sweet_box_te') {
              const groupName = shapeSelect.value;
              const group = shapeGroups[groupName];
              const newShapeKey = group[newView];
              
              if (newShapeKey) {
                  currentShape = newShapeKey;
                  mainDraw();
              }
          }
      }

      function handleShapeTypeChange(event) {
        currentShapeType = event.target.value;
        toggleViewSelector();
        updateSpecificShapeSelector();
        mainDraw();
      }

      function handleShapeChange(event) {
          const selectedValue = event.target.value;

          if (currentShapeType === 'sweet_box' || currentShapeType === 'sweet_box_te') {
              const group = shapeGroups[selectedValue];
              currentShape = group.top || group.bottom; 
          } else {
              currentShape = selectedValue;
          }
          
          syncSweetBoxViewControls();
          mainDraw();
      }

      function exportPNG() {
        if (!currentImage) {
          alert("Please upload an image first.");
          return;
        }
        const shape = getCurrentShape();
        if (!shape) {
            alert("No shape selected for export.");
            return;
        }
        const exportWidth = shape.width * EXPORT_SCALE;
        const exportHeight = shape.height * EXPORT_SCALE;
        const exportCanvas = document.createElement("canvas");
        exportCanvas.width = exportWidth;
        exportCanvas.height = exportHeight;
        const exportCtx = exportCanvas.getContext("2d", { alpha: true });
        
        drawShape(
          exportCtx,
          exportWidth,
          exportHeight,
          true,
          EXPORT_SCALE,
          true
        );
        
        exportCanvas.toBlob(
          (blob) => {
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `${currentShape}_Wrap.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          },
          "image/png",
          1.0
        );
      }

      function createSVGString() {
        const shape = getCurrentShape();
        if (!shape) return null;
        let svgContent = "";

        if (currentImage) {
          const exportWidth = shape.width * EXPORT_SCALE;
          const exportHeight = shape.height * EXPORT_SCALE;
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const exportCtx = exportCanvas.getContext("2d", { alpha: true });
          
          renderImageContent(exportCtx, exportWidth, exportHeight, true, EXPORT_SCALE, true);
          
          const rasterData = exportCanvas.toDataURL("image/png");

          svgContent = `<image x="0" y="0" width="${shape.width}" height="${shape.height}" xlink:href="${rasterData}" preserveAspectRatio="none" /><path d="${shape.path}" fill="none" stroke="#ed312c" stroke-width="0.75" stroke-miterlimit="10" />`;
        } else {
          svgContent = `<path d="${shape.path}" fill="#eeeeee" stroke="#ed312c" stroke-width="0.75" stroke-miterlimit="10" />`;
        }

        return `<?xml version="1.0" encoding="UTF-8"?>
        <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 ${shape.width} ${shape.height}" xml:space="preserve">
        ${svgContent}
        </svg>`;
      }

      function exportSVG() {
        const shape = getCurrentShape();
        if (!shape) {
            alert("No shape selected for export.");
            return;
        }
        const svgString = createSVGString();
        if (!svgString) return;

        const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `${currentShape}_Wrap.svg`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      
      function exportAI() {
        const shape = getCurrentShape();
        if (!shape) {
            alert("No shape selected for export.");
            return;
        }
        const svgString = createSVGString();
        if (!svgString) return;

        const blob = new Blob([svgString], { type: "application/postscript" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `${currentShape}_Wrap.ai`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // --- Event Listeners ---
      window.addEventListener("resize", mainDraw);
      fileInput.addEventListener("input", handleImageUpload);
      exportPngBtn.addEventListener("click", exportPNG);
      exportSvgBtn.addEventListener("click", exportSVG);
      exportAiBtn.addEventListener("click", exportAI);
      shapeTypeSelect.addEventListener("change", handleShapeTypeChange);
      shapeSelect.addEventListener("change", handleShapeChange);
      document.querySelectorAll('input[name="view_type"]').forEach(radio => {
        radio.addEventListener('change', handleViewChange);
      });

      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey || e.metaKey) {
          if (e.key === "p") {
            e.preventDefault();
            exportPNG();
          } else if (e.key === "s") {
            e.preventDefault();
            exportSVG();
          }
        }
      });

      const fileUploadLabel = document.querySelector('.file-upload-label');
      fileUploadLabel.addEventListener("dragover", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.add("dragover");
      });
      fileUploadLabel.addEventListener("dragleave", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.remove("dragover");
      });
      fileUploadLabel.addEventListener("drop", (e) => {
        e.preventDefault();
        fileUploadLabel.classList.remove("dragover");
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          fileInput.files = e.dataTransfer.files;
          const event = new Event("input", { bubbles: true });
          fileInput.dispatchEvent(event);
        }
      });
      
      // --- Initialization ---
      function initializeApp() {
        preProcessShapes();
        populateShapeTypes();
        toggleViewSelector();
        updateSpecificShapeSelector();
        mainDraw();
      }

      initializeApp();
    </script>
  </body>
</html>